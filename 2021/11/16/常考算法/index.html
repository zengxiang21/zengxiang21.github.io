<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>常考算法 | zx的博客</title><meta name="keywords" content="博客,zx"><meta name="author" content="zengxiang"><meta name="copyright" content="zengxiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.排序算法 1234在排序元素基本有序的前提下	插入排序效率最高，退化为O(n)插入排序最坏情况下比较n(n-1)&#x2F;2次，最好情况下比较n次快速排序在基本有序的情况下退化为O(n^2)  稳定的排序12冒泡、插入、归并贵插茂  冒泡排序1234567891011121314151617181920[i,nums.size()-1]为排好序的void bubblesort(vector&lt;in">
<meta property="og:type" content="article">
<meta property="og:title" content="常考算法">
<meta property="og:url" content="https://zengxiang21.github.io/2021/11/16/%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="zx的博客">
<meta property="og:description" content="1.排序算法 1234在排序元素基本有序的前提下	插入排序效率最高，退化为O(n)插入排序最坏情况下比较n(n-1)&#x2F;2次，最好情况下比较n次快速排序在基本有序的情况下退化为O(n^2)  稳定的排序12冒泡、插入、归并贵插茂  冒泡排序1234567891011121314151617181920[i,nums.size()-1]为排好序的void bubblesort(vector&lt;in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsum.photos/id/85/1280/774">
<meta property="article:published_time" content="2021-11-16T08:25:13.867Z">
<meta property="article:modified_time" content="2022-03-21T04:58:03.235Z">
<meta property="article:author" content="zengxiang">
<meta property="article:tag" content="博客,zx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picsum.photos/id/85/1280/774"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zengxiang21.github.io/2021/11/16/%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常考算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-21 12:58:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="zx的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 音视频</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picsum.photos/id/85/1280/774')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zx的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 音视频</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常考算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-16T08:25:13.867Z" title="发表于 2021-11-16 16:25:13">2021-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-21T04:58:03.235Z" title="更新于 2022-03-21 12:58:03">2022-03-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常考算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1.排序算法"></a>1.排序算法</h1><p><img src="https://images2017.cnblogs.com/blog/1282720/201711/1282720-20171120155153899-888274770.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在排序元素基本有序的前提下</span><br><span class="line">	插入排序效率最高，退化为O(n)</span><br><span class="line">插入排序最坏情况下比较n(n-1)/2次，最好情况下比较n次</span><br><span class="line">快速排序在基本有序的情况下退化为O(n^2)</span><br></pre></td></tr></table></figure>

<h2 id="稳定的排序"><a href="#稳定的排序" class="headerlink" title="稳定的排序"></a>稳定的排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡、插入、归并</span><br><span class="line">贵插茂</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[i,nums.size()-1]为排好序的</span><br><span class="line">void bubblesort(vector&lt;int&gt;&amp; tem)</span><br><span class="line">&#123;</span><br><span class="line">	int size=tem.size();</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int i=size-1;i&gt;0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(tem[j]&gt;tem[j+1])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(tem[j],tem[j+1]);</span><br><span class="line">                flag=true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		if(!flag)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">思路：[0,i]为整个序列最小排好序的，最大值为tem[i],[i+1,n-1]之间选取一个最小的与tem[i]交换</span><br><span class="line">不稳定</span><br><span class="line"></span><br><span class="line">[0,i]之间是排好序的</span><br><span class="line">void selectsort(vector&lt;int&gt;&amp; tem)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;tem.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int minindex=i;</span><br><span class="line">		for(int j=i+1;j&lt;tem.size();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(tem[minindex]&gt;tem[j])</span><br><span class="line">				minindex=j;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(tem[i],tem[minindex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">思路：[0,i-1]为排好序的，i为当前判断的元素，找[0,i-1]之间第一个小于nums[i]的元素，并且往后推，最后j为i一个小于nums[i]的位置，将nums[j+1]=nums[i],最后[i,n-1]从左到右选择一个元素插入[0,i]使其仍然有序</span><br><span class="line">稳定</span><br><span class="line">[0,i-1][,end]</span><br><span class="line"></span><br><span class="line">找哨兵往后推的写法（记这个）</span><br><span class="line">void bubblesort(vector&lt;int&gt;&amp; tem)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=1;i&lt;tem.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int key=a[i];</span><br><span class="line">		int j=i-1;</span><br><span class="line">		while(j&gt;=0&amp;&amp;tem[j]&gt;key)</span><br><span class="line">		&#123;</span><br><span class="line">			tem[j+1]=tem[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		tem[j+1]=key;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for循环写法</span><br><span class="line">void bubblesort(vector&lt;int&gt;&amp; tem)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;tem.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=i+1;j&gt;0&amp;&amp;tem[j]&lt;tem[j-1];j--)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(tem[j],tem[j-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while循环写法</span><br><span class="line">void bubblesort(vector&lt;int&gt;&amp; tem)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;tem.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int j=i+1;</span><br><span class="line">		while(j&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			if(tem[j]&lt;tem[j-1])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(tem[j],tem[j-1]);</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">法1：</span><br><span class="line">void shellSortCore(vector&lt;int&gt;&amp; nums, int gap, int i) </span><br><span class="line">&#123;</span><br><span class="line">    int inserted = nums[i];</span><br><span class="line">    int j;</span><br><span class="line">    // 插入的时候按组进行插入</span><br><span class="line">    for (j = i - gap; j &gt;= 0 &amp;&amp; inserted &lt; nums[j]; j -= gap) </span><br><span class="line">    &#123;</span><br><span class="line">   		nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = inserted;</span><br><span class="line">&#125;</span><br><span class="line">void shellSort(vector&lt;int&gt;&amp; nums) </span><br><span class="line">&#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    //进行分组，最开始的时候，gap为数组长度一半</span><br><span class="line">    for (int gap = len / 2; gap &gt; 0; gap /= 2)</span><br><span class="line">    &#123;</span><br><span class="line">    	//对各个分组进行插入分组</span><br><span class="line">        for (int i = gap; i &lt; len; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            //将nums[i]插入到所在分组正确的位置上</span><br><span class="line">            shellSortCore(nums,gap,i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">法2：</span><br><span class="line">void shell_sort(vector&lt;int&gt;&amp; arr)&#123;</span><br><span class="line">    int desquence=1;</span><br><span class="line">    while(dequence&lt;n)&#123;</span><br><span class="line">        dequence=3*desquence+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;dequence&gt;0;dequence/=3)&#123;</span><br><span class="line">        for(int i=desquence;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=i;j&gt;=desquence;j-=desquence)&#123;</span><br><span class="line">                if(arr[j]&gt;arr[j-desquence])&#123;</span><br><span class="line">                    swap(arr[j],arr[j-desquence]);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">后移sequence再往后一个个比较</span><br></pre></td></tr></table></figure>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="C:\Users\zx\AppData\Roaming\Typora\typora-user-images\image-20210725151825630.png" alt="image-20210725151825630"></p>
<p><img src="C:\Users\zx\AppData\Roaming\Typora\typora-user-images\image-20210725155221427.png" alt="image-20210725155221427"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">二路归并快速排序</span><br><span class="line">int partition(vector&lt;int&gt; tem,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">	int j=l;</span><br><span class="line">	int num=tem[l];</span><br><span class="line">	for(int i=l+1;i&lt;=r;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(tem[i]&lt;num)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(tem[++j],tem[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(tem[l],tem[j]);</span><br><span class="line">	return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">int partition(vector&lt;int&gt; tem,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">	int j=l+1;</span><br><span class="line">	int num=tem[l];</span><br><span class="line">	for(int i=l+1;i&lt;=r;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(tem[i]&lt;num)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(tem[j++],tem[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(tem[l],tem[j-1]);</span><br><span class="line">	return j-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quicksort(vector&lt;int&gt;&amp; tem,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">	if(l&gt;=r)	return;</span><br><span class="line">	int pivot=partition(tem,l,r);</span><br><span class="line">	quicksort(tem,l,pivot-1);</span><br><span class="line">	quicksort(tem,pivot+1,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="荷兰国旗-三路快排"><a href="#荷兰国旗-三路快排" class="headerlink" title="荷兰国旗(三路快排)"></a>荷兰国旗(三路快排)</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210908215449920.png" alt="image-20210908215449920"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//[0,zero]为0</span><br><span class="line">//(zero,i)为1</span><br><span class="line">//[two,nums.size()-1]为2</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int zero=-1;</span><br><span class="line">        int i=0;</span><br><span class="line">        int two=nums.size();</span><br><span class="line">        while(i&lt;two)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[++zero],nums[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[i]==1)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[i]==2)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[--two],nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void mergeSortCore(vector&lt;int&gt;&amp; data, vector&lt;int&gt;&amp; dataTemp, int low, int high) &#123;</span><br><span class="line">    if (low &gt;= high) return;</span><br><span class="line">    int len = high - low, mid = low + len / 2;</span><br><span class="line">    int start1 = low, end1 = mid, start2 = mid + 1, end2 = high;</span><br><span class="line">    mergeSortCore(data, dataTemp, start1, end1);</span><br><span class="line">    mergeSortCore(data, dataTemp, start2, end2);</span><br><span class="line">    int index = low;</span><br><span class="line">    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">        dataTemp[index++] = data[start1] &lt; data[start2] ? data[start1++] :data[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start1 &lt;= end1) &#123;</span><br><span class="line">        dataTemp[index++] = data[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start2 &lt;= end2) &#123;</span><br><span class="line">    	dataTemp[index++] = data[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">    for (index = low; index &lt;= high; ++index) &#123;</span><br><span class="line">   		data[index] = dataTemp[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergeSort(vector&lt;int&gt;&amp; data) &#123;</span><br><span class="line">    int len = data.size();</span><br><span class="line">    vector&lt;int&gt; dataTemp(len, 0);</span><br><span class="line">    mergeSortCore(data, dataTemp, 0, len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">堆：必须是完全二叉树,子节点大于父节点</span><br><span class="line">节点从0开始编号，父节点i,左孩子2i+1,右孩子2i+2    父亲i-1/2 第一个非叶子节点 size-2/2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//对当前节点形成的树进行堆化处理，有递归调用</span><br><span class="line">void heapify(vector&lt;int&gt;&amp; vec,int length,int i)</span><br><span class="line">&#123;</span><br><span class="line">    //对当前i节点进行shifdown操作</span><br><span class="line">    //保存当前值</span><br><span class="line">    int max=i;</span><br><span class="line">    int l=2*i+1;</span><br><span class="line">    int r=2*i+2;</span><br><span class="line">    if(l&lt;length&amp;&amp;vec[l]&gt;vec[max])</span><br><span class="line">    &#123;</span><br><span class="line">        max=l;</span><br><span class="line">    &#125;</span><br><span class="line">    if(r&lt;length&amp;&amp;vec[r]&gt;vec[max])</span><br><span class="line">    &#123;</span><br><span class="line">        max=r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(max!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(vec[i],vec[max]);</span><br><span class="line">        heapify(vec,length,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将一个无序数组堆排序</span><br><span class="line">void heapSort(vector&lt;int&gt;&amp; vec)</span><br><span class="line">&#123;</span><br><span class="line">    int size=vec.size();</span><br><span class="line">    //建堆</span><br><span class="line">    //从第一个非叶子节点进行heapify</span><br><span class="line">    for(int i=(size-2)/2;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        heapify(vec,size,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //堆排序</span><br><span class="line">    for(int i=size-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        //交换堆顶元素和最后一个元素，除了vec[0]不满足堆的性质，其他均满足</span><br><span class="line">        swap(vec[0],vec[i]);</span><br><span class="line">        //交换后长度-1维护vec[0]的堆,只需要维护堆顶的性质</span><br><span class="line">        heapify(vec,i,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec=&#123;20,6,9,1,4,10,8&#125;;</span><br><span class="line">    heapSort(vec);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求前k大的数"><a href="#求前k大的数" class="headerlink" title="求前k大的数"></a>求前k大的数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">利用快排</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int partition(vector&lt;int&gt;&amp; arr,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=arr[start];</span><br><span class="line">    int j=start+1;</span><br><span class="line">    for(int i=start+1;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i]&lt;=temp)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(arr[j],arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[j-1],arr[start]);</span><br><span class="line">    return j-1;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; quicksort(vector&lt;int&gt;&amp; arr, int k,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    int pivot=partition(arr,l,r);</span><br><span class="line">    if(pivot==k-1)</span><br><span class="line">    &#123;</span><br><span class="line">        return vector&lt;int&gt;(arr.begin(),arr.begin()+k);</span><br><span class="line">    &#125;</span><br><span class="line">    return pivot&gt;k-1?quicksort(arr,k,l,pivot-1):quicksort(arr,k,pivot+1,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        if(k==0||arr.size()==0)</span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        return quicksort(arr,k,0,arr.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.利用堆排</span><br></pre></td></tr></table></figure>

<h2 id="求第k大的元素"><a href="#求第k大的元素" class="headerlink" title="求第k大的元素"></a>求第k大的元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">堆排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void heapify(vector&lt;int&gt;&amp; arr,int i,int length)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp=arr[i];</span><br><span class="line">        int max=i;</span><br><span class="line">        int k=2*i+1;</span><br><span class="line">        if(k&lt;length&amp;&amp;arr[k]&gt;arr[max])</span><br><span class="line">        &#123;</span><br><span class="line">            max=k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k+1&lt;length&amp;&amp;arr[k+1]&gt;arr[max])</span><br><span class="line">        &#123;</span><br><span class="line">            max=k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(max!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(arr[i],arr[max]);</span><br><span class="line">            heapify(arr,max,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void makeheap(vector&lt;int&gt;&amp; nums,int length)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=(length-2)/2;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            heapify(nums,i,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        makeheap(nums,nums.size());</span><br><span class="line">        for(int i=nums.size()-1;i&gt;nums.size()-k;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[0],nums[i]);</span><br><span class="line">            heapify(nums,0,i);</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="strcpy和strncpy"><a href="#strcpy和strncpy" class="headerlink" title="strcpy和strncpy"></a>strcpy和strncpy</h2><p>strcpy:注意检查指针有效性</p>
<p>​            不管des内存够不够，一直拷贝到’\0’结束，所以一般为了避免溢出，des长度要足以装下src+’\0’</p>
<p>​            des的内存也不应该与src重叠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strcpy:</span><br><span class="line"></span><br><span class="line">char *strcpy(char *des, const char *src)  </span><br><span class="line">&#123;   </span><br><span class="line">    assert((des!=NULL) &amp;&amp; (src !=NULL));   </span><br><span class="line">    char *ans = des;                    </span><br><span class="line">    while( (*des++ = * src++) != &#x27;\0&#x27; );      </span><br><span class="line">    return ans;                            </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy:"></a>strncpy:</h2><p>​            当src长度小于n时，拷贝src到des，多余补’\0’</p>
<p>​            当src长度大于n时，拷贝src前n个字节进des，此时des不是以’\0’为结尾的字符串，不安全</p>
<p>​            src和des不能重叠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">strncpy:</span><br><span class="line"></span><br><span class="line">char* strncpy(char* des,const char* src,size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	char* ans=des;</span><br><span class="line">	while(n&amp;&amp;(*des++ = * src++)!= &#x27;\0&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	while(--n)</span><br><span class="line">	&#123;</span><br><span class="line">		*des++=&#x27;\0&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memcpy和memmove"><a href="#memcpy和memmove" class="headerlink" title="memcpy和memmove"></a>memcpy和memmove</h2><p>memmove是内存重叠版本的memcpy</p>
<p>memmove</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *dest, const void *src,size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    if(dest==nullptr||src==nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line">    char* d=(char *)des;</span><br><span class="line">    char* s=(char *)src;</span><br><span class="line">    void* res=d;</span><br><span class="line">    if(d&lt;=s||d&gt;=s+n)&#123;</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">        //从低地址开始复制</span><br><span class="line">        *d++ =*s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    //从高地址开始复制</span><br><span class="line">          while(n--)&#123;</span><br><span class="line">          	*(d+n-1)=*(s+n-1);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><p>​    比较两个c字符串，相等返回0，不相等时第一个字典序大返回1，第二个字典序大返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(const char *dest, const char *source) </span><br><span class="line">&#123; </span><br><span class="line">  assert((NULL != dest) &amp;&amp; (NULL != source)); </span><br><span class="line">  while (*dest &amp;&amp; *source &amp;&amp; (*dest == *source)) </span><br><span class="line">      &#123; </span><br><span class="line">          dest ++; </span><br><span class="line">          source ++; </span><br><span class="line">      &#125; </span><br><span class="line">  return *dest - *source; </span><br><span class="line">/*如果dest &gt; source,则返回值大于0，如果dest = source,则返回值等于0，如果dest &lt; source ,则返回值小于0。*/ </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p>kmp或者暴力搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1.	双指针</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre=nullptr;</span><br><span class="line">        ListNode* nx;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">        	nx=cur-&gt;next;</span><br><span class="line">        	cur-&gt;next=pre;</span><br><span class="line">        	pre=cur;</span><br><span class="line">        	cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.	递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode*ret= reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;  </span><br><span class="line">        head-&gt;next = NULL;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.反转[head,tail）之间的链表</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head,ListNode* tail) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre=nullptr;</span><br><span class="line">        ListNode* nx;</span><br><span class="line">        while (cur!=tail) &#123;</span><br><span class="line">        	nx=cur-&gt;next;</span><br><span class="line">        	cur-&gt;next=pre;</span><br><span class="line">        	pre=cur;</span><br><span class="line">        	cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">4.k个一组反转链表</span><br><span class="line"></span><br><span class="line">ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    if (head == null) return null;</span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        if (b == null) return head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = reverse(a, b);</span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断链表是否相等"><a href="#判断链表是否相等" class="headerlink" title="判断链表是否相等"></a>判断链表是否相等</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isSame(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">    while (head1 &amp;&amp; head2) &#123;</span><br><span class="line">    if (head1-&gt;val != head2-&gt;val) return false;</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return !head1 &amp;&amp; !head2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找链表的中点"><a href="#找链表的中点" class="headerlink" title="找链表的中点"></a>找链表的中点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//当使用fast&amp;&amp;fast-&gt;next作为判断条件，slow在中间或者中间偏右</span><br><span class="line">//当使用fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next作为判断条件，slow在中间或者偏左的位置(常用)</span><br><span class="line">ListNode* getMiddle(ListNode head) &#123;</span><br><span class="line">    ListNode* fast=head;</span><br><span class="line">    ListNode* slow=head;</span><br><span class="line">    while(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">    	slow=slow-&gt;next;</span><br><span class="line">    	fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">    //奇数slow正好在中间，偶数slow在中间右边			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表交点"><a href="#链表交点" class="headerlink" title="链表交点"></a>链表交点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode* tem1=headA;</span><br><span class="line">        ListNode* tem2=headB;</span><br><span class="line">        while(tem1!=tem2)</span><br><span class="line">        &#123;</span><br><span class="line">            tem1=tem1==nullptr?headB:tem1-&gt;next;</span><br><span class="line">            tem2=tem2==nullptr?headA:tem2-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        return tem1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表环的交点"><a href="#链表环的交点" class="headerlink" title="链表环的交点"></a>链表环的交点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">fast、slow指向head</span><br><span class="line">while(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">	fast=fast-&gt;next-&gt;next;</span><br><span class="line">	slow=slow-&gt;next;</span><br><span class="line">	//没有交点进不来的</span><br><span class="line">	if(slow==fast)</span><br><span class="line">	&#123;</span><br><span class="line">		fast=head;</span><br><span class="line">		while(fast!=slow)</span><br><span class="line">		&#123;</span><br><span class="line">			fast=fast-&gt;next;</span><br><span class="line">			slow=slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		return fast;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nullptr;</span><br></pre></td></tr></table></figure>



<h2 id="合并升序链表"><a href="#合并升序链表" class="headerlink" title="合并升序链表"></a>合并升序链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.迭代</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* dummyhead=new ListNode(-1);</span><br><span class="line">        ListNode* cur=dummyhead;</span><br><span class="line">        while(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=l1?l1:l2;</span><br><span class="line">        return dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if (!l1 || !l2) return !l1 ? l2 : l1;</span><br><span class="line">        if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">合并k个升序链表</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        ListNode *ans = nullptr;</span><br><span class="line">        for (size_t i = 0; i &lt; lists.size(); ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除升序链表重复节点（一个不保留）"><a href="#删除升序链表重复节点（一个不保留）" class="headerlink" title="删除升序链表重复节点（一个不保留）"></a>删除升序链表重复节点（一个不保留）</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img"></p>
<h2 id="两指针法-pre-cur"><a href="#两指针法-pre-cur" class="headerlink" title="两指针法 pre cur"></a>两指针法 pre cur</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pre、cur分别指向dummy和head</span><br><span class="line">当pre-&gt;val==cur-&gt;val</span><br><span class="line">	保持pre不变，cur一直移动到空或者cur-&gt;val!=pre-&gt;val</span><br><span class="line">	1.cur==nullptr,只需将pre-&gt;next=cur;</span><br><span class="line">	2.cur!=nullptr,将pre-&gt;next=cur;还要将pre=cur，cur=cur-&gt;next</span><br><span class="line">当pre-&gt;val!=cur-&gt;val</span><br><span class="line">	只需移动pre=cur,cur=cur-&gt;next</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        ListNode* dummy=new ListNode(-1);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* pre=dummy;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre-&gt;val==cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                while(cur&amp;&amp;cur-&gt;val==pre-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur=cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;next=cur;</span><br><span class="line">                if(cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur-&gt;next;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除链表重复节点（保留一个）"><a href="#删除链表重复节点（保留一个）" class="headerlink" title="删除链表重复节点（保留一个）"></a>删除链表重复节点（保留一个）</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<h2 id="三指针法-ppre-pre-cur"><a href="#三指针法-ppre-pre-cur" class="headerlink" title="三指针法 ppre pre cur"></a>三指针法 ppre pre cur</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将我们的ppre、pre、cur分别放在dummy、head、head-&gt;next</span><br><span class="line">当pre-&gt;val==cur-&gt;val</span><br><span class="line">	保持ppre不变，循环移动pre=cur,cur=cur-&gt;next直到cur==nullptr or cur-&gt;val!=pre-&gt;val</span><br><span class="line">	1.cur=nullptr，这是ppre-&gt;next=cur；</span><br><span class="line">	2.cur-&gt;val!=pre-&gt;val，ppre-&gt;next=cur,pre=cur,cur=cur-&gt;next;</span><br><span class="line">当pre-&gt;val!=cur-&gt;val</span><br><span class="line">	ppre=pre;</span><br><span class="line">	pre=cur;</span><br><span class="line">	cur=cur-&gt;next;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        ListNode* dummy=new ListNode(-1);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        if(head==nullptr||head-&gt;next==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ppre=dummy;</span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        ListNode* cur=head-&gt;next;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            //当前cur-&gt;val==pre-&gt;val</span><br><span class="line">            if(cur-&gt;val==pre-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                while(cur&amp;&amp;cur-&gt;val==pre-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ppre-&gt;next=cur;</span><br><span class="line">                //两种情况，cur为空和cur不为空</span><br><span class="line">                if(cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            //否则cur-&gt;val!=pre-&gt;val</span><br><span class="line">            &#123;</span><br><span class="line">                ppre=pre;</span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表相加"><a href="#链表相加" class="headerlink" title="链表相加"></a>链表相加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">   /*     stack&lt;int&gt; s1;</span><br><span class="line">        stack&lt;int&gt; s2; </span><br><span class="line">        ListNode* cur=l1; </span><br><span class="line">         while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.push(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=l2;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s2.push(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125; */ 正序排列时需要先反转链表，使用栈或者自己写反转链表的操作</span><br><span class="line">        </span><br><span class="line">        ListNode* dummy=new ListNode(-1);</span><br><span class="line">        ListNode* cur=dummy;</span><br><span class="line">        int carry=0;</span><br><span class="line">        while(l1||l2||carry)</span><br><span class="line">        &#123;</span><br><span class="line">            int sum=carry;</span><br><span class="line">            if(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l1-&gt;val;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l2-&gt;val;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry=sum/10;</span><br><span class="line">            int newsum=sum%10;</span><br><span class="line">            cur-&gt;next=new ListNode(newsum);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="交换相邻两个节点"><a href="#交换相邻两个节点" class="headerlink" title="交换相邻两个节点"></a>交换相邻两个节点</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：1.递归，当需要两个，一般递归就取前两个</span><br><span class="line">	 2.迭代</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">    if(!head||!head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pos=head-&gt;next;</span><br><span class="line">    head-&gt;next=swapPairs(pos-&gt;next);</span><br><span class="line">    pos-&gt;next=head;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if(!head||!head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy=new ListNode(-1);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* pre=dummy;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        while(cur&amp;&amp;cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* nx=cur-&gt;next;</span><br><span class="line">            pre-&gt;next=nx;</span><br><span class="line">            cur-&gt;next=nx-&gt;next;</span><br><span class="line">            nx-&gt;next=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">    ListNode* dummy=new ListNode(-1);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    //第一个元素不用看，直接看第二个元素</span><br><span class="line">    ListNode* cur=head-&gt;next;</span><br><span class="line">    //tail是排好序的最后一个元素</span><br><span class="line">    ListNode* tail=head;</span><br><span class="line">    while(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        //[head,tail]cur</span><br><span class="line">        if(tail-&gt;val&lt;=cur-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //pre从一个负数开始，避免讨论加在第一个节点的位置</span><br><span class="line">            ListNode* pre=dummy;</span><br><span class="line">            //不用担心越界，外侧else一定有一个cur前面的pre-&gt;next-&gt;val&gt;cur-&gt;val</span><br><span class="line">            while(pre-&gt;next-&gt;val&lt;=cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            //pre定在最后一个小于等于cur-&gt;val的位置</span><br><span class="line">            ListNode* nx=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=cur;</span><br><span class="line">            tail-&gt;next=nx;</span><br><span class="line">            cur=nx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表冒泡排序"><a href="#链表冒泡排序" class="headerlink" title="链表冒泡排序"></a>链表冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：不需要判断是否过界，根据结点的个数确保冒泡次数i和每趟比较的次数</span><br><span class="line">	为了保留比较两节点最前面的节点通常使用pre-&gt;next-&gt;val与cur比较，即三个节点一组移动</span><br><span class="line">	遍历一遍没有交换说明有序，直接退出就行</span><br></pre></td></tr></table></figure>

<p><strong>如果要使用O(nlogn)对链表排序，最好的方法是使用归并排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.找中点拆分</span><br><span class="line">2.一直递归拆</span><br><span class="line">3.拆完合并</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge(ListNode* a,ListNode* b)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* dummy=new ListNode(-1);</span><br><span class="line">    ListNode* head=dummy;</span><br><span class="line">    while(a!=nullptr&amp;&amp;b!=nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a-&gt;val&lt;b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next=a;</span><br><span class="line">            a=a-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next=b;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next=a==nullptr?b:a;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ListNode*,ListNode*&gt; getmid(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* fast=head-&gt;next;</span><br><span class="line">    ListNode* slow=head;</span><br><span class="line">    while(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid=slow-&gt;next;</span><br><span class="line">    slow-&gt;next=nullptr;</span><br><span class="line">    return &#123;head,mid&#125;;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* mergesort(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">    if(head==nullptr||head-&gt;next==nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* a=nullptr;</span><br><span class="line">    ListNode* b=nullptr;</span><br><span class="line">    tie(a,b)=getmid(head);</span><br><span class="line">    a=mergesort(a);</span><br><span class="line">    b=mergesort(b);</span><br><span class="line">    return merge(a,b);</span><br><span class="line">&#125;</span><br><span class="line">ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">    return mergesort(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int val)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;val=val;</span><br><span class="line">        next=nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode(int val,ListNode* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;val=val;</span><br><span class="line">        this-&gt;next=ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode* append(ListNode* head,int val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* nx=new ListNode(val);</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    while(cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next=nx;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* bubbleSort(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* dummy=new ListNode(-1);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode* pre=dummy;</span><br><span class="line">    ListNode* cur=head-&gt;next;</span><br><span class="line">    int num=0;</span><br><span class="line">    while(pre)</span><br><span class="line">    &#123;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    num-=1;</span><br><span class="line">    bool ischange=false;</span><br><span class="line">    for(int i=0;i&lt;num-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j=num-i-1;</span><br><span class="line">        pre=dummy;</span><br><span class="line">        cur=dummy-&gt;next-&gt;next;</span><br><span class="line">        while(j--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre-&gt;next-&gt;val&gt;cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* nx=cur-&gt;next;</span><br><span class="line">                pre-&gt;next-&gt;next=nx;</span><br><span class="line">                cur-&gt;next=pre-&gt;next;</span><br><span class="line">                pre-&gt;next=cur;</span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=nx;</span><br><span class="line">                ischange=true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!ischange)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">void print(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">    while(head)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;head-&gt;val&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* head=new ListNode(5);</span><br><span class="line">    head=append(head,4);</span><br><span class="line">    head=append(head,3);</span><br><span class="line">    head=append(head,2);</span><br><span class="line">    head=append(head,1);</span><br><span class="line">    print(head);</span><br><span class="line">    head=bubbleSort(head);</span><br><span class="line">    print(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-树"><a href="#3-树" class="headerlink" title="3.树"></a>3.树</h1><h2 id="迭代遍历方式"><a href="#迭代遍历方式" class="headerlink" title="迭代遍历方式"></a>迭代遍历方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1.先序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            cur = st.top();                       // 中</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            if (cur-&gt;right) st.push(cur-&gt;right);           // 右（空节点不入栈）</span><br><span class="line">            if (cur-&gt;left) st.push(cur-&gt;left);             // 左（空节点不入栈）</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">2.中序</span><br><span class="line">利用中间指针保留父节点</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        while (cur != NULL || !st.empty()) &#123;</span><br><span class="line">            if (cur != NULL) &#123; // 指针来访问节点，访问到最底层</span><br><span class="line">                st.push(cur); // 将访问的节点放进栈</span><br><span class="line">                cur = cur-&gt;left;                // 左</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);     // 中</span><br><span class="line">                cur = cur-&gt;right;               // 右</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.后序</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            if (cur-&gt;left) st.push(cur-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br><span class="line">            if (cur-&gt;right) st.push(cur-&gt;right); // 空节点不入栈</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">4.层序 </span><br></pre></td></tr></table></figure>

<h2 id="根据先序和中序遍历构建二叉树"><a href="#根据先序和中序遍历构建二叉树" class="headerlink" title="根据先序和中序遍历构建二叉树"></a>根据先序和中序遍历构建二叉树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,int&gt; hash;</span><br><span class="line">TreeNode* dfs(vector&lt;int&gt;&amp; preorder,int pl,int pr,vector&lt;int&gt;&amp; inorder,int rl,int rr)</span><br><span class="line">&#123;</span><br><span class="line">    if(pl&gt;pr)</span><br><span class="line">    &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    int index=hash[preorder[pl]];</span><br><span class="line">    TreeNode* root=new TreeNode(preorder[pl]);</span><br><span class="line">    int leftnum=index-rl;</span><br><span class="line">    root-&gt;left=dfs(preorder,pl+1,pl+leftnum,inorder,rl,index-1);</span><br><span class="line">    root-&gt;right=dfs(preorder,pl+leftnum+1,pr,inorder,index+1,rr);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">    //hash存[value,i]</span><br><span class="line">    for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    return dfs(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="是否为子树"><a href="#是否为子树" class="headerlink" title="是否为子树"></a>是否为子树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	 3				</span><br><span class="line">​    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2 </span><br><span class="line"></span><br><span class="line">​    4 </span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line"></span><br><span class="line"> class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* A, TreeNode* B)</span><br><span class="line">    &#123;</span><br><span class="line">        if(A==nullptr&amp;&amp;B==nullptr) return true;</span><br><span class="line">        if(A&amp;&amp;B)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A-&gt;val!=B-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                return dfs(A-&gt;left,B-&gt;left)&amp;&amp;dfs(A-&gt;right,B-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if(A==nullptr||B==nullptr)  return false;</span><br><span class="line">        return dfs(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="层次打印-要用队列，不要跟迭代中序遍历stack搞混了"><a href="#层次打印-要用队列，不要跟迭代中序遍历stack搞混了" class="headerlink" title="层次打印(要用队列，不要跟迭代中序遍历stack搞混了)"></a>层次打印(要用队列，不要跟迭代中序遍历stack搞混了)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">1.一行打印</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if(root==nullptr)   return ans;</span><br><span class="line">        que.push(root);</span><br><span class="line">        TreeNode* temp=nullptr;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">           temp=que.front();</span><br><span class="line">           ans.push_back(temp-&gt;val);</span><br><span class="line">           que.pop();</span><br><span class="line">           if(temp-&gt;left)   que.push(temp-&gt;left);</span><br><span class="line">           if(temp-&gt;right)  que.push(temp-&gt;right);     </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.多行打印</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(root==nullptr) return ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        TreeNode* temp=nullptr;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size=que.size();</span><br><span class="line">            while(size)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)  que.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right) que.push(temp-&gt;right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(vec);</span><br><span class="line">            vec.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.Z字打印</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root==nullptr)   return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        TreeNode* temp=nullptr;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size=que.size();</span><br><span class="line">            while(size)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)  que.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right)  que.push(temp-&gt;right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(vec.begin(),vec.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            flag=!flag;</span><br><span class="line">            vec.clear();   </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最下层最左边的元素-层序遍历的方法"><a href="#最下层最左边的元素-层序遍历的方法" class="headerlink" title="最下层最左边的元素(层序遍历的方法)"></a>最下层最左边的元素(层序遍历的方法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">    if(root-&gt;right==nullptr&amp;&amp;root-&gt;left==nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    int result=0;</span><br><span class="line">    que.push(root);</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size=que.size();</span><br><span class="line">        for(int i=0;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=que.front();</span><br><span class="line">            if(i==0)</span><br><span class="line">            &#123;</span><br><span class="line">                result=tmp-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            que.pop();</span><br><span class="line">            if(tmp-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否是完全二叉树"><a href="#判断是否是完全二叉树" class="headerlink" title="判断是否是完全二叉树"></a>判断是否是完全二叉树</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：最后一层前的每一层都是满的（即，结点值为 &#123;1&#125; 和 &#123;2,3&#125; 的两层），且最后一层中的所有结点（&#123;4,5,6&#125;）都尽可能地向左。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：设置一个bool变量，可以两种方式判断是否是完全二叉树</span><br><span class="line">1.当前节点为空，则当前层之后的节点都必须为空，设置prenull变量，que需要将nullptr加进去，所以多加最后一层叶子节点的左右nullptr</span><br><span class="line">2.当前节点为只有右孩子，没左孩子，返回false，右孩子为空（左孩子为空或者左孩子不为空，不为空加入que），将 bool isleft置为1，后面的节点都必须为叶子节点，左右孩子不为空同样加入que</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool isCompleteTree(TreeNode* root) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line">    bool prenull=false;</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size=que.size();</span><br><span class="line">        while(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(tmp==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                prenull=true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(prenull==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push(tmp-&gt;left);</span><br><span class="line">                que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isCompleteTree(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">        if (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        bool leaf = false; //是否必须为叶子节点</span><br><span class="line"></span><br><span class="line">        while (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            if (!node-&gt;left &amp;&amp; node-&gt;right) //仅有右子节点，无左子节点</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (leaf) //前面出现过无右子节点的 (只有左 或 左右都没有的) 后续所有节点必须为叶子节点</span><br><span class="line">            &#123;</span><br><span class="line">                if (node-&gt;left || node-&gt;right) //非叶子节点</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            else //右为空 则后续节点必须为叶子节点</span><br><span class="line">            &#123;</span><br><span class="line">                leaf = true; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.图：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(matrix.empty()) return res;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        int m = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;bool&gt; &gt; st(n, vector&lt;bool&gt;(m, false));//标记走没走过</span><br><span class="line">        int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;//上、右、下、左，依次</span><br><span class="line">        int x = 0, y = 0, d = 1;//d控制着方向</span><br><span class="line">        for(int i = 0; i &lt; n * m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = true;</span><br><span class="line"></span><br><span class="line">            int a = x + dx[d], b = y + dy[d];</span><br><span class="line">            if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b])//遇到阻碍</span><br><span class="line">            &#123;</span><br><span class="line">                d = (d + 1) % 4;//d改变方向</span><br><span class="line">                a = x + dx[d], b = y + dy[d];//更新遇到阻碍的那个点</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;//从更新后的点开始</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.模拟</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if(matrix.size())</span><br><span class="line">        &#123;</span><br><span class="line">            int row_up=0;</span><br><span class="line">            int row_down=matrix.size()-1;</span><br><span class="line">            int col_left=0;</span><br><span class="line">            int col_right=matrix[0].size()-1;</span><br><span class="line">            while(row_up&lt;=row_down&amp;&amp;col_left&lt;=col_right)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=col_left;j&lt;=col_right;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(matrix[row_up][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                if(++row_up&gt;row_down) break;</span><br><span class="line">                for(int i=row_up;i&lt;=row_down;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(matrix[i][col_right]);</span><br><span class="line">                &#125; </span><br><span class="line">                if(--col_right&lt;col_left) break;</span><br><span class="line">                for(int j=col_right;j&gt;=col_left;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(matrix[row_down][j]);</span><br><span class="line">                &#125;  </span><br><span class="line">                if(--row_down&lt;row_up) break;  </span><br><span class="line">                for(int i=row_down;i&gt;=row_up;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(matrix[i][col_left]);</span><br><span class="line">                &#125; </span><br><span class="line">               if(++col_left&gt;row_down) break;                                             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断出栈顺序"><a href="#判断出栈顺序" class="headerlink" title="判断出栈顺序"></a>判断出栈顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">使用辅助栈模拟</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        if(pushed.size()!=popped.size()) return false;</span><br><span class="line">        if(pushed.empty()) return true;</span><br><span class="line">        stack&lt;int&gt; sta;</span><br><span class="line">        for(int i=0,j=0;i&lt;pushed.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(pushed[i]);</span><br><span class="line">            while(!sta.empty()&amp;&amp;sta.top()==popped[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return sta.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="根据vec判断是否是后序遍历"><a href="#根据vec判断是否是后序遍历" class="headerlink" title="根据vec判断是否是后序遍历"></a>根据vec判断是否是后序遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool _verifyPostorder(vector&lt;int&gt;&amp; postorder,int start,int end) &#123;</span><br><span class="line">        if(start&gt;=end)  return true;</span><br><span class="line">        int low=start;</span><br><span class="line">        while(low&lt;end&amp;&amp;postorder[low]&lt;postorder[end])</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=low;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(postorder[i]&lt;postorder[end])</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return _verifyPostorder(postorder,start,low-1)&amp;&amp;_verifyPostorder(postorder,low,end-1); </span><br><span class="line">    &#125;</span><br><span class="line">    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(postorder.size()==0||postorder.size()==1) return true;</span><br><span class="line">        return _verifyPostorder(postorder,0,postorder.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树删除节点"><a href="#二叉搜索树删除节点" class="headerlink" title="二叉搜索树删除节点"></a>二叉搜索树删除节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树一定要利用性质</span><br><span class="line">在递归过程中一般采用root-&gt;val和条件比较大小判断往左走还是往右走</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //返回删除key后的root</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //要利用二叉搜索树的特点</span><br><span class="line">        if(root-&gt;val&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val==key)</span><br><span class="line">        &#123;</span><br><span class="line">            if(root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                auto tmp=getMin(root-&gt;right);</span><br><span class="line">                root-&gt;val=tmp-&gt;val;</span><br><span class="line">                root-&gt;right=deleteNode(root-&gt;right,tmp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return root-&gt;left==nullptr?root-&gt;right:root-&gt;left;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* getMin(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        while(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        //dp[i]表示i个数所有二叉搜索树的个数</span><br><span class="line">        //G(n)=f(1)+f(2)+...+f(n)</span><br><span class="line">        //f(i)=G(i-1)*G(n-i)</span><br><span class="line">        //G(n)=G(0)*G(n-1)+...+G(n-1)*G(0)</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[j-1]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="路径之和（自顶向下）"><a href="#路径之和（自顶向下）" class="headerlink" title="路径之和（自顶向下）"></a>路径之和（自顶向下）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每次进来tmp加入当前根</span><br><span class="line">判断叶子节点时，加入结果</span><br><span class="line">左右子树递归</span><br><span class="line">最后删除选择</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    void dfs(TreeNode* root,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr&amp;&amp;target==root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,target-root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right,target-root-&gt;val);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root,targetSum);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大路径和-自底向上"><a href="#最大路径和-自底向上" class="headerlink" title="最大路径和(自底向上)"></a>最大路径和(自底向上)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.一般dfs定义为以root为起点的路径和</span><br><span class="line">2.一般有一个全局变量记录经过root，但不一定以root为起点的路径</span><br><span class="line"></span><br><span class="line">3.后序遍历的方式</span><br></pre></td></tr></table></figure>

<h2 id="最大路径和不一定过根节点"><a href="#最大路径和不一定过根节点" class="headerlink" title="最大路径和不一定过根节点"></a>最大路径和不一定过根节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//返回以root为起点且以root为起点的最大路径和</span><br><span class="line">//当左子树右子树的最大路径和小于0，则从root开始</span><br><span class="line">//左子树右子树最大路径和均大于0,maxpath=root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)</span><br><span class="line">    int maxpath=INT_MIN; </span><br><span class="line">    int dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return 0;</span><br><span class="line">        int left=max(dfs(root-&gt;left),0);</span><br><span class="line">        int right=max(dfs(root-&gt;right),0);</span><br><span class="line">        maxpath=max(root-&gt;val+left+right,maxpath);</span><br><span class="line">        return max(root-&gt;val+left,root-&gt;val+right);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="求和路径-双层dfs"><a href="#求和路径-双层dfs" class="headerlink" title="求和路径(双层dfs)"></a>求和路径(双层dfs)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">以每个节点作路径和查找</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//返回以root为起点且经过root的最大路径和</span><br><span class="line">//当左子树右子树的最大路径和小于0，则从root开始</span><br><span class="line">//左子树右子树最大路径和均大于0,maxpath=root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)</span><br><span class="line">    int maxpath=INT_MIN; </span><br><span class="line">    int dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return 0;</span><br><span class="line">        int left=max(dfs(root-&gt;left),0);</span><br><span class="line">        int right=max(dfs(root-&gt;right),0);</span><br><span class="line">        maxpath=max(root-&gt;val+left+right,maxpath);</span><br><span class="line">        return max(root-&gt;val+left,root-&gt;val+right);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="4-回溯"><a href="#4-回溯" class="headerlink" title="4.回溯"></a>4.回溯</h1><h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="(1)DFS"></a><strong>(1)DFS</strong></h2><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个题很特殊的剪枝技巧：</span><br><span class="line">已选择的(比）多才能满足匹配的原则，所以一般传进去只需要判断</span><br><span class="line">left==0&amp;&amp;right==0   满足条件</span><br><span class="line">left&gt;0  先使用(往下搜</span><br><span class="line">right&gt;left说明用过的left&gt;right 这时候可以使用）往下递归</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//dfs传入(剩余个数left ,)剩余个数right，传记录结果的变量str，这时候就不需要回溯</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    void dfs(int n,int left,int right,string str)</span><br><span class="line">    &#123;</span><br><span class="line">        //base case</span><br><span class="line">        if(left==0&amp;&amp;right==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.emplace_back(str);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //合法情况,优先塞左括号</span><br><span class="line">        if(left&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(n,left-1,right,str+&quot;(&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //还有一种合法情况就是剩余的right要多余left</span><br><span class="line">        if(right&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(n,left,right-1,str+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        dfs(n,n,n,&quot;&quot;);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="组合之和"><a href="#组合之和" class="headerlink" title="组合之和"></a>组合之和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">	为了避免组合之和重复，一般传一个startIndex，可选范围可以是[startIndex,end）【可重复选择】或者是(startIndex,end）【不可重复选择】</span><br></pre></td></tr></table></figure>

<p>不可重复使用：先排序，对于选择中相同的相邻元素进行去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates,int startIndex,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        if(startIndex&gt;candidates.size()||target&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=startIndex;i&lt;candidates.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //做选择</span><br><span class="line">            if(i!=startIndex&amp;&amp;candidates[i]==candidates[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.emplace_back(candidates[i]);</span><br><span class="line">            //递归下去</span><br><span class="line">            dfs(candidates,i+1,target-candidates[i]);</span><br><span class="line">            //递归完出来，抛弃选择</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        dfs(candidates,0,target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="复原ip"><a href="#复原ip" class="headerlink" title="复原ip"></a>复原ip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">public:</span><br><span class="line">    void dfs(string s,int startIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        //当开始标记越界，返回</span><br><span class="line">        //base case</span><br><span class="line">        //当tmp.size()==4时，返回啦</span><br><span class="line">        if(tmp.size()==4)</span><br><span class="line">        &#123;</span><br><span class="line">            //还有剩余的元素，不符合题意</span><br><span class="line">            if(startIndex&lt;s.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有剩余元素</span><br><span class="line">            if(startIndex==s.size())</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp1=tmp[0];</span><br><span class="line">                for(int i=0;i&lt;3;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp1=tmp1+&quot;.&quot;+tmp[i+1];</span><br><span class="line">                &#125;</span><br><span class="line">                ans.emplace_back(tmp1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int len=1;len&lt;=3;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(startIndex&gt;=s.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if(len!=1&amp;&amp;s[startIndex]==&#x27;0&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            string sstr=s.substr(startIndex,len);</span><br><span class="line">            if(len==3&amp;&amp;stoi(sstr)&gt;255)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(sstr);</span><br><span class="line">            dfs(s,startIndex+len);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        dfs(s,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.使用isvisit标记当前元素访问过</span><br></pre></td></tr></table></figure>



<h3 id="二维平面回溯注意事项"><a href="#二维平面回溯注意事项" class="headerlink" title="二维平面回溯注意事项"></a>二维平面回溯注意事项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如果使用过的元素不能再用通常采用isvisited数组(一维或者二维)标记当前元素是否访问过，所以在撤销选择时需要将isvisited撤销</span><br><span class="line">2.如果边深搜边修改(board中不存在的元素)，则不需要isvisited数组标记</span><br><span class="line">2.二维坐标startx,starty上下左右遍历通常采用</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; d&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		newx=startx+d[i][0];</span><br><span class="line">		newy=starty+d[i][1];</span><br><span class="line">	&#125;</span><br><span class="line">	实现上下左右遍历</span><br></pre></td></tr></table></figure>



<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; d&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line">    bool search_word(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;vector&lt;bool&gt;&gt;&amp; isvisit,</span><br><span class="line">    string word,int index,int startx,int starty)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果index到头了，并且最后一个字符相等，base case</span><br><span class="line">        if(index==word.size()-1)</span><br><span class="line">        &#123;</span><br><span class="line">            return board[startx][starty]==word[index];</span><br><span class="line">        &#125;</span><br><span class="line">        //当前board[starty][starty]==word[index],向其他方向搜索</span><br><span class="line">        if(board[startx][starty]==word[index])</span><br><span class="line">        &#123;</span><br><span class="line">            isvisit[startx][starty]=true;</span><br><span class="line">            for(int i=0;i&lt;4;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int newx=startx+d[i][0];</span><br><span class="line">                int newy=starty+d[i][1];</span><br><span class="line">                if( ( newx&gt;=0&amp;&amp;newx&lt;board.size()&amp;&amp;newy&gt;=0&amp;&amp;newy&lt;board[0].size() )&amp;&amp;!isvisit[newx][newy] &amp;&amp;search_word(board,isvisit,word,index+1,newx,newy) )</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            isvisit[startx][starty]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        int m=board.size();</span><br><span class="line">        int n=board[0].size();</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; isvalid(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                //从board[i][j]开始搜寻word</span><br><span class="line">                if( search_word(board,isvalid,word,0,i,j) )</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //所有搜完都没有搜到，说明没有</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><h3 id="floodfill算法"><a href="#floodfill算法" class="headerlink" title="floodfill算法"></a>floodfill算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; isvisited;</span><br><span class="line">    int ans=0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; d=&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    bool isvaild(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y)</span><br><span class="line">    &#123;</span><br><span class="line">        return x&gt;=0&amp;&amp;x&lt;grid.size()&amp;&amp;y&gt;=0&amp;&amp;y&lt;grid[0].size();</span><br><span class="line">    &#125;</span><br><span class="line">    void backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int startx,int starty)</span><br><span class="line">    &#123;</span><br><span class="line">        isvisited[startx][starty]=true;</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int newx=startx+d[i][0];</span><br><span class="line">            int newy=starty+d[i][1];</span><br><span class="line">            if( isvaild(grid,newx,newy) &amp;&amp; !isvisited[newx][newy] &amp;&amp; grid[newx][newy]==&#x27;1&#x27; )</span><br><span class="line">            &#123;</span><br><span class="line">                backtracking(grid,newx,newy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m=grid.size();</span><br><span class="line">        int n=grid[0].size();</span><br><span class="line">        isvisited=vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j]==&#x27;1&#x27; &amp;&amp; !isvisited[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    backtracking(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs定义的时候就定义成最大面积</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;bool&gt;&gt; isvisited;</span><br><span class="line">//非沉岛法</span><br><span class="line">int maxsize=0;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; d&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int m=grid.size();</span><br><span class="line">    int n=grid[0].size();</span><br><span class="line">    return x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n;</span><br><span class="line">&#125;</span><br><span class="line">//返回以(x,y)为中心，岛屿的最大面积</span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    //递归出口:当前不是岛</span><br><span class="line">    if(grid[x][y]==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //进来修改当前点的遍历属性</span><br><span class="line">    isvisited[x][y]=true;</span><br><span class="line">    int ans=1;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newx=x+d[i][0];</span><br><span class="line">        int newy=y+d[i][1];</span><br><span class="line">        if(isvalid(grid,newx,newy)&amp;&amp;!isvisited[newx][newy])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=dfs(grid,newx,newy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxsize=std::max(maxsize,ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int m=grid.size();</span><br><span class="line">    if(m==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n=grid[0].size();</span><br><span class="line">    isvisited=vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!isvisited[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(grid,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a>黄金矿工</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注意回溯里面的写法</span><br><span class="line">沉岛法或者isvisted在修改时，应该在</span><br><span class="line">//做选择</span><br><span class="line">grid[x][y]=0或者isvisited[x][y]=true</span><br><span class="line">//不同选择，做选择的过程</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">	//搜索下一层</span><br><span class="line">&#125;</span><br><span class="line">grid[x][y]=1 or isvisited[x][y]=false</span><br><span class="line">//撤销选择</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; d&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int maxvalue=0;</span><br><span class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int n=grid.size();</span><br><span class="line">    int m=grid[0].size();</span><br><span class="line">    return x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(grid[x][y]==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp=grid[x][y];</span><br><span class="line">    grid[x][y]=0;</span><br><span class="line">    int ans=tmp;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newx=x+d[i][0];</span><br><span class="line">        int newy=y+d[i][1];</span><br><span class="line">        if(isvalid(grid,newx,newy))</span><br><span class="line">        &#123;</span><br><span class="line">            ans=max(dfs(grid,newx,newy)+tmp,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y]=tmp;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int m=grid.size();</span><br><span class="line">    if(m==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n=grid[0].size();</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxvalue=max(dfs(grid,i,j),maxvalue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非沉岛的方法-isvisited数组方法"><a href="#非沉岛的方法-isvisited数组方法" class="headerlink" title="非沉岛的方法(isvisited数组方法)"></a>非沉岛的方法(isvisited数组方法)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; d&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int maxvalue=0;</span><br><span class="line">vector&lt;vector&lt;bool&gt;&gt; isvisited;</span><br><span class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int n=grid.size();</span><br><span class="line">    int m=grid[0].size();</span><br><span class="line">    return x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(grid[x][y]==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=grid[x][y];</span><br><span class="line">    isvisited[x][y]=true;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newx=x+d[i][0];</span><br><span class="line">        int newy=y+d[i][1];</span><br><span class="line">        if(isvalid(grid,newx,newy)&amp;&amp;!isvisited[newx][newy])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=max(dfs(grid,newx,newy)+grid[x][y],ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isvisited[x][y]=false;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int m=grid.size();</span><br><span class="line">    if(m==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n=grid[0].size();</span><br><span class="line">    isvisited=vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxvalue=max(dfs(grid,i,j),maxvalue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxvalue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分成k个和相等的子集"><a href="#分成k个和相等的子集" class="headerlink" title="分成k个和相等的子集"></a>分成k个和相等的子集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;bool&gt; vis;</span><br><span class="line">    int n;</span><br><span class="line">public:</span><br><span class="line">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        vis = vector&lt;bool&gt;(n, false);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % k) return false;</span><br><span class="line">        int target = sum / k;</span><br><span class="line">        return dfs(nums, 0, 0,target, k);</span><br><span class="line">    &#125;</span><br><span class="line">    //cur:桶内现有的数</span><br><span class="line">    bool dfs(vector&lt;int&gt;&amp; nums,int start, int cur, int target, int k) &#123;</span><br><span class="line">        if (k == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int count=0;</span><br><span class="line">            for(auto u:vis)</span><br><span class="line">            &#123;</span><br><span class="line">                if(u==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return count==nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur == target) &#123;</span><br><span class="line">            return dfs(nums, 0, 0, target, k - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; n; i++) &#123;</span><br><span class="line">            if (vis[i]) continue;</span><br><span class="line">            if (cur + nums[i] &gt; target) continue;</span><br><span class="line">            vis[i] = true;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            if (dfs(nums, i + 1, cur, target, k)) return true;</span><br><span class="line">            cur -= nums[i];</span><br><span class="line">            vis[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2)BFS"></a>(2)<strong>BFS</strong></h2><p>bfs把问题抽象成一个图，从一个点开始向四周扩散，解决的是从起点start到终点target的最短路径问题</p>
<h3 id="单向BFS模板"><a href="#单向BFS模板" class="headerlink" title="单向BFS模板"></a>单向BFS模板</h3><p><img src="https://img-blog.csdnimg.cn/20200129230222575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY2ODg5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 计算从起点 start 到终点 target 的最近距离</span><br><span class="line">int BFS(Node start, Node target) &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; // 核心数据结构</span><br><span class="line">    Set&lt;Node&gt; visited; // 避免走回头路</span><br><span class="line"></span><br><span class="line">    q.offer(start); // 将起点加入队列</span><br><span class="line">    visited.add(start);</span><br><span class="line">    int step = 0; // 记录扩散的步数</span><br><span class="line"></span><br><span class="line">    while (q not empty) &#123;</span><br><span class="line">        int sz = q.size();</span><br><span class="line">        /* 将当前队列中的所有节点向四周扩散 */</span><br><span class="line">        for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            /* 划重点：这里判断是否到达终点 */</span><br><span class="line">            if (cur is target)</span><br><span class="line">                return step;</span><br><span class="line">            /* 将 cur 的相邻节点加入队列 */</span><br><span class="line">            for (Node x : cur.adj())</span><br><span class="line">                if (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 划重点：更新步数在这里 */</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向BFS：用于直到起点和终点位置</p>
<h3 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">bool check(string a,string b)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(i&lt;a.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]!=b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            if(count&gt;1)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count==1;</span><br><span class="line">&#125;</span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; wordSet(wordList.begin(),wordList.end());</span><br><span class="line">        if(wordSet.find(endWord)==wordSet.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;string&gt; que1;</span><br><span class="line">        queue&lt;string&gt; que2;</span><br><span class="line">        unordered_map&lt;string,int&gt; map1;</span><br><span class="line">        unordered_map&lt;string,int&gt; map2;</span><br><span class="line">        que1.push(beginWord);</span><br><span class="line">        que2.push(endWord);</span><br><span class="line">        map1.insert(&#123;beginWord,0&#125;);</span><br><span class="line">        map2.insert(&#123;endWord,0&#125;);</span><br><span class="line">        while(!que1.empty()&amp;&amp;!que2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if(que1.size()&gt;que2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                que1.swap(que2);</span><br><span class="line">                map1.swap(map2);</span><br><span class="line">            &#125;</span><br><span class="line">            int size=que1.size();</span><br><span class="line">            while(size--)</span><br><span class="line">            &#123;</span><br><span class="line">                auto word=que1.front();</span><br><span class="line">                que1.pop();</span><br><span class="line">                int path=map1[word];</span><br><span class="line">                if(map2.count(word))</span><br><span class="line">                &#123;</span><br><span class="line">                    return path+map2[word]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i=0;i&lt;word.size();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int j=0;j&lt;26;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        char c=&#x27;a&#x27;+j;</span><br><span class="line">                        string newword=word;</span><br><span class="line">                        newword[i]=c;</span><br><span class="line">                        if(map1.count(newword)==0&amp;&amp;wordSet.find(newword)!=wordSet.end())</span><br><span class="line">                        &#123;</span><br><span class="line">                            map1[newword]=path+1;</span><br><span class="line">                            que1.push(newword);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="密码锁"><a href="#密码锁" class="headerlink" title="密码锁"></a>密码锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">string plus(string s,int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(s[i]==&#x27;9&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=&#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=s[i]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">string minus(string s,int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(s[i]==&#x27;0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=&#x27;9&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=s[i]-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123;</span><br><span class="line">    queue&lt;string&gt; que1;</span><br><span class="line">    queue&lt;string&gt; que2;</span><br><span class="line">    int step=0;</span><br><span class="line">    unordered_set&lt;string&gt; set1;</span><br><span class="line">    unordered_set&lt;string&gt; set2;</span><br><span class="line">    unordered_set&lt;string&gt; deadset(deadends.begin(),deadends.end());</span><br><span class="line">    que1.push(&quot;0000&quot;);</span><br><span class="line">    que2.push(target);</span><br><span class="line">    set1.insert(&quot;0000&quot;);</span><br><span class="line">    set2.insert(target);</span><br><span class="line">    while(!que1.empty()&amp;&amp;!que2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        if(que1.size()&gt;que2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            que1.swap(que2);</span><br><span class="line">            set1.swap(set2);</span><br><span class="line">        &#125;</span><br><span class="line">        int size=que1.size();</span><br><span class="line">        while(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp=que1.front();</span><br><span class="line">            que1.pop();</span><br><span class="line">            if(deadset.find(tmp)!=deadset.end())</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(set2.find(tmp)!=set2.end())</span><br><span class="line">            &#123;</span><br><span class="line">                return step;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=0;i&lt;4;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                string newword=plus(tmp,i);</span><br><span class="line">                if(set1.find(newword)==set1.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    que1.push(newword);</span><br><span class="line">                    set1.insert(newword);</span><br><span class="line">                &#125;</span><br><span class="line">                string newword1=minus(tmp,i);</span><br><span class="line">                if(set1.find(newword1)==set1.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    que1.push(newword1);</span><br><span class="line">                    set1.insert(newword1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省份数量-朋友圈"><a href="#省份数量-朋友圈" class="headerlink" title="省份数量+朋友圈"></a>省份数量+朋友圈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</span><br><span class="line"></span><br><span class="line">省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</span><br><span class="line"></span><br><span class="line">给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</span><br><span class="line"></span><br><span class="line">返回矩阵中 省份 的数量。</span><br></pre></td></tr></table></figure>

<p>示例 1：</p>
<p>输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p>
<p>示例 2：</p>
<p>输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以采用bfs、dfs、并查集的方式</span><br></pre></td></tr></table></figure>

<p>bfs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;bool&gt; isvisit;</span><br><span class="line">void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected,int i)</span><br><span class="line">&#123;</span><br><span class="line">    isvisit[i]=true;</span><br><span class="line">    int node=i;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size=que.size();</span><br><span class="line">        int tmp=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int j=0;j&lt;isConnected.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp==j)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!isvisit[j]&amp;&amp;isConnected[tmp][j]==1)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(j);</span><br><span class="line">                isvisit[j]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;</span><br><span class="line">    isvisit=vector&lt;bool&gt;(isConnected.size(),false);</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=0;i&lt;isConnected.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isvisit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            bfs(isConnected,i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dfs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;bool&gt; isvisit;</span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected,int i)</span><br><span class="line">&#123;</span><br><span class="line">    isvisit[i]=true;</span><br><span class="line">    for(int j=0;j&lt;isConnected.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==j)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!isvisit[j]&amp;&amp;isConnected[i][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(isConnected,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;</span><br><span class="line">    isvisit=vector&lt;bool&gt;(isConnected.size(),false);</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=0;i&lt;isConnected.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isvisit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(isConnected,i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h1><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般dp[i]或者dp[i][j]定义均是以i或者j结尾的nums满足的最大。。。，然后有一个全局变量记录所有的最大值</span><br><span class="line"></span><br><span class="line">如果不行再将dp[i]定义为非结尾数字的满足题意的最大值</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1625312260-JHtQFs-image.png" alt="image.png"></p>
<h2 id="最长公共子序列（LCS-最多的不相交的线"><a href="#最长公共子序列（LCS-最多的不相交的线" class="headerlink" title="最长公共子序列（LCS)+最多的不相交的线"></a>最长公共子序列（LCS)+最多的不相交的线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个定义就不是以i结尾</span><br><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">        int max=INT_MIN;</span><br><span class="line">        int m=text1.size();</span><br><span class="line">        int n=text2.size();</span><br><span class="line">        //dp[i+1][j+1]定义为t1[0：i]与t2[0：j]的最大公共子序列为结尾</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(text1[i]==text2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+1][j+1]=dp[i][j]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+1][j+1]=std::max(dp[i+1][j],dp[i][j+1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//动态规划</span><br><span class="line">1.dp数组定义</span><br><span class="line">	dp[i]表示以nums[i]结尾的子序列最大值   i:0~n-1</span><br><span class="line">2.状态转移方程</span><br><span class="line">	dp[i]=max(dp[i-1],dp[i-1]+nums[i])</span><br><span class="line">	</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //动态规划</span><br><span class="line">    //1.dp[i]表示以nums[i]结尾的最大子序列和</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(),0);</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        int ans=dp[0];</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(nums[i],dp[i-1]+nums[i]);</span><br><span class="line">            ans=max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="输出最大子数组和的每个元素"><a href="#输出最大子数组和的每个元素" class="headerlink" title="输出最大子数组和的每个元素"></a>输出最大子数组和的每个元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用两个hashtable存区间开始值和结束值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; maxSubArray(vector&lt;int&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">    int n=input.size();</span><br><span class="line">    //key是最大值,value为起始位置</span><br><span class="line">    unordered_map&lt;int,int&gt; hash;</span><br><span class="line">    unordered_map&lt;int,int&gt; hashe;</span><br><span class="line">    vector&lt;int&gt; dp(n,0);</span><br><span class="line">    //dp[i]表示以input[i]结尾最大子序列和</span><br><span class="line">    dp[0]=input[0];</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[i-1]&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=input[i];</span><br><span class="line">            hash[dp[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=input[i]+dp[i-1];</span><br><span class="line">            hash[dp[i]]=hash[dp[i-1]];</span><br><span class="line">        &#125;</span><br><span class="line">        hashe[dp[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    int mini=dp[0];</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mini=max(dp[i],mini);</span><br><span class="line">    &#125;</span><br><span class="line">    int start=hash[mini];</span><br><span class="line">    int end=hashe[mini];</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=start;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(input[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;int&gt; input;</span><br><span class="line">    while(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(getchar()==&#x27;\n&#x27;)</span><br><span class="line">            break;</span><br><span class="line">        input.push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; ans=maxSubArray(input);</span><br><span class="line">    for(auto num:ans)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串最长公共子数组并输出"><a href="#字符串最长公共子数组并输出" class="headerlink" title="字符串最长公共子数组并输出"></a>字符串最长公共子数组并输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:&quot;abcde&quot;    b:&quot;cd&quot;</span><br><span class="line">输出：&quot;cd&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int maxlen=INT_MIN;</span><br><span class="line">int start=0;</span><br><span class="line">pair&lt;int,int&gt; getstr(string a,string b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a.size()&lt;b.size())</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(a.size()+1,vector&lt;int&gt;(b.size()+1,0));</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;b.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]==b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+1][j+1]=dp[i][j]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(dp[i+1][j+1]&gt;maxlen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen=dp[i+1][j+1];</span><br><span class="line">                start=i-maxlen+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;start,maxlen&#125;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a=&quot;abcde&quot;;</span><br><span class="line">    string b=&quot;cd&quot;;</span><br><span class="line">    int s;</span><br><span class="line">    int len;</span><br><span class="line">    tie(s,len)=getstr(a,b);</span><br><span class="line">    cout&lt;&lt;a.substr(s,len)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回文串数量"><a href="#回文串数量" class="headerlink" title="回文串数量"></a>回文串数量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]定义为s[i,j]之间是否为回文串</span><br><span class="line">i&lt;=j，则只填充右上角，dp[i][j]=true if s[i]==s[j]&amp;&amp;(j-i)&lt;2||dp[i+1][j-1]</span><br></pre></td></tr></table></figure>



<h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">递推公式</span><br><span class="line">dp(i,j)=min(dp(i-1,j-1),dp(i-1,j),dp(i,j-1))</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //dp[i][j]表示以matrix[i-1][j-1]为右下角正方向最大值</span><br><span class="line">        int m=matrix.size();</span><br><span class="line">        int n=matrix[0].size();</span><br><span class="line">        int ans=0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));</span><br><span class="line">        //dp[i][j]初始化为0，表示初始为0</span><br><span class="line">        //递推公式</span><br><span class="line">        //matrix[i][j]==1时</span><br><span class="line">        //dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(matrix[i][j]==&#x27;1&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+1][j+1]=min(min(dp[i][j],dp[i][j+1]),dp[i+1][j])+1;</span><br><span class="line">                    ans=max(ans,dp[i+1][j+1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//正方形子矩阵个数=所有dp[i][j]之和</span><br></pre></td></tr></table></figure>

<h2 id="最小路径和并输出最小路径"><a href="#最小路径和并输出最小路径" class="headerlink" title="最小路径和并输出最小路径"></a>最小路径和并输出最小路径</h2><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">pair&lt;vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;,int&gt; getminpath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)</span><br><span class="line">&#123;</span><br><span class="line">    int n=matrix.size();</span><br><span class="line">    int m=matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(m,INT_MAX));</span><br><span class="line">    //coorinate存当前[i,j]节点上一个最优点</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; coordinate(n,vector&lt;pair&lt;int,int&gt;&gt;(m,&#123;0,0&#125;));</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==0&amp;&amp;j==0)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=matrix[i][j];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(i==0)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i][j-1]+matrix[i][j];</span><br><span class="line">                coordinate[i][j]=pair&lt;int,int&gt;(i,j-1);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j==0)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j]+matrix[i][j];</span><br><span class="line">                coordinate[i][j]=pair&lt;int,int&gt;(i-1,j);                </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int left=dp[i][j-1]+matrix[i][j];</span><br><span class="line">                int up=dp[i-1][j]+matrix[i][j];</span><br><span class="line">                dp[i][j]=min(left,up);</span><br><span class="line">                coordinate[i][j]=left&lt;up?pair&lt;int,int&gt;(i,j-1):pair&lt;int,int&gt;(i-1,j);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;coordinate,dp[n-1][m-1]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix&#123;&#123;1,3,1&#125;,&#123;1,5,1&#125;,&#123;4,2,1&#125;&#125;;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; cor;</span><br><span class="line">    int min_sum;</span><br><span class="line">    int n=matrix.size();</span><br><span class="line">    int m=matrix[0].size();</span><br><span class="line">    tie(cor,min_sum)=getminpath(matrix);</span><br><span class="line">    vector&lt;pair&lt;int,int&gt;&gt; ans;</span><br><span class="line">    pair&lt;int,int&gt; tmp=cor[n-1][m-1];</span><br><span class="line">    ans.push_back(&#123;n-1,m-1&#125;);</span><br><span class="line">    while(tmp.first!=0||tmp.second!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        tmp=cor[tmp.first][tmp.second];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(&#123;0,0&#125;);</span><br><span class="line">    reverse(ans.begin(),ans.end());</span><br><span class="line">    cout&lt;&lt;min_sum&lt;&lt;endl;</span><br><span class="line">    for(auto cor:ans)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;(&quot;&lt;&lt;cor.first&lt;&lt;&quot;,&quot;&lt;&lt;cor.second&lt;&lt;&quot;)&quot;&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">分别处理第一列和对角线上的元素</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //dp[i-1][j-1]表示以tri[i-1][j-1]为结尾的最小路径和</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        int m=triangle.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(m,0));</span><br><span class="line">        dp[0][0]=triangle[0][0];</span><br><span class="line">        for(int i=1;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0]=dp[i-1][0]+triangle[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i]=dp[i-1][i-1]+triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        return *min_element(dp[m-1].begin(),dp[m-1].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种题目的思路一般是将dp[i]定义为前i个字符可以表示的解码方法，根据条件判断dp[i]怎么从dp[i-1]和dp[i-2]转移过来，要判断dp[0]和dp[1]的数字，只需要看dp[2]就行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        //动态规划</span><br><span class="line">        //dp[i]是前i个字符的翻译方法</span><br><span class="line">        string s=to_string(num);</span><br><span class="line">        int n=s.size();</span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==1)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]+=dp[i-1];</span><br><span class="line">            if(s[i-2]!=&#x27;0&#x27;&amp;&amp;s[i-1]-&#x27;0&#x27;+10*(s[i-2]-&#x27;0&#x27;)&lt;=25)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i-2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        int n=s.size();</span><br><span class="line">        //dp为[1,i]前i个字符并且以i结尾的字符串映射数量</span><br><span class="line">        //dp[i]=dp[i-1]+dp[i-2] or 0 or dp[i-1]</span><br><span class="line">        //dp[0]:前0个字符,1</span><br><span class="line">        //dp[1]:1</span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        dp[1]=s[0]==&#x27;0&#x27;?0:1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i-1]!=&#x27;0&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[i-2]!=&#x27;0&#x27;&amp;&amp;10*(s[i-2]-&#x27;0&#x27;)+s[i-1]-&#x27;0&#x27;&lt;=26)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i-2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://pic1.zhimg.com/80/v2-280fe01f0b2d03bb1d2de06682b0c388_1440w.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常见背包定义：</span><br><span class="line">	dp[i][j]：选择前i个物品塞容量为j的背包产生的最大价值</span><br><span class="line">	所以一般物品dp维数定义为：nums.size()+1，target+1(均多一维度)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0-1背包：所有物品只能选择一次,二维01背包两个for循环可以互换位置</span><br><span class="line">	dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1])</span><br><span class="line">	</span><br><span class="line">	weight数组遍历是从右向左，一维01背包两个for循环不能颠倒位置，一般先遍历物品，再遍历背包</span><br><span class="line">	dp[j]=max(dp[j],dp[j-weight[i-1]+value[i-1]])</span><br><span class="line">	所以在优化空间时对于weight数组的遍历必须从后往左更新	</span><br><span class="line">初始化：根据定义</span><br><span class="line">dp[i][0]=0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">完全背包：所有物品可以选择多次</span><br><span class="line">	dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i-1]]+k*value[i-1])</span><br><span class="line">	对weight数组遍历从左往右</span><br><span class="line">	dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i-1]])</span><br><span class="line">初始化：根据定义</span><br><span class="line">dp[i][0]=0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 先遍历物品，再遍历背包</span><br><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = weight[i]; j &lt; bagWeight ; j++) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意区别：0-1背包是从上一行的左边和上边转移过来</span><br><span class="line">		完全背包是从上一行上边和当前行左边转移过来</span><br><span class="line">初始化：</span><br><span class="line">	要根据所求条件初始化第一行第一列(如果压缩为1行，则注意当前行的初始化)</span><br><span class="line">	比如恰好装满j最少硬币数,dp[0][0]初始化为0，其他的dp[0][j]初始化为不存在的状态(不能简单的初始化为0)</span><br></pre></td></tr></table></figure>



<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>编辑距离（Minimum Edit Distance，MED），由俄罗斯科学家 Vladimir Levenshtein 在1965年提出，也因此而得名 Levenshtein Distance。</p>
<p>编辑距离指的是在两个单词<img src="https://math.jianshu.com/math?formula=%3Cw_1,w_2%3E" alt="&lt;w_1,w_2&gt;">之间，由其中一个单词<img src="https://math.jianshu.com/math?formula=w_1" alt="w_1">转换为另一个单词<img src="https://math.jianshu.com/math?formula=w_2" alt="w_2">所需要的最少<strong>单字符编辑操作</strong>次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在这里定义的单字符编辑操作有且仅有三种：</span><br><span class="line"></span><br><span class="line">- 插入（Insertion）</span><br><span class="line">- 删除（Deletion）</span><br><span class="line">- 替换（Substitution）</span><br><span class="line"></span><br><span class="line">譬如，&quot;kitten&quot; 和 &quot;sitting&quot; 这两个单词，由 &quot;kitten&quot; 转换为  &quot;sitting&quot;  需要的最少单字符编辑操作有：</span><br><span class="line"></span><br><span class="line">1.kitten → sitten (substitution of &quot;s&quot; for &quot;k&quot;)</span><br><span class="line">2.sitten → sittin (substitution of &quot;i&quot; for &quot;e&quot;)</span><br><span class="line">3.sittin  → sitting (insertion of &quot;g&quot; at the end)</span><br><span class="line"></span><br><span class="line">因此，&quot;kitten&quot; 和 &quot;sitting&quot; 这两个单词之间的编辑距离为 3 </span><br></pre></td></tr></table></figure>



<h1 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h1><h2 id="实现atoi"><a href="#实现atoi" class="headerlink" title="实现atoi"></a>实现atoi</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int atoi (const char * str)</span><br><span class="line">atoi忽略前导空格</span><br><span class="line">判断+-号</span><br><span class="line">再转化(直到非数字字符)</span><br><span class="line">第一个字符为非数字字符返回0</span><br><span class="line"></span><br><span class="line">to_string:可以转化正负数</span><br><span class="line">		  忽略前导0(默认留一个是八进制)</span><br><span class="line">		  </span><br><span class="line">stoi(int val,nullptr,int base=10)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string s) &#123;</span><br><span class="line">        int size=s.size();</span><br><span class="line">        if(size==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int idx=0;</span><br><span class="line">        bool plus=true;</span><br><span class="line">        long long ans=0;   </span><br><span class="line">        while(s[idx]==&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        //正号负号处理</span><br><span class="line">        if(s[idx]==&#x27;+&#x27;||s[idx]==&#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            plus=s[idx]==&#x27;+&#x27;?true:false;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(idx&gt;=size||!isdigit(s[idx]))</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        while(isdigit(s[idx])&amp;&amp;idx&lt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=10*ans+(s[idx++]-&#x27;0&#x27;);</span><br><span class="line">            if(ans&gt;INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!plus)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(-ans&lt;INT_MIN)</span><br><span class="line">                    &#123;</span><br><span class="line">                        return INT_MIN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        return -ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return plus==false?-ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="实现string类"><a href="#实现string类" class="headerlink" title="实现string类"></a>实现string类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class String&#123;</span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    String(const char *str = nullptr);</span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    String(const String &amp;str);</span><br><span class="line">    // 析构函数</span><br><span class="line">    ~String();</span><br><span class="line">    // 字符串赋值函数</span><br><span class="line">    String&amp; operator=(const String &amp;str);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char *m_data;</span><br><span class="line">    int m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 构造函数</span><br><span class="line">String::String(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    if(str == nullptr)  // 加分点：对m_data加NULL 判断</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = new char[1];   // 得分点：对空字符串自动申请存放结束标志&#x27;\0&#x27;的</span><br><span class="line">        m_data[0] = &#x27;\0&#x27;;</span><br><span class="line">        m_size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        m_size = strlen(str);</span><br><span class="line">        m_data = new char[m_size + 1];</span><br><span class="line">        strcpy(m_data, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝构造函数</span><br><span class="line">String::String(const String &amp;str)   // 得分点：输入参数为const型</span><br><span class="line">&#123;</span><br><span class="line">    m_size = str.m_size;</span><br><span class="line">    m_data = new char[m_size + 1];  //加分点：对m_data加NULL 判断</span><br><span class="line">    strcpy(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构函数</span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">    delete[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串赋值函数</span><br><span class="line">/*</span><br><span class="line">我们先用delete释放了实例m_data的内存，如果此时内存不足导致new char抛出异常，则m_data将是一个空指针，</span><br><span class="line">这样非常容易导致程序崩溃。违背了异常安全性原则。</span><br><span class="line">*/</span><br><span class="line">String&amp; String::operator=(const String &amp;str)  // 得分点：输入参数为const</span><br><span class="line">&#123;</span><br><span class="line">    if(this == &amp;str)    //得分点：检查自赋值</span><br><span class="line">        return *this;</span><br><span class="line"></span><br><span class="line">    delete[] m_data;    //得分点：释放原有的内存资源</span><br><span class="line">    m_size = strlen(str.m_data);</span><br><span class="line">    m_data = new char[m_size + 1];  //加分点：对m_data加NULL 判断</span><br><span class="line">    strcpy(m_data, str.m_data);</span><br><span class="line">    return *this;       //得分点：返回本对象的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串赋值函数（推荐使用）</span><br><span class="line">// 保证了异常安全性</span><br><span class="line">String&amp; String::operator=(const String &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    if(this != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        String strTemp(str);</span><br><span class="line"></span><br><span class="line">        char* pTemp = strTemp.m_data;</span><br><span class="line">        strTemp.m_data = m_data;</span><br><span class="line">        m_data = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>对于字符串s和p，若p是s的子串，返回p在s中的位置（p的首字符在s中对应的下标），否则返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">1.朴素暴力</span><br><span class="line"></span><br><span class="line">int charmatch(string s,string p)</span><br><span class="line">&#123;</span><br><span class="line">	int m=s.size();</span><br><span class="line">	int n=p.size();</span><br><span class="line">	if(n==0)</span><br><span class="line">		return 0;</span><br><span class="line">	int i=0;</span><br><span class="line">	int j=0;</span><br><span class="line">	while(i&lt;m&amp;&amp;j&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s[i]==p[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			i=i-j+1;</span><br><span class="line">			j=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(j==n)</span><br><span class="line">	&#123;</span><br><span class="line">		return i-j;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.改进朴素暴力</span><br><span class="line">int charmatch(string s,string p)</span><br><span class="line">&#123;</span><br><span class="line">	int m=s.size();</span><br><span class="line">	int n=p.size();</span><br><span class="line">	if(n==0)</span><br><span class="line">		return 0;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;=m-n)</span><br><span class="line">	&#123;</span><br><span class="line">		int j=i;</span><br><span class="line">		int k=0;</span><br><span class="line">		while(k&lt;n&amp;&amp;s[j]==p[k])</span><br><span class="line">		&#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(k==m)</span><br><span class="line">			return i;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.KMP算法</span><br><span class="line">next[i] 数组表示的是模式串[0,i]子串最长公共前后缀长度</span><br><span class="line">	    也可以认当i不匹配时，next[i-1]就是i应该回溯的位置</span><br><span class="line">next数组求法：</span><br><span class="line">	void getNext(int* next,string p)</span><br><span class="line">	&#123;</span><br><span class="line">		int n=p.size();</span><br><span class="line">		if(n==0)</span><br><span class="line">			next=nullptr;</span><br><span class="line">		int j=0;</span><br><span class="line">		next[0]=0;</span><br><span class="line">		for(int i=1;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			while(j&gt;0&amp;&amp;(p[i]!=p[j]))</span><br><span class="line">			&#123;</span><br><span class="line">				j=next[j-1];</span><br><span class="line">			&#125;</span><br><span class="line">			if(p[i]==p[j])</span><br><span class="line">			&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			next[i]=j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    int strStr(string haystack, string needle)</span><br><span class="line">    &#123;</span><br><span class="line">        if(needle.size()==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int next[needle.size()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        int j=0;</span><br><span class="line">        for(int i=0;i&lt;haystack.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(j&gt;0&amp;&amp;haystack[i]!=needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            if(haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j==needle.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return i-needle.size()+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每2k个反转前k个</span><br><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string reversestr(string s,int k)</span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    int n=s.size();</span><br><span class="line">    for(int i=0;i&lt;n;i+=2*k)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(s.begin()+i,min(s.begin()+i+k,s.end()));</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转每个单词(可能有多个空格)</span><br><span class="line">I am a student</span><br><span class="line">student a am I</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：给定一个指针index从0开始</span><br><span class="line">     start记录end!=&#x27; &#x27;的开始</span><br><span class="line">     index记录不为&#x27; &#x27;的结束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string reverseWords(string s) &#123;</span><br><span class="line">    int n=s.size();</span><br><span class="line">    int l=0;</span><br><span class="line">    int r=0;</span><br><span class="line">    int index=0;</span><br><span class="line">    //&quot;    I am     a    student    &quot;</span><br><span class="line">    while(r&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">    	//1.判断大右边界是否为空</span><br><span class="line">        if(s[r]==&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //4.添加空格</span><br><span class="line">        if(index!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            s[index++]=&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        //2.记录左边界</span><br><span class="line">        l=index;</span><br><span class="line">        //3.移动两个右边界</span><br><span class="line">        while(r&lt;n&amp;&amp;s[r]!=&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            s[index++]=s[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        //4.反转左右边界</span><br><span class="line">        reverse(s.begin()+l,s.begin()+index);</span><br><span class="line">    &#125;</span><br><span class="line">    s.erase(s.begin()+index,s.end());</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串模拟大数相乘"><a href="#字符串模拟大数相乘" class="headerlink" title="字符串模拟大数相乘"></a>字符串模拟大数相乘</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.从后向前遍历</span><br><span class="line">2.定义的一维数组最长位m+n</span><br><span class="line">3.res[i+j+1]为相乘的后一位，res[i+j]为进位的那位，sum=res[i+j+1]+num[i]*num[j],res[i+j+1]=sum%10,res[i+j]+=sum/10,往前移动时，后面多的进位会再次累加到上上一位</span><br><span class="line">4.不要忘了最多是m+n位，不要忘记*0的情况</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string multiply(string num1, string num2) &#123;</span><br><span class="line">        int m=num1.size();</span><br><span class="line">        int n=num2.size();</span><br><span class="line">        //res最多m+n位</span><br><span class="line">        vector&lt;int&gt; res(n+m,0);</span><br><span class="line">        for(int i=m-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=n-1;j&gt;=0;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                int sum=res[j+i+1]+(num1[i]-&#x27;0&#x27;)*(num2[j]-&#x27;0&#x27;);</span><br><span class="line">                res[j+i+1]=sum%10;</span><br><span class="line">                //记录后面的进位不可能</span><br><span class="line">                res[i+j]+=sum/10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //去除前导0</span><br><span class="line">        int i=0;</span><br><span class="line">        for(;i&lt;res.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[i]!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //i记录了第一个不为0的位置</span><br><span class="line">        string ans;</span><br><span class="line">        for(;i&lt;res.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=to_string(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans.size()==0?&quot;0&quot;:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1600675705-DasmDU-file_1600675705288" alt="img"></p>
<h2 id="字符串排列找最大"><a href="#字符串排列找最大" class="headerlink" title="字符串排列找最大"></a>字符串排列找最大</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //自定义排序规则   3  43     343   433比较两个排列哪个大</span><br><span class="line">    sort(nums.begin(),nums.end(),[](const int&amp; a,const int&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        int sx=10;</span><br><span class="line">        int sy=10;</span><br><span class="line">        while(sx&lt;=a)</span><br><span class="line">        &#123;</span><br><span class="line">            sx*=10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(sy&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            sy*=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sy*a+b&gt;sx*b+a;</span><br><span class="line">    &#125;);</span><br><span class="line">    if(nums[0]==0)</span><br><span class="line">    &#123;</span><br><span class="line">    	return &quot;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    for(auto num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=to_string(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-智能指针"><a href="#7-智能指针" class="headerlink" title="7.智能指针"></a>7.智能指针</h1><h2 id="shared-ptr实现"><a href="#shared-ptr实现" class="headerlink" title="shared_ptr实现"></a>shared_ptr实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">    private:</span><br><span class="line">        T* m_ptr;</span><br><span class="line">        int* m_count;</span><br><span class="line">    public:</span><br><span class="line">        //初始化最好只用一次裸指针</span><br><span class="line">        Shared_ptr(T* ptr=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ptr==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                *m_count=new int(0);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                *m_count=new int(1);</span><br><span class="line">                *m_ptr=ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //拷贝构造函数</span><br><span class="line">        Shared_ptr(const Shared_ptr&amp; sptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //排除自己构造自己</span><br><span class="line">            if(this!=&amp;sptr)</span><br><span class="line">            &#123;</span><br><span class="line">                this-&gt;m_ptr=sptr-&gt;m_ptr;</span><br><span class="line">                this-&gt;m_count=sptr-&gt;count;</span><br><span class="line">                (*this-&gt;m_count)++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //赋值运算符重载</span><br><span class="line">        Shared_ptr&amp; operator=(const Shared_ptr&amp; sptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this==&amp;sptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return *this;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前指向不为空，减去</span><br><span class="line">            if(this-&gt;m_ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                *(this-&gt;m_count)--;</span><br><span class="line">                if(*this-&gt;m_count==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    delete this-&gt;m_count;</span><br><span class="line">                    delete this-&gt;m_ptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //此时指向可以为空或者不为空</span><br><span class="line">            this-&gt;m_count=sptr-&gt;m_count;</span><br><span class="line">            this-&gt;m_ptr=sptr-&gt;m_ptr;</span><br><span class="line">            (*this-&gt;m_count)++;</span><br><span class="line">            return *this;      </span><br><span class="line">        &#125;</span><br><span class="line">        //重载*，对于非空返回地址里面的东西</span><br><span class="line">        T&amp; operator* ()</span><br><span class="line">        &#123;</span><br><span class="line">            if(this-&gt;m_ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return *this-&gt;m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //重载-&gt;，对于非空指针，返回指向的东西</span><br><span class="line">        T&amp; operator-&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            if(this-&gt;m_ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return this-&gt;m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Shared_ptr()</span><br><span class="line">        &#123;</span><br><span class="line">            if(--(*m_count)==0)</span><br><span class="line">            &#123;</span><br><span class="line">                delete m_count;</span><br><span class="line">                delete m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int use_count()</span><br><span class="line">        &#123;</span><br><span class="line">            return *this-&gt;m_count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class munique_ptr&#123;</span><br><span class="line">    T *ptr;</span><br><span class="line">    public:</span><br><span class="line">    munique_ptr(T *_ptr=NULL):ptr(_ptr)&#123;&#125;</span><br><span class="line">    ~munique_ptr()</span><br><span class="line">    &#123;</span><br><span class="line">        delete ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除拷贝构造函数</span><br><span class="line">    munique_ptr(const munique_ptr &amp;r)=delete;</span><br><span class="line">    //删除赋值运算符重载函数</span><br><span class="line">    munique_ptr &amp;operator=(const munique_ptr &amp;r)=delete;</span><br><span class="line"></span><br><span class="line">    T operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    munique_ptr&lt;double&gt; ptr(new double(3.14));</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">    munique_ptr&lt;double&gt; ptr1=ptr;</span><br><span class="line">    munique_ptr&lt;double&gt; ptr2;</span><br><span class="line">    ptr2=ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="8-大厂常考"><a href="#8-大厂常考" class="headerlink" title="8.大厂常考"></a>8.大厂常考</h1><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        size=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if(!map.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; tempair=map[key];</span><br><span class="line">            dlink.remove(tempair);</span><br><span class="line">            dlink.push_back(tempair);</span><br><span class="line">            return tempair.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if(map.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; tempair=map[key];</span><br><span class="line">            int temvalue=tempair.second;</span><br><span class="line">            map.erase(key);</span><br><span class="line">            map[key]=&#123;key,value&#125;;</span><br><span class="line">            dlink.remove(&#123;key,temvalue&#125;);</span><br><span class="line">            dlink.push_back(&#123;key,value&#125;);                </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dlink.push_back(&#123;key,value&#125;);</span><br><span class="line">            map.insert(&#123;key,&#123;key,value&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(dlink.size()&gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            auto tem=dlink.front().first;</span><br><span class="line">            dlink.pop_front();</span><br><span class="line">            map.erase(tem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    list&lt;pair&lt;int,int&gt;&gt; dlink;</span><br><span class="line">    unordered_map&lt;int,pair&lt;int,int&gt;&gt; map;</span><br><span class="line">    int size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="异或运算性质"><a href="#异或运算性质" class="headerlink" title="异或运算性质"></a>异或运算性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x^x=0;</span><br><span class="line">x^0=x;</span><br></pre></td></tr></table></figure>

<h3 id="一个只出现一次，其他出现两次"><a href="#一个只出现一次，其他出现两次" class="headerlink" title="一个只出现一次，其他出现两次"></a>一个只出现一次，其他出现两次</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    	int x=0;</span><br><span class="line">    	for(auto num:nums)</span><br><span class="line">    	&#123;</span><br><span class="line">    		x^=num;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="一个只出现一次，其他出现三次"><a href="#一个只出现一次，其他出现三次" class="headerlink" title="一个只出现一次，其他出现三次"></a>一个只出现一次，其他出现三次</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int bits;</span><br><span class="line">        for(int i=0;i&lt;31;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bits=0;</span><br><span class="line">            for(auto num:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                bits+=(num&gt;&gt;i)&amp;1;</span><br><span class="line">            &#125;</span><br><span class="line">            ans|=bits%3&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="两个只出现一次，其他出现两次"><a href="#两个只出现一次，其他出现两次" class="headerlink" title="两个只出现一次，其他出现两次"></a>两个只出现一次，其他出现两次</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.先异或求出xy异或</span><br><span class="line">2.找到xy中低位的1</span><br><span class="line">3.每个数再异或xy分组</span><br><span class="line">4.分组后组内异或</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //先异或求x,y的异或</span><br><span class="line">        int xy=0;</span><br><span class="line">        int m=1;</span><br><span class="line">        int x=0;</span><br><span class="line">        int y=0;</span><br><span class="line">        for(auto num:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            xy^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        //找xy第一个1,把xy分开</span><br><span class="line">        while((xy&amp;m)==0)</span><br><span class="line">        &#123;</span><br><span class="line">            m&lt;&lt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        //分组</span><br><span class="line">        for(auto num:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            if(num&amp;m)</span><br><span class="line">            &#123;</span><br><span class="line">                x^=num;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                y^=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans=&#123;x,y&#125;;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三个只出现一次，其余出现两次"><a href="#三个只出现一次，其余出现两次" class="headerlink" title="三个只出现一次，其余出现两次"></a>三个只出现一次，其余出现两次</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1. x &amp; (-x)所得的结果即是x最后一位1所在的位置。</span><br><span class="line">2. x = a ^ b ^ c, f(x) = x &amp; (-x)</span><br><span class="line">3. f(x^a)^f(x^b)^f(x^c) 结果必有一位是1，因为f(m)^f(n)结果为0或者为2个1</span><br><span class="line">4. f(x^a)^f(x^b)^f(x^c)的第m位为1，则x^a, x^b, x^c必有1个或者3个第m位为1</span><br><span class="line">5. 用反证法可得，x^a, x^b, x^c只有一个第m位为1</span><br><span class="line"></span><br><span class="line">我们定义一个函数f(n)，它的结果是保留数字n的二进制表示中的最后一位1，而把其他所有位都变成0。比如十进制6表示成二进制是0110，因此f(6)的结果为2（二进制为0010）。f(x^a)、f(x^b)、f(x^c)的结果均不等于0。</span><br><span class="line"></span><br><span class="line">接着我们考虑f(x^a)^f(x^b)^f(x^c)的结果。由于对于非0的n，f(n)的结果的二进制表示中只有一个数位是1，因此f(x^a)^f(x^b)^f(x^c)的结果肯定不为0。这是因为对于任意三个非零的数i、j、k，f(i)^f(j)的结果要么为0，要么结果的二进制结果中有两个1。不管是那种情况，f(i)^f(j)都不可能等于f(k)，因为f(k)不等于0，并且结果的二进制中只有一位是1。</span><br><span class="line"></span><br><span class="line">于是f(x^a)^f(x^b)^f(x^c)的结果的二进制中至少有一位是1。假设最后一位是1的位是第m位。那么x^a、x^b、x^c的结果中，有一个或者三个数字的第m位是1。</span><br><span class="line"></span><br><span class="line">接下来我们证明x^a、x^b、x^c的三个结果第m位不可能都是1。还是用反证法证明。</span><br><span class="line"></span><br><span class="line">如果x^a、x^b、x^c的第m位都是1，那么a、b、c三个数字的第m位和x的第m位都相反，因此a、b、c三个数字的第m位相同。如果a、b、c三个数字的第m位都是0，x=a^b^c结果的第m位是0。由于x和a两个数字的第m位都是0，x^a结果的第m位应该是0。同理可以证明x^b、x^c第m位都是0。这与我们的假设矛盾。如果a、b、c三个数字的第m位都是1，x=a^b^c结果的第m位是1。由于x和a两个数字的第m位都是1，x^a结果的第m位应该是0。同理可以证明x^b、x^c第m位都是0。这还是与我们的假设矛盾。</span><br><span class="line"></span><br><span class="line">因此x^a、x^b、x^c三个数字中，只有一个数字的第m位是1。于是我们找到了能够区分a、b、c三个数字的标准。这三个数字中，只有一个数字满足这个标准，而另外两个数字不满足。一旦这个满足标准数字找出来之后，另外两个数字也就可以找出来了。</span><br></pre></td></tr></table></figure>

<h3 id="常用位运算"><a href="#常用位运算" class="headerlink" title="常用位运算"></a>常用位运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.x&amp;(-x)：保留二进制下最后出现的1的位置，其余位置置0（即一个数中最大的2的n次幂的因数</span><br><span class="line">2.x&amp;(x-1)：消除二进制下最后出现1的位置，其余保持不变</span><br></pre></td></tr></table></figure>

<h3 id="Rand8实现Rand12"><a href="#Rand8实现Rand12" class="headerlink" title="Rand8实现Rand12"></a>Rand8实现Rand12</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">使用公式(RandX-1)*Y+RandY可以实现RandXY模拟[1,X*Y]</span><br><span class="line">比如只有rand8时模拟rand12，(rand8-1)*8+rand8可以模拟出1-64</span><br><span class="line">但是我们只需要rand12，要舍去61-64，太多了</span><br><span class="line">再次使用(num-60-1)*8+rand8模拟[1-32],舍去[25,32]</span><br><span class="line">再次使用(num-24-1)*8+rand8模拟[1-64],舍去[61-64]</span><br><span class="line">循环，最终选择舍去61-64即可</span><br><span class="line">int rand12()</span><br><span class="line">&#123;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		int num=(rand8-1)*8+rand8;</span><br><span class="line">		if(num&lt;=60)</span><br><span class="line">		&#123;</span><br><span class="line">			return num%12+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><p>使用场景:最近的一个比当前值大/小</p>
<p>1.单调栈一般从后往前遍历</p>
<p>2.单调栈保存的是nums[i]右边均小于(大于)元素的按照从大到小的顺序排列</p>
<p>![](G:\OneDrive - 东南大学\面试准备\算法\单调栈\幻灯片1.PNG)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; st;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	while(!st.empty() &amp;&amp; st.top() &gt; nums[i])</span><br><span class="line">	&#123;</span><br><span class="line">		st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	st.push(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; ans(nums.size()); // 存放答案的数组</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; // 倒着往栈里放</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; // 判定个子高矮</span><br><span class="line">            s.pop(); // 矮个起开，反正也被挡着了。。。</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个</span><br><span class="line">        s.push(nums[i]); // 进队，接受之后的身高判定吧！</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="技巧循环数组"><a href="#技巧循环数组" class="headerlink" title="技巧循环数组"></a>技巧循环数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">将原数组扩展为2倍</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n=nums.size();</span><br><span class="line">        vector&lt;int&gt; ans(n,0);</span><br><span class="line">        stack&lt;int&gt; sta;</span><br><span class="line">        for(int i=2*n-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            while(!sta.empty()&amp;&amp;sta.top()&lt;=nums[i%n])</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i%n]=sta.empty()?-1:sta.top();</span><br><span class="line">            sta.push(nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路1：暴力，找到i位置左右最大的元素，每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度-当前柱子高度</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1617328346-rDZcQx-file_1617328346572" alt="42.接雨水3"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        //暴力</span><br><span class="line">        //按列进行求取，i=0和size-1时柱子不能蓄水</span><br><span class="line">        //i位置储水高度为左右最大值中最小值-当前高度(大于0才能储水)</span><br><span class="line">        int n=height.size();</span><br><span class="line">        int h=0;</span><br><span class="line">        int ans=0;</span><br><span class="line">        vector&lt;int&gt; leftmax(n,0);</span><br><span class="line">        vector&lt;int&gt; rightmax(n,0);</span><br><span class="line">        //leftmax[i]表示[0,i-1]中最大的</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax[i]=max(leftmax[i-1],height[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        //rightmax[j]表示[j+1,n-1]最大的</span><br><span class="line">        for(int j=n-2;j&gt;=0;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            rightmax[j]=max(rightmax[j+1],height[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;n-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            h=min(leftmax[i],rightmax[i])-height[i];</span><br><span class="line">            if(h&gt;0)</span><br><span class="line">                ans+=h;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路2：单调栈，栈为单调递增栈(栈顶到栈底单调递增)，判断刚入栈元素，栈顶和栈顶下面那个元素形成凹槽则可以计算，等于当前元素等于栈顶直接加入</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210819161704126.png" alt="image-20210819161704126"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123; </span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; height.size(); i++) &#123;</span><br><span class="line">            while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;</span><br><span class="line">                int mid = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if (!st.empty()) &#123;</span><br><span class="line">                    int h = min(height[st.top()], height[i]) - height[mid];</span><br><span class="line">                    int w = i - st.top() - 1;</span><br><span class="line">                    sum += h * w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="柱状图中最大矩阵"><a href="#柱状图中最大矩阵" class="headerlink" title="柱状图中最大矩阵"></a>柱状图中最大矩阵</h3><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思路：单调递减栈(栈顶到栈底单调递减)</span><br><span class="line">	1.heights[i]&gt;height[sta.top()]，加入sta</span><br><span class="line">	2.heights[i]==sta.top(),加入sta</span><br><span class="line">	3.heights[i]&lt;height[sta.top()]，当前i是小于height[sta.top]的右边界，sta.pop()之后，sta如果为空则说明只有一个右边界，不为空说明此时的sta.top()为小于上一个sta.top()的左边界，定位这两个左右边界便可以求出我们的以i为中心的最大面积，即可以判断出当前小于sta.top()的左右边界，可以计算最大面积</span><br><span class="line">注意没有右边界或者左边界的情况</span><br><span class="line">[2,4] 2和4都没有右边界，可以人工加一个0</span><br><span class="line">[1] 1没有左边界，人工加一个0</span><br><span class="line">heights.insert(heights.begin(),0);</span><br><span class="line">heights.push_back(0);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        heights.insert(heights.begin(),0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        int n=heights.size();</span><br><span class="line">        stack&lt;int&gt; sta;</span><br><span class="line">        int h=0;</span><br><span class="line">        int w=0;</span><br><span class="line">        int mid=0;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(!sta.empty()&amp;&amp;heights[sta.top()]&gt;heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                mid=sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                h=heights[mid];</span><br><span class="line">                left=sta.empty()?i-1:sta.top();</span><br><span class="line">                right=i;</span><br><span class="line">                w=right-left-1;</span><br><span class="line">                ans=max(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>不允许排序则采用暴力或者哈希表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; hash;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(hash.find(target-nums[i])!=hash.end())</span><br><span class="line">            &#123;</span><br><span class="line">                return &#123;hash[target-nums[i]],i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>允许排序，采用左右双指针，两指针所在元素&gt;target,右指针左移;两指针元素&lt;target,左指针右移，直到==</p>
<p>所以当要返回下标时，不应该排序</p>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>求所有按照元素顺序排序的a+b+c=0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; twosum(vector&lt;int&gt;&amp; nums,int endIndex,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; hash;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        for(int i=0;i&lt;endIndex;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(auto key:hash)</span><br><span class="line">            &#123;</span><br><span class="line">                if(key.first==target-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(&#123;key.first,nums[i]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=twosum(nums,i,-nums[i]);</span><br><span class="line">            if(!tmp.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                for(auto&amp; num:tmp)</span><br><span class="line">                    ans.push_back(&#123;num[0],num[1],nums[i]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="求不重复的a-b-c-0"><a href="#求不重复的a-b-c-0" class="headerlink" title="求不重复的a+b+c=0"></a>求不重复的a+b+c=0</h3><p>排序后双指针，同时对i,left,right三个位置去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">//i去重</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            left=i+1;</span><br><span class="line">            right=nums.size()-1;</span><br><span class="line">            while(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                //left去重</span><br><span class="line">                if(left&gt;i+1&amp;&amp;nums[left]==nums[left-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //right去重</span><br><span class="line">                if(right&lt;nums.size()-1&amp;&amp;nums[right]==nums[right+1])</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //right去重</span><br><span class="line">                </span><br><span class="line">                if(nums[left]+nums[right]==-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back( &#123;nums[i],nums[left],nums[right]&#125; );</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(nums[left]+nums[right]&gt;-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.一般prefix[i]表示包含i个数字的前缀和</span><br><span class="line">2.使用上述prefix定义不需要再向hash中push hash[0]=1</span><br><span class="line">3.查找时从i=1开始</span><br><span class="line"></span><br><span class="line">当遍历时，从1~nums.size(),进来就hash先加上上一个元素的prefix，这样可以添加到prefix[0]这个元素，就不再需要提前添加了</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; prefix(nums.size()+1,0);</span><br><span class="line">    unordered_map&lt;int,int&gt; hash;</span><br><span class="line">    for(int i=1;i&lt;=nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[i]=prefix[i-1]+nums[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=1;i&lt;=nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash[prefix[i-1]]++;</span><br><span class="line">        if(hash.count(prefix[i]-k))</span><br><span class="line">        &#123;</span><br><span class="line">            count+=hash[prefix[i]-k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; sumk(vector&lt;int&gt; input,int k)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; prefix(input.size()+1);</span><br><span class="line">    for(int i=0;i&lt;input.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[i+1]=prefix[i]+input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    unordered_map&lt;int,int&gt; hash;</span><br><span class="line">    //key=前缀和 value=个数</span><br><span class="line">    unordered_map&lt;int,int&gt; hashi;</span><br><span class="line">    hashi[0]=-1;</span><br><span class="line">    hash[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=input.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hash.count(prefix[i]-k))</span><br><span class="line">        &#123;</span><br><span class="line">            if(hashi[prefix[i]-k]==-1)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(&#123;0,i-1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(&#123;hashi[prefix[i]-k],i-1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            count+=hash[prefix[i]-k];</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefix[i]]++;</span><br><span class="line">        hashi[prefix[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; input&#123;1,2,3,4&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans=sumk(input,7);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不同定义下的prefix"><a href="#不同定义下的prefix" class="headerlink" title="不同定义下的prefix"></a>不同定义下的prefix</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; sumk(vector&lt;int&gt; input,int k)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    //prefix[i]定义为以nums[i]结尾的前缀和</span><br><span class="line">    vector&lt;int&gt; prefix(input.size());</span><br><span class="line">    prefix[0]=input[0];</span><br><span class="line">    for(int i=1;i&lt;input.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[i]=prefix[i-1]+input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    unordered_map&lt;int,int&gt; hash;</span><br><span class="line">    unordered_map&lt;int,int&gt; hash_index;</span><br><span class="line">    //key=前缀和 value=个数</span><br><span class="line">    hash[0]=1;</span><br><span class="line">    hash_index[0]=-1;</span><br><span class="line">    for(int i=0;i&lt;input.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hash.count(prefix[i]-k))</span><br><span class="line">        &#123;</span><br><span class="line">            if(hash_index[prefix[i]-k]==-1)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; tmp;</span><br><span class="line">                for(int j=0;j&lt;=i;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(input[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; tmp1;</span><br><span class="line">                for(int j=hash_index[prefix[i]-k]+1;j&lt;=i;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp1.push_back(input[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(tmp1);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count+=hash[prefix[i]-k];</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefix[i]]++;</span><br><span class="line">        hash_index[prefix[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; input&#123;1,2,3,4&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans=sumk(input,7);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="洗牌算法-shuffle"><a href="#洗牌算法-shuffle" class="headerlink" title="洗牌算法(shuffle)"></a>洗牌算法(shuffle)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">    int ran=rand()%(i+1);</span><br><span class="line">    swap(ans[i],ans[ran]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现复数类complex"><a href="#实现复数类complex" class="headerlink" title="实现复数类complex"></a>实现复数类complex</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex</span><br><span class="line">&#123;</span><br><span class="line">   private:</span><br><span class="line">     double real;</span><br><span class="line">     double imag;</span><br><span class="line">   public:</span><br><span class="line">     Complex()&#123;real=0;imag=1;&#125;</span><br><span class="line">     Complex(double r,double i):real(r),imag(i)&#123;&#125;</span><br><span class="line">     Complex(const Complex &amp;tmp):real(tmp.real),imag(tmp.imag)&#123;&#125;</span><br><span class="line">     void set_real(double r);</span><br><span class="line">     void set_imag(double i);</span><br><span class="line">     void set_complex(double r,double i);</span><br><span class="line">     double get_real() const;</span><br><span class="line">     double get_imag() const;</span><br><span class="line">     Complex&amp; operator+=(const Complex &amp;tmp);</span><br><span class="line">     Complex&amp; operator+=(const double r);</span><br><span class="line">     Complex&amp; operator-=(const Complex &amp;tmp);</span><br><span class="line">     Complex&amp; operator-=(const double r);</span><br><span class="line">     Complex&amp; operator=(const Complex &amp;tmp);</span><br><span class="line">     Complex&amp; operator=(const double r);</span><br><span class="line">     bool operator==(const Complex &amp;tmp) const;</span><br><span class="line">     bool operator&gt;=(const Complex &amp;tmp) const;</span><br><span class="line">     bool operator&lt;=(const Complex &amp;tmp) const;</span><br><span class="line">     bool operator!=(const Complex &amp;tmp) const;</span><br><span class="line">     bool operator&gt;(const Complex &amp;tmp) const;</span><br><span class="line">     bool operator&lt;(const Complex &amp;tmp) const;</span><br><span class="line">     double operator!();</span><br><span class="line">     friend Complex operator+(const Complex &amp;tmp,const Complex &amp;temp);</span><br><span class="line">     friend Complex operator+(const Complex &amp;tmp,const double r);</span><br><span class="line">     friend Complex operator+(const double r,const Complex &amp;tmp);</span><br><span class="line">     friend Complex operator-(const Complex &amp;tmp,const Complex &amp;temp);</span><br><span class="line">     friend Complex operator-(const Complex &amp;tmp,const double r);</span><br><span class="line">     friend Complex operator-(const double r,const Complex &amp;tmp);</span><br><span class="line">     friend Complex operator*(const Complex &amp;tmp,const Complex &amp;temp);</span><br><span class="line">     friend Complex operator*(const Complex &amp;tmp,const double r);</span><br><span class="line">     friend Complex operator*(const double r,const Complex &amp;tmp);</span><br><span class="line">     friend Complex operator/(const Complex &amp;tmp,const Complex &amp;temp);</span><br><span class="line">     friend Complex operator/(const Complex &amp;tmp,const double r);</span><br><span class="line">     friend Complex operator/(const double r,const Complex &amp;tmp);</span><br><span class="line">     friend istream&amp; operator&gt;&gt;(istream &amp;is ,Complex &amp;tmp);</span><br><span class="line">     friend ostream&amp; operator&lt;&lt;(ostream &amp;os,const Complex &amp;tmp);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   Complex p(1,1);</span><br><span class="line">   Complex q(2,2);</span><br><span class="line">   Complex t(3,3);</span><br><span class="line">   double test;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; p+q;</span><br><span class="line">   cout &lt;&lt; p-q;</span><br><span class="line">   cout &lt;&lt; p*q ;</span><br><span class="line">   cout &lt;&lt; p/q ;</span><br><span class="line">   test=(!p);</span><br><span class="line">   cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p==q) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p!=q) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p&gt;=q) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p&gt;q) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p&lt;q) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; (p&lt;=q) &lt;&lt; endl;</span><br><span class="line">   t+=q;</span><br><span class="line">   cout &lt;&lt; t;</span><br><span class="line">   t-=p;</span><br><span class="line">   cout &lt;&lt; t;</span><br><span class="line">   cout &lt;&lt; 10+p;</span><br><span class="line">   cout &lt;&lt; p+10;</span><br><span class="line">   cout &lt;&lt; 10-p;</span><br><span class="line">   cout &lt;&lt; p-10;</span><br><span class="line">   cout &lt;&lt; 10*p;</span><br><span class="line">   cout &lt;&lt; p*10;</span><br><span class="line">   cout &lt;&lt; 10/p;</span><br><span class="line">   cout &lt;&lt; p/10;</span><br><span class="line">   cin &gt;&gt; t;</span><br><span class="line">   cout &lt;&lt; t;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Complex::set_real(double r)</span><br><span class="line">&#123;</span><br><span class="line">   real=r;</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Complex::set_imag(double i)</span><br><span class="line">&#123;</span><br><span class="line">   imag=i;</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Complex::set_complex(double r,double i)</span><br><span class="line">&#123;</span><br><span class="line">   real=r;</span><br><span class="line">   imag=i;</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double Complex::get_real() const</span><br><span class="line">&#123;</span><br><span class="line">    return(real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double Complex::get_imag() const</span><br><span class="line">&#123;</span><br><span class="line">   return(imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator+=(const Complex&amp; tmp)</span><br><span class="line">&#123;</span><br><span class="line">   real+=tmp.real;</span><br><span class="line">   imag+=tmp.imag;</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator+=(double r)</span><br><span class="line">&#123;</span><br><span class="line">   real+=r;</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator-=(const Complex&amp; tmp)</span><br><span class="line">&#123;</span><br><span class="line">   real-=tmp.real;</span><br><span class="line">   imag-=tmp.imag;</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator-=(double r)</span><br><span class="line">&#123;  </span><br><span class="line">   real-=r;</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator=(const Complex&amp; tmp)</span><br><span class="line">&#123;</span><br><span class="line">   real=tmp.real;</span><br><span class="line">   imag=tmp.imag;</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator=(double r)</span><br><span class="line">&#123;</span><br><span class="line">  real=r;</span><br><span class="line">  imag=0;</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator+(const Complex &amp;tmp,const Complex &amp;temp)</span><br><span class="line">&#123;    </span><br><span class="line">   Complex result;</span><br><span class="line">   result.real=tmp.real+temp.real;</span><br><span class="line">   result.imag=tmp.imag+temp.imag;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator+(const Complex &amp;tmp,const double r)</span><br><span class="line">&#123;       </span><br><span class="line">   Complex result;</span><br><span class="line">   result.real=tmp.real+r;</span><br><span class="line">   result.imag=tmp.imag;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator+(const double r,const Complex &amp;tmp)</span><br><span class="line">&#123;       </span><br><span class="line">   Complex result;</span><br><span class="line">   result.real=r+tmp.real;</span><br><span class="line">   result.imag=tmp.imag;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator-(const Complex &amp;tmp,const Complex &amp;temp)</span><br><span class="line">&#123;</span><br><span class="line">   Complex result;</span><br><span class="line">   result.real=tmp.real-temp.real;</span><br><span class="line">   result.imag=tmp.imag-temp.imag;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline Complex operator-(const Complex &amp;tmp,const double r)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    result.real=tmp.real-r;</span><br><span class="line">    result.imag=tmp.imag;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator-(const double r,const Complex &amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    result.real=r-tmp.real;</span><br><span class="line">    result.imag=0-tmp.imag;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator*(const Complex &amp;tmp,const Complex&amp; temp)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    result.real=temp.real*tmp.real-temp.imag*tmp.imag;</span><br><span class="line">    result.imag=temp.real*tmp.imag+temp.imag*tmp.real;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator*(const Complex &amp;tmp,const double r)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    result.real=tmp.real*r;</span><br><span class="line">    result.imag=tmp.imag*r;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator*(const double r,const Complex &amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    result.real=r*tmp.real;</span><br><span class="line">    result.imag=r*tmp.imag;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator/(const Complex &amp;tmp,const Complex &amp;temp)</span><br><span class="line">&#123;</span><br><span class="line">    Complex result;</span><br><span class="line">    if(temp.real==0&amp;&amp;temp.imag==0)</span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl;</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.real=(tmp.real*temp.real+tmp.imag*temp.imag)/(temp.real*temp.real+temp.imag*temp.imag);</span><br><span class="line">    result.imag=(tmp.imag*temp.real-tmp.real*temp.imag)/(temp.real*temp.real+temp.imag*temp.imag);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator/(const Complex &amp;tmp,const double r)</span><br><span class="line">&#123;</span><br><span class="line">   Complex result;</span><br><span class="line">   if(r==0)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl;</span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">   result.real=tmp.real/r;</span><br><span class="line">   result.imag=tmp.imag/r;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator/(const double r,const Complex &amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">   Complex result;</span><br><span class="line">   if(tmp.real==0&amp;&amp;tmp.imag==0)</span><br><span class="line">   &#123;</span><br><span class="line">     cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line">   result.real=r*tmp.real/(tmp.real*tmp.real+tmp.imag*tmp.imag);</span><br><span class="line">   result.imag=(0-r*tmp.imag)/(tmp.real*tmp.real+tmp.imag+tmp.imag);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double Complex::operator!()</span><br><span class="line">&#123;</span><br><span class="line">   return sqrt(real*real+imag*imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator==(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">   if(real==tmp.real&amp;&amp;imag==tmp.imag)</span><br><span class="line">      return true;</span><br><span class="line">   else</span><br><span class="line">      return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator!=(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">   if(*this==tmp)</span><br><span class="line">     return false;</span><br><span class="line">   else</span><br><span class="line">     return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator&gt;=(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">   if((real*real+imag*imag)&gt;=(tmp.real*tmp.real+tmp.imag*tmp.imag))</span><br><span class="line">     return true;</span><br><span class="line">   else</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator&gt;(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">   if((real*real+imag*imag)&gt;(tmp.real*tmp.real+tmp.imag*tmp.imag))</span><br><span class="line">     return true;</span><br><span class="line">   else</span><br><span class="line">     return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator&lt;=(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">  if((real*real+imag*imag)&lt;=(tmp.real*tmp.real+tmp.imag*tmp.imag))</span><br><span class="line">     return true;</span><br><span class="line">  else</span><br><span class="line">     return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Complex::operator&lt;(const Complex &amp;tmp) const</span><br><span class="line">&#123;</span><br><span class="line">  if((real*real+imag*imag)&lt;(tmp.real*tmp.real+tmp.imag*tmp.imag))</span><br><span class="line">     return true;</span><br><span class="line">  else</span><br><span class="line">     return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline ostream&amp; operator&lt;&lt;(ostream&amp; os,const Complex&amp; tmp)</span><br><span class="line">&#123;</span><br><span class="line">   os &lt;&lt; tmp.real &lt;&lt; &quot;+&quot; &lt;&lt; tmp.imag &lt;&lt; &quot;j&quot; &lt;&lt; endl;</span><br><span class="line">   return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline istream&amp; operator&gt;&gt;(istream &amp;is,Complex&amp; tmp)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;enter real:&quot;;</span><br><span class="line">   is &gt;&gt; tmp.real;</span><br><span class="line">   if(is)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;enter imag:&quot;;</span><br><span class="line">      is &gt;&gt; tmp.imag;</span><br><span class="line">      if(is)</span><br><span class="line">      &#123;</span><br><span class="line">        return is;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl;</span><br><span class="line">     	 tmp=Complex(0,1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      tmp=Complex(0,1);</span><br><span class="line">   &#125;</span><br><span class="line">   return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自己实现循环队列"><a href="#自己实现循环队列" class="headerlink" title="自己实现循环队列"></a>自己实现循环队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">循环队列成员变量：</span><br><span class="line">	1.一个数据结构保存数组，可以用vector&lt;int&gt; que</span><br><span class="line">	2.循环队列的capacity</span><br><span class="line">	3.循环队列的头指针</span><br><span class="line">	4.循环队列的尾指针</span><br><span class="line">	5.循环队列当前的元素数量</span><br><span class="line">注意：front指的是头元素，rear指的是最后一个元素的下一个位置，所以返回Rear需要返回que[(rear-1+capacity)%capacity]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class MyCircularQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    int m_count;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int m_num;</span><br><span class="line">    vector&lt;int&gt; que;</span><br><span class="line">public:</span><br><span class="line">    MyCircularQueue(int k) &#123;</span><br><span class="line">        m_count=k;</span><br><span class="line">        que=vector&lt;int&gt;(m_count,-1);</span><br><span class="line">        front=0;</span><br><span class="line">        rear=0;</span><br><span class="line">        m_num=0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool enQueue(int value) &#123;</span><br><span class="line">        if(isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        que[rear]=value;</span><br><span class="line">        rear=(rear+1)%m_count;</span><br><span class="line">        m_num++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool deQueue() &#123;</span><br><span class="line">        if(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        front=(front+1)%m_count;</span><br><span class="line">        m_num--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int Front() &#123;</span><br><span class="line">        if(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return que[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Rear() &#123;</span><br><span class="line">        if(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return que[(rear-1+m_count)%m_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isEmpty() &#123;</span><br><span class="line">        return m_num==0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isFull() &#123;</span><br><span class="line">        return m_count==m_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyCircularQueue object will be instantiated and called as such:</span><br><span class="line"> * MyCircularQueue* obj = new MyCircularQueue(k);</span><br><span class="line"> * bool param_1 = obj-&gt;enQueue(value);</span><br><span class="line"> * bool param_2 = obj-&gt;deQueue();</span><br><span class="line"> * int param_3 = obj-&gt;Front();</span><br><span class="line"> * int param_4 = obj-&gt;Rear();</span><br><span class="line"> * bool param_5 = obj-&gt;isEmpty();</span><br><span class="line"> * bool param_6 = obj-&gt;isFull();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h1 id="9-设计模式"><a href="#9-设计模式" class="headerlink" title="9.设计模式"></a>9.设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-局部静态变量实现"><a href="#1-局部静态变量实现" class="headerlink" title="1.局部静态变量实现"></a>1.局部静态变量实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class singleton</span><br><span class="line">&#123;</span><br><span class="line">    private:</span><br><span class="line">        singleton()=default;</span><br><span class="line">        singleton(const singleton&amp; sig)=delete;</span><br><span class="line">        singleton&amp; operator=(const singleton&amp; sig)=delete;</span><br><span class="line">    public:</span><br><span class="line">        ~singleton()=default;</span><br><span class="line">        static singleton&amp; getInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            static singleton sigInstance;</span><br><span class="line">            return sigInstance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    singleton&amp; sig1=singleton::getInstance();</span><br><span class="line">    cout&lt;&lt;&amp;sig1&lt;&lt;endl;</span><br><span class="line">    singleton&amp; sig2=singleton::getInstance();</span><br><span class="line">    cout&lt;&lt;&amp;sig2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//二者是同一个地址</span><br></pre></td></tr></table></figure>

<h3 id="2-双检查锁-Double-check-lock"><a href="#2-双检查锁-Double-check-lock" class="headerlink" title="2.双检查锁(Double-check-lock)"></a>2.双检查锁(Double-check-lock)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">public:</span><br><span class="line">  static Singleton* GetInstance() &#123;</span><br><span class="line">    if (instance_ == nullptr) &#123;</span><br><span class="line">      std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">      if (instance_ == nullptr) &#123;</span><br><span class="line">        instance_ = new Singleton;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance_;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Singleton() = default;</span><br><span class="line">  // 释放资源。</span><br><span class="line">  void Destroy() &#123;</span><br><span class="line">    if (instance_ != nullptr) &#123;</span><br><span class="line">      delete instance_;</span><br><span class="line">      instance_ = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void PrintAddress() const &#123;</span><br><span class="line">    std::cout &lt;&lt; this &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  Singleton() = default;</span><br><span class="line">  Singleton(const Singleton&amp;) = delete;</span><br><span class="line">  Singleton&amp; operator=(const Singleton&amp;) = delete;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  static Singleton* instance_;</span><br><span class="line">  static std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance_ = nullptr;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  Singleton* s1 = Singleton::GetInstance();</span><br><span class="line">  s1-&gt;PrintAddress();</span><br><span class="line"></span><br><span class="line">  Singleton* s2 = Singleton::GetInstance();</span><br><span class="line">  s2-&gt;PrintAddress();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><img src="https://images2017.cnblogs.com/blog/1176669/201801/1176669-20180108230030082-1100848962.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">enum CarType&#123;BENZ, BMW&#125;;</span><br><span class="line">class Car//车类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void createdCar(void) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BenzCar : public Car //奔驰车</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BenzCar()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Benz::Benz()&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void createdCar(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;BenzCar::createdCar()&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~BenzCar()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BmwCar : public Car //宝马车</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BmwCar()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Bmw::Bmw()&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void createdCar(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;BmwCar::createdCar()&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CarFactory //车厂</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Car* createSpecificCar(CarType type)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(type)</span><br><span class="line">        &#123;</span><br><span class="line">        case BENZ://生产奔驰车</span><br><span class="line">            return (new BenzCar());</span><br><span class="line">            break;</span><br><span class="line">        case BMW://生辰宝马车</span><br><span class="line">            return (new BmwCar());</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return NULL;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    CarFactory carfac;</span><br><span class="line">    Car* specificCarA = carfac.createSpecificCar(BENZ);//看到网上众多示例在new后没有delete，感觉不是特别严谨</span><br><span class="line">    Car* specificCarB = carfac.createSpecificCar(BMW);</span><br><span class="line"></span><br><span class="line">    delete specificCarA; delete specificCarB;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-应用场景"><a href="#10-应用场景" class="headerlink" title="10.应用场景"></a>10.应用场景</h1><h2 id="c11-实现消费者生产者"><a href="#c11-实现消费者生产者" class="headerlink" title="c11++实现消费者生产者"></a>c11++实现消费者生产者</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">#include&lt;condition_variable&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class p_v</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;T&gt; taskQ;</span><br><span class="line">    T task_num;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">public:</span><br><span class="line">    p_v()</span><br><span class="line">    &#123;</span><br><span class="line">        while(!taskQ.empty())</span><br><span class="line">            taskQ.pop();</span><br><span class="line">        task_num=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void producer()</span><br><span class="line">    &#123;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; ulock(mtx);</span><br><span class="line">            task_num++;</span><br><span class="line">            cout&lt;&lt;&quot;producer produces&quot;&lt;&lt;task_num&lt;&lt;endl;</span><br><span class="line">            taskQ.push(task_num);</span><br><span class="line">            ulock.unlock();</span><br><span class="line">            cv.notify_all();</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void consumer()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; ul(mtx);</span><br><span class="line">            while(taskQ.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                cv.wait(ul);</span><br><span class="line">            &#125;</span><br><span class="line">            int t=taskQ.front();</span><br><span class="line">            taskQ.pop();</span><br><span class="line">            cout&lt;&lt;&quot;consumor consumes&quot;&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">            ul.unlock();</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;std::thread&gt; threads;</span><br><span class="line">        //消费者线程</span><br><span class="line">        for(int i=0;i&lt;5;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threads.push_back( std::thread(p_v::consumer,this) );</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=5;i&lt;10;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threads.push_back( std::thread(p_v::producer,this) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(auto&amp; t:threads)</span><br><span class="line">        &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p_v&lt;int&gt; pv;</span><br><span class="line">    pv.start();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-11实现三个线程顺序打印"><a href="#c-11实现三个线程顺序打印" class="headerlink" title="c++11实现三个线程顺序打印"></a>c++11实现三个线程顺序打印</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思想：使用一个变量ready=1，2，3加上mutex和condition_variable结合顺序打印</span><br><span class="line">condition_variable.wait(mutex,pred)</span><br><span class="line">只有pred为false才会阻塞</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">#include&lt;condition_variable&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">mutex mu;</span><br><span class="line">std::condition_variable cond_var;</span><br><span class="line">int num=0;</span><br><span class="line">void func(char ch)</span><br><span class="line">&#123;</span><br><span class="line">	int n=ch-&#x27;A&#x27;;</span><br><span class="line">	for(int i=0;i&lt;10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_lock&lt;std::mutex&gt; mylock(mu);</span><br><span class="line">		cond_var.wait(mylock,[n]&#123;return n==num;&#125;);</span><br><span class="line">		cout&lt;&lt;ch;</span><br><span class="line">		num=(num+1)%3;</span><br><span class="line">		mylock.unlock();</span><br><span class="line">		cond_var.notify_all();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;thread&gt; pool;</span><br><span class="line">	pool.push_back(thread(func,&#x27;A&#x27;));</span><br><span class="line">	pool.push_back(thread(func,&#x27;B&#x27;));</span><br><span class="line">	pool.push_back(thread(func,&#x27;C&#x27;));</span><br><span class="line">	for(auto iter=pool.begin();iter!=pool.end();iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		iter-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-数组"><a href="#11-数组" class="headerlink" title="11.数组"></a>11.数组</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>二分法一定要明确定义</p>
<p>要维持<strong>循环不变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意l,r初始化的位置</span><br><span class="line">定义：[l,r]中搜寻target</span><br><span class="line">	 l=0,r=nums.size()-1</span><br><span class="line">	 则while(l&lt;=r):因为l==r时，[l,r]中还有一个元素，此时还应该搜寻</span><br><span class="line">定义:[l,r)中搜寻target</span><br><span class="line">	l=0,r=nums.size()</span><br><span class="line">	则while(l&lt;r):因为当l==r时，[l,r)中没有元素了，此时终止搜寻</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">upper_bound</span><br><span class="line"></span><br><span class="line">    int upper_bound(vector&lt;int&gt;&amp; nums,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-1;</span><br><span class="line">        int mid=0;</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">        	mid=l+(r-l)/2;</span><br><span class="line">            if(nums[mid]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[mid]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[mid]==target)</span><br><span class="line">            &#123;</span><br><span class="line">            	//找右边界，此时锁定r，左边界l右移</span><br><span class="line">            	l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //r最后位置一定是等于target最右边的或者第一个小于target的值</span><br><span class="line">        //r停在等于target或者target不存在</span><br><span class="line">        target不存在分为两种情况：</span><br><span class="line">        1.中间不存在，此时nums[r]&lt;target</span><br><span class="line">        2.整个不存在说明整个数组大于target，r越界</span><br><span class="line">        if(r&lt;0||nums[r]!=target)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">lower_bound</span><br><span class="line"></span><br><span class="line">    int lower_bound(vector&lt;int&gt;&amp; nums,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-1;</span><br><span class="line">        int mid=0;</span><br><span class="line">        //最后停[r,l]</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+(r-l)/2;</span><br><span class="line">            //r最后停在等于target位置或小于target</span><br><span class="line">            if(nums[mid]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            //l刨去小于target数字</span><br><span class="line">            //l停在第一个等于targrt的位置或者第一个大于target的位置</span><br><span class="line">            else if(nums[mid]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //r刨去右边等于target的值</span><br><span class="line">            else if(nums[mid]==target)</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[l]!=target||l==nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="求x的平方根"><a href="#求x的平方根" class="headerlink" title="求x的平方根"></a>求x的平方根</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        if(x==0||x==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        //二分法找y*y=x</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=x;</span><br><span class="line">        int ans=-1;</span><br><span class="line">        //[0,x]找y</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=l+(r-l)/2;</span><br><span class="line">            //能存在平方根</span><br><span class="line">            //每次记录&lt;=x的元素</span><br><span class="line">            if((long long)mid*mid&lt;=x)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=mid;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if((long long)mid*mid&gt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找0-n-1缺失的元素"><a href="#寻找0-n-1缺失的元素" class="headerlink" title="寻找0~n-1缺失的元素"></a>寻找0~n-1缺失的元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-1;</span><br><span class="line">        //[l,r]中找target</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=l+(r-l)/2;</span><br><span class="line">            if(nums[mid]==mid)</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[mid]&gt;mid)</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //l位于缺省值右边</span><br><span class="line">        //r位于缺省值左边</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="山峰数组最小元素"><a href="#山峰数组最小元素" class="headerlink" title="山峰数组最小元素"></a>山峰数组最小元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-1;</span><br><span class="line">        int mid=0;</span><br><span class="line">        //[l,r]搜寻最小值</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+(r-l)/2;</span><br><span class="line">            if(nums[mid]&lt;=nums[nums.size()-1])</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[r+1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找峰值元素"><a href="#寻找峰值元素" class="headerlink" title="寻找峰值元素"></a>寻找峰值元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要思想：对于nums[i]!=nums[i+1]时，nums[i]&gt;nums[i+1]说明峰值元素在i左边</span><br><span class="line">		nums[i]&lt;nums[i+1]，峰值元素在i的右边</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1628133102-ILSmsa-file_1628133103312" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==1||nums[0]&gt;nums[1])</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-2;</span><br><span class="line">        //在[l,r]种找峰值</span><br><span class="line">        //需要比较mid和mid+1，所以r再减1</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=l+(r-l)/2;</span><br><span class="line">            if(nums[mid]&gt;nums[mid+1])</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="寻找重复数字"><a href="#寻找重复数字" class="headerlink" title="寻找重复数字"></a>寻找重复数字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num:1~n n+1个位置</span><br><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1.可以修改nums，nums[i]的i下标存放i-1</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for(int i=0;i&lt;nums.size();)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]-1==i)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[i]==nums[nums[i]-1])</span><br><span class="line">            &#123;</span><br><span class="line">                return nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i],nums[nums[i]-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">2.快慢指针</span><br><span class="line">index 0 1 2 3 4</span><br><span class="line">nums  1 3 4 2 2</span><br><span class="line"></span><br><span class="line">0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2 </span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int fast=0;</span><br><span class="line">        int slow=0;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=nums[nums[fast]];</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">            if(fast==slow)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow=0;</span><br><span class="line">        while(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=nums[fast];</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="找到数组中左边全小于，右边全大于的元素-类似找枢轴"><a href="#找到数组中左边全小于，右边全大于的元素-类似找枢轴" class="headerlink" title="找到数组中左边全小于，右边全大于的元素(类似找枢轴)"></a>找到数组中左边全小于，右边全大于的元素(类似找枢轴)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; getnum(vector&lt;int&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; left_max(nums.size(),INT_MIN);</span><br><span class="line">    vector&lt;int&gt; right_min(nums.size(),INT_MAX);</span><br><span class="line">    for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left_max[i]=max(left_max[i-1],nums[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=nums.size()-2;j&gt;=0;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        right_min[j]=min(right_min[j+1],nums[j+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历，nums[i]&gt;left_max[i]&amp;&amp;nums[j]&lt;right_min[j]属于结果</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int k=0;k&lt;nums.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        if((nums[k]&gt;left_max[k])&amp;&amp;(nums[k]&lt;right_min[k]))</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; tem=&#123;2,1,8,10,9&#125;;</span><br><span class="line">    vector&lt;int&gt; ans=getnum(tem);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不含有重复元素的旋转数组：mid一刀劈肯定左右两边有一个单调</span><br><span class="line">	比较mid与l的大小来判断单调区间在哪</span><br><span class="line">	nums[mid]&gt;=nums[l]  l-mid单调</span><br><span class="line">	nums[mid]&lt;nums[l]   mid-r单调</span><br><span class="line">含有重复元素的旋转数组：mid一刀劈不一定能判断哪边区间单调</span><br><span class="line">	当nums[mid]=nums[l]=nums[r]就判断不了，这时候仅需要l++(r--)直到这个条件不满足</span><br></pre></td></tr></table></figure>

<h2 id="含重复元素的旋转数组"><a href="#含重复元素的旋转数组" class="headerlink" title="含重复元素的旋转数组"></a>含重复元素的旋转数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //如果mid上的元素==left和right则没法继续搜索，可以移动边界直到left和right不等</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=nums.size()-1;</span><br><span class="line">        while(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=l+(r-l)/2;</span><br><span class="line">            if(target==nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[mid]==nums[l]&amp;&amp;nums[mid]==nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //在左边</span><br><span class="line">            if(nums[mid]&gt;=nums[l])</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    r=mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    l=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&lt;=nums[r]&amp;&amp;target&gt;nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    l=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    r=mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>按照字典序找数组的下一个排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。此时 [j,end) 必然是降序</span><br><span class="line">在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」</span><br><span class="line">将 A[i] 与 A[k] 交换</span><br><span class="line">可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序</span><br><span class="line">如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //从右开始往左找，找到第一个峰值元素a[m]左边索引最大的元素a[l]，使得a[m]&gt;a[l]</span><br><span class="line">        //在a[l]右边找索引最大的元素a[r],使得a[r]&gt;a[l](肯定存在)</span><br><span class="line">        //交换a[r]和a[l]</span><br><span class="line">        //反转a[l+1]-最后一个元素</span><br><span class="line">        //只有一个节点</span><br><span class="line">        int n=nums.size();</span><br><span class="line">        if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //先找最右侧第一个峰值元素</span><br><span class="line">        int m=n-1;</span><br><span class="line">        int l=-1;</span><br><span class="line">        int r=n;</span><br><span class="line">        for(int i=n-1;i&gt;0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i-1]&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                m=i;</span><br><span class="line">                l=i-1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums.begin(),nums.end());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找右边索引最大的a[r]</span><br><span class="line">        for(int i=n-1;i&gt;l;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&gt;nums[l])</span><br><span class="line">            &#123;</span><br><span class="line">                r=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l],nums[r]);</span><br><span class="line">        reverse(nums.begin()+l+1,nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>遇到的坑</p>
<h2 id="bool变量取反"><a href="#bool变量取反" class="headerlink" title="bool变量取反"></a>bool变量取反</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag=true;</span><br><span class="line">flag=!flag;</span><br></pre></td></tr></table></figure>

<p>rand()和srand()、time()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time_t time(time_t* time)</span><br><span class="line">time为传入传出参数</span><br><span class="line">time(NULL):返回现在到1970.1.1日之间的秒数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srand(unsigned int seed)</span><br><span class="line">srand(time(NULL))</span><br><span class="line">rand()%(b-a+1)+a  : [a,b]</span><br></pre></td></tr></table></figure>

<h2 id="数组交换"><a href="#数组交换" class="headerlink" title="数组交换"></a>数组交换</h2><h2 id="奇数在前，偶数在后，不改变相对位置"><a href="#奇数在前，偶数在后，不改变相对位置" class="headerlink" title="奇数在前，偶数在后，不改变相对位置"></a>奇数在前，偶数在后，不改变相对位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0,i-1]为奇数，i为当前判断元素</span><br><span class="line">i为奇数，i++</span><br><span class="line">i为偶数，在[i+1,n-1]之间找第一个奇数与其交换，找到交换后i++，找不到直接退出，满足条件</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]%2)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int j=i+1;</span><br><span class="line">            while(j&lt;nums.size())</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[j]%2)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(nums[i],nums[j]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j==nums.size())</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="12-子序列-Longest-Increasing-Squence-、子串问题"><a href="#12-子序列-Longest-Increasing-Squence-、子串问题" class="headerlink" title="12.子序列(Longest Increasing Squence)、子串问题"></a>12.子序列(Longest Increasing Squence)、子串问题</h1><p>子串：子串必须连续</p>
<p>子序列:子序列可以不连续</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法：1.O(n^2)的dp</span><br><span class="line">	 2.O(nlogn)的二分贪心</span><br></pre></td></tr></table></figure>

<p>dp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //dp[i]表示以nums[i]结尾的最长子序列</span><br><span class="line">    //dp[i]=max(dp[j])+1      nums[j]&lt;nums[i]   j&lt;i</span><br><span class="line">    //nums[j]&gt;nums[i]  dp[i]=1</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(),1);</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i]&gt;nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(begin(dp),end(dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模拟发牌(贪心+二分)——同时能找出最大子序列的一组元素</p>
<p><img src="https://pic.leetcode-cn.com/1629170842-gahWzG-image.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//方法1：</span><br><span class="line">    //dp[i]表示以nums[i]结尾的最长子序列</span><br><span class="line">    //dp[i]=max(dp[j])+1      nums[j]&lt;nums[i]   j&lt;i</span><br><span class="line">    //nums[j]&gt;nums[i]  dp[i]=1</span><br><span class="line">//方法2:</span><br><span class="line">    //码牌法</span><br><span class="line">    //1.每一个牌处理</span><br><span class="line">    //2.小牌放在最左堆下面，如果没有的话新建堆</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans(nums.size(),-1);</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        int piles=1;</span><br><span class="line">        ans[0]=nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            left=0;</span><br><span class="line">            right=piles;</span><br><span class="line">            //每个元素处理</span><br><span class="line">            //[left,right)中寻找nums[i]的第一个小的</span><br><span class="line">            //lower_bound</span><br><span class="line">            while(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                int mid=left+(right-left)/2;</span><br><span class="line">                if(ans[mid]&gt;=nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(ans[mid]&lt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left==piles)</span><br><span class="line">                piles++;</span><br><span class="line">            ans[left]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return piles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char,int&gt; needs;</span><br><span class="line">        unordered_map&lt;char,int&gt; win;</span><br><span class="line">        for(int i=0;i&lt;t.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            needs[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int valid=0;</span><br><span class="line">        //滑动窗口</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=0;</span><br><span class="line">        //</span><br><span class="line">        int minsize=INT_MAX;</span><br><span class="line">        while(r&lt;=s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //扩张右边</span><br><span class="line">            if(needs.count(s[r]))</span><br><span class="line">            &#123;</span><br><span class="line">                win[s[r]]++;</span><br><span class="line">                if(win[s[r]]==needs[s[r]])</span><br><span class="line">                &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //收缩左边界</span><br><span class="line">            //当包含一个t时</span><br><span class="line">            while(valid==needs.size())</span><br><span class="line">            &#123;</span><br><span class="line">                //当左边界时win里面的</span><br><span class="line">                if(needs.count(s[l]))</span><br><span class="line">                &#123;</span><br><span class="line">                    win[s[l]]--;</span><br><span class="line">                    if(win[s[l]]==0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        win.erase(s[l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    valid--;     </span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            minsize=min(minsize,r-l+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return minsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="13-贪心算法"><a href="#13-贪心算法" class="headerlink" title="13.贪心算法"></a>13.贪心算法</h1><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路：两次遍历，初始化全为1，第一遍从前往后，后面大的+1，第二遍前面大于后面前面+1</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似双指针，顶一个k为当前能到达的最大下标，初始化为0，</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int k=0;</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(i&gt;k)</span><br><span class="line">    	&#123;</span><br><span class="line">    		return false;</span><br><span class="line">    	&#125;</span><br><span class="line">        k=max(k,nums[i]+i);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static boolean canJump(int[] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //前n-1个元素能够跳到的最远距离</span><br><span class="line">        int k = 0;</span><br><span class="line">        for (int i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">            //第i个元素能够跳到的最远距离</span><br><span class="line">            int temp = i + nums[i];</span><br><span class="line">            //更新最远距离</span><br><span class="line">            k = Math.max(k, temp);</span><br><span class="line">            //如果最远距离已经大于或等于最后一个元素的下标,则说明能跳过去,退出. 减少循环</span><br><span class="line">            if (k &gt;= nums.length - 1) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最远距离k不再改变,且没有到末尾元素</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小跳次数"><a href="#最小跳次数" class="headerlink" title="最小跳次数"></a>最小跳次数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找[start,end]间最远的一跳作为maxpos，当i==end时需要更新end=maxpos，start=end+1，count++</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int end=0;</span><br><span class="line">    //[start,end]间的最大跳作为下一个</span><br><span class="line">    int count=0;</span><br><span class="line">    int maxpos=0;</span><br><span class="line">    for(int i=0;i&lt;nums.size()-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxpos=max(maxpos,nums[i]+i);</span><br><span class="line">        if(i==end)</span><br><span class="line">        &#123;</span><br><span class="line">        end=maxpos;</span><br><span class="line">        count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=0;</span><br><span class="line">        //[start,end]间的最大跳作为下一个</span><br><span class="line">        int count=0;</span><br><span class="line"></span><br><span class="line">        while(end&lt;nums.size()-1)</span><br><span class="line">        &#123;</span><br><span class="line">            int maxpos=0;</span><br><span class="line">            for(int i=start;i&lt;=end;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                maxpos=max(maxpos,nums[i]+i);</span><br><span class="line">            &#125;</span><br><span class="line">            start=end+1;</span><br><span class="line">            end=maxpos;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者采用动态规划的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        const int n = nums.size();</span><br><span class="line">        int dp[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;  //0位置步数是0</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)  //遍历每一个点</span><br><span class="line">            for(int j = 1; j &lt;= nums[i] &amp;&amp; i + j &lt; n; ++j) //这个点能够到达的点</span><br><span class="line">                dp[i + j] = min(dp[i + j], dp[i] + 1); //尝试更新所到之点</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="覆盖花园的最少水龙头"><a href="#覆盖花园的最少水龙头" class="headerlink" title="覆盖花园的最少水龙头"></a>覆盖花园的最少水龙头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">贪心的算法：</span><br><span class="line">建立一个数组land[i]表示能覆盖到i土地的水龙头右边界最大的覆盖位置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int minTaps(int n, vector&lt;int&gt;&amp; ranges) </span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; land(n);</span><br><span class="line">	for (int i = 0; i &lt; ranges.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">	//遍历到没个i土地，看一下上面的水龙头左右边界</span><br><span class="line">		int l = max(i - ranges[i], 0);</span><br><span class="line">		int r = min(i + ranges[i], n);</span><br><span class="line">	//内循环将左右边界里的最右边界更新一下</span><br><span class="line">		for (int j = l; j &lt; r; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			land[j] = max(land[j], r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int cnt = 0;</span><br><span class="line">	int cur = 0;</span><br><span class="line">	while (cur &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (land[cur] == 0) return -1;</span><br><span class="line">		cur = land[cur];</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line"></span><br><span class="line">leetcode上一维的区间合并计算问题种类很多，但是都是一个套路，起点排序，然后通过贪心的方法，进行具体分析；</span><br><span class="line">这里先将水龙头位置信息转化为其有效工作区间信息；</span><br><span class="line">然后根据区间的左端点进行升序；</span><br><span class="line">最后枚举所有区间，通过贪心思想，获得可覆盖当前有效区间的最右区间。</span><br><span class="line">各位力扣老爷，公审英皇，传播自由花费巨大，还请各位立刻捐赠20个赞，以便我军再战。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minTaps(int n, int[] ranges) &#123;</span><br><span class="line">        // 定义一个区间数组</span><br><span class="line">        int[][] region = new int[n + 1][2];</span><br><span class="line"></span><br><span class="line">        // 将原来的水龙头位置信息转化为洒水区间信息</span><br><span class="line">        for(int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            int[] temp = new int[2];</span><br><span class="line">            temp[0] = Math.max(0, i - ranges[i]);</span><br><span class="line">            temp[1] = Math.min(n, i + ranges[i]);</span><br><span class="line">            region[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        // 以左端点为标准进行升序</span><br><span class="line">        Arrays.sort(region, (a, b) -&gt; a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);</span><br><span class="line"></span><br><span class="line">        // 初始化答案，当前可用最右位置</span><br><span class="line">        int res = 0, right = 0;</span><br><span class="line">        // 初始化当前区间</span><br><span class="line">        int cur = 0;</span><br><span class="line">        // 遍历所有区间</span><br><span class="line">        while(cur &lt; n + 1) &#123;</span><br><span class="line">            // 当前区间无法覆盖到最右的有效工作范围，那么就会存在覆盖不到的间隙</span><br><span class="line">            if(region[cur][0] &gt; right) break;</span><br><span class="line">            // 遍历可以覆盖到已经可用的最右点的下一个可用的最右边点</span><br><span class="line">            int rt = right;</span><br><span class="line">            while(cur &lt; n + 1 &amp;&amp; region[cur][0] &lt;= right) &#123;</span><br><span class="line">                rt = Math.max(rt, region[cur][1]);</span><br><span class="line">                cur ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">            right = rt;</span><br><span class="line">            // 已经遍历到整个范围</span><br><span class="line">            if(right == n) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return right == n ? res : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-位运算"><a href="#14-位运算" class="headerlink" title="14.位运算"></a>14.位运算</h1><h2 id="位运算实现a-b"><a href="#位运算实现a-b" class="headerlink" title="位运算实现a+b"></a>位运算实现a+b</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a^b是没有近位的加法</span><br><span class="line">  a 0101</span><br><span class="line">  b 0100</span><br><span class="line">a^b 0001</span><br><span class="line"></span><br><span class="line">a&amp;b&lt;&lt;1 是需要进位后位置</span><br><span class="line"></span><br><span class="line">a=a^b b=a&amp;b&lt;&lt;1 ans=a+b直到b==0</span><br></pre></td></tr></table></figure>

<h2 id="计算二进制表示的1的个数"><a href="#计算二进制表示的1的个数" class="headerlink" title="计算二进制表示的1的个数"></a>计算二进制表示的1的个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用&gt;&gt;，c++右移uint32是高位补0，有符号数高位补符号位</span><br><span class="line">或者使用性质n&amp;(n-1)可以消除末尾的0，直到n==0</span><br></pre></td></tr></table></figure>



<h1 id="15-双指针"><a href="#15-双指针" class="headerlink" title="15.双指针"></a>15.双指针</h1><p>双指针和三指针问题一定要定义好<strong>循环不变量</strong></p>
<p>比如leetcode283将0移动到数组后面，并且保证非0元素顺序一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n=nums.size();</span><br><span class="line">    int fast=0;</span><br><span class="line">    //双指针</span><br><span class="line">    //[0,slow)是已经满足题意的保持顺序的数组</span><br><span class="line">    //slow定在第一个0的位置</span><br><span class="line">    //[slow,fast)为0，fast位置不为0</span><br><span class="line">    int slow=0;</span><br><span class="line">    while(fast&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[fast]!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[slow],nums[fast]);</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-数学问题"><a href="#16-数学问题" class="headerlink" title="16.数学问题"></a>16.数学问题</h1><h2 id="阶乘后尾部的0"><a href="#阶乘后尾部的0" class="headerlink" title="阶乘后尾部的0"></a>阶乘后尾部的0</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n！结果尾数的零是如何产生的？中间结果存在10，比如2x5等。主要由2的倍数与5的倍数组成，而2的倍数比5的倍数要多，因此5的倍数数量为考量结果尾数零的数量的关键。由于某些数包含了数个5的乘积，如：25，50，75，100，...，625等。因此我们可以将输入n不断的除以5直至结果为零，并对中间的结果进行累加，则可得到结果。</span><br><span class="line">以126为例：</span><br><span class="line"></span><br><span class="line">第一次除以5时得到25，表明存在25个包含1个5的数。</span><br><span class="line">再次除以5得到5，表明存在5个包含两个5乘积的数，由于第一个5在第一轮已被计算，因此第二轮只需简单的相加。</span><br><span class="line">同理，第三次除以5得到一，存在一个包含三个5乘积的数。</span><br><span class="line">最后累加，得到126！结果尾数包含31个零的结论</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int trailingZeroes(int n) &#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(n!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=n/5;</span><br><span class="line">        n/=5;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>使用O(logn)的时间复杂度求POW(x,n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">double myPow(double x, long long n) &#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    double res=1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%2==1)</span><br><span class="line">        &#123;</span><br><span class="line">            res*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        x*=x;</span><br><span class="line">        n/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三的幂"><a href="#三的幂" class="headerlink" title="三的幂"></a>三的幂</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 9 27</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果n&gt;0并且此时n%3==0显然继续除以3</span><br><span class="line">排除0</span><br><span class="line">1是3的0次方</span><br><span class="line"></span><br><span class="line">或者使用换底公式</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">    while(n&gt;0&amp;&amp;n%3==0)</span><br><span class="line">    &#123;</span><br><span class="line">    	n=n/3;</span><br><span class="line">    &#125;</span><br><span class="line">    return n==1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    double a=log10(n)/log10(3);</span><br><span class="line">    return a==floor(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>只有加减乘除，正数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</span><br><span class="line"></span><br><span class="line">表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preSign记录之前的符号，如果是除和乘就把当前的数字和sta的数字计算后加进去；+-分别往sta中push+num或-num</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int calculate(string s) &#123;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    int i=0;</span><br><span class="line">    int n=s.size();</span><br><span class="line">    char preSign=&#x27;+&#x27;;</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int num=0;</span><br><span class="line">        if(isdigit(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            while(i&lt;n&amp;&amp;isdigit(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                num+=10*num+(s[i]-&#x27;0&#x27;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(preSign==&#x27;+&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(preSign==&#x27;-&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(-num);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(preSign==&#x27;*&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                int topval=sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                sta.push(topval*num);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(preSign==&#x27;/&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                int topval=sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                sta.push(topval/num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            preSign=s[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans;</span><br><span class="line">    while(!sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归做法"><a href="#递归做法" class="headerlink" title="递归做法"></a>递归做法</h2><p>由于是递归所以优先级低的+-先判断进入递归<br>因为同等优先级是从左往右 所以递归是从右往左开始扫<br>如果没有符号则说明这个区间里是一个数字 使用stoi返回数字即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int cal(string &amp;s, int l, int r) &#123;</span><br><span class="line">        for (int i = r; i &gt;= l; --i) &#123;</span><br><span class="line">            if (s[i] == &#x27;+&#x27;) return cal(s, l, i - 1) + cal(s, i + 1, r);</span><br><span class="line">            if (s[i] == &#x27;-&#x27;) return cal(s, l, i - 1) - cal(s, i + 1, r);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = r; i &gt;= l; --i) &#123;</span><br><span class="line">            if (s[i] == &#x27;*&#x27;) return cal(s, l, i - 1) * cal(s, i + 1, r);</span><br><span class="line">            if (s[i] == &#x27;/&#x27;) return cal(s, l, i - 1) / cal(s, i + 1, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return stoi(s.substr(l, r - l + 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        if (s.empty()) return 0;</span><br><span class="line">        return cal(s, 0, s.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="计算机通用处理方法"><a href="#计算机通用处理方法" class="headerlink" title="计算机通用处理方法"></a>计算机通用处理方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.将中缀表达式转化为后缀表达式，使用shunting-yard algorithm(调度场算法)</span><br><span class="line">2.利用括号的递归性</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(队列非空)</span><br><span class="line">    1.单个 or 连续数字：计算它的数值</span><br><span class="line">    2.左括号：让递归计算与它对应的右括号内的数    </span><br><span class="line">    3.运算符号 or 右括号</span><br><span class="line">        前一个运算符是 + ，  它前面的数可以加入res了</span><br><span class="line">        前一个运算符是 - ，  它前面的数可以加进res了，把它后面的数变成负数</span><br><span class="line">        前一个运算符是 * ，  它前面的数还不能加进res，乘到它后面的数</span><br><span class="line">        前一个运算符是 / ，  它前面的数还不能加进res，除到它后面的数</span><br><span class="line"></span><br><span class="line">        把当前运算符更新给【前一个运算符】 </span><br><span class="line">        右括号   本对括号内的数算出来了，返回res</span><br><span class="line">    </span><br><span class="line">别忘了加上本来在等待计算的【运算符前面的数】preNum</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //递归程序一定要按照自然的（目标的）顺序去写</span><br><span class="line">    //先有数 然后左括号(递归数完了用符号)</span><br><span class="line">    // 然后符号 然后右括号</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">      int i=0;</span><br><span class="line">      return helper(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(string s,int &amp;i)&#123;</span><br><span class="line">     stack&lt;int&gt; st;</span><br><span class="line">     char sign=&#x27;+&#x27;; //第一次为正，要把数字放进去</span><br><span class="line">     int num=0;    //当前的计算值</span><br><span class="line">     int pre=0;   //用于计算乘除时保存前面的值</span><br><span class="line">     for(;i&lt;s.size();i++)&#123;</span><br><span class="line">    if(isdigit(s[i]))  &#123;   //碰到数字了</span><br><span class="line">        if(s[i]==&#x27; &#x27;) s[i]=0;      </span><br><span class="line">        num=10*num+(s[i]-&#x27;0&#x27;); //当前为数字，注意是字符类型</span><br><span class="line">    &#125;</span><br><span class="line">    if(s[i]==&#x27;(&#x27;)&#123;       </span><br><span class="line">        num=helper(s,++i);//下一个数字开始递归</span><br><span class="line">        i++; //递归结束在&#x27;)&#x27; 要i++        </span><br><span class="line">      &#125;</span><br><span class="line">    if((!isdigit(s[i])&amp;&amp;(s[i]!=&#x27; &#x27;))||i==s.size()-1)&#123;  </span><br><span class="line">        //空格不算 s[i]!=&#x27; &#x27;,当s[i]==&#x27;)&#x27;时进入if因为要把num压入栈</span><br><span class="line">         switch(sign)&#123;  //上面的num算出来要push</span><br><span class="line">           case &#x27;+&#x27;: st.push(+num); break;</span><br><span class="line">           case &#x27;-&#x27;: st.push(-num); break;</span><br><span class="line">           case &#x27;*&#x27;: </span><br><span class="line">           pre=st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           st.push(pre*num);</span><br><span class="line">           break;</span><br><span class="line">           case &#x27;/&#x27;:</span><br><span class="line">           pre=st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           st.push(pre/num);</span><br><span class="line">           break;</span><br><span class="line">         &#125;</span><br><span class="line">          num=0;</span><br><span class="line">          sign=s[i];// 更新sign,为了下一次的保存与计算</span><br><span class="line">      &#125; </span><br><span class="line">    if(s[i]==&#x27;)&#x27;) break; ////统计完才能跳出循环，不可放到前面的位置 </span><br><span class="line">     &#125;</span><br><span class="line">     int result=0;   //累计当前栈的结果</span><br><span class="line">     while(!st.empty())&#123;</span><br><span class="line">        result=result+st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">    //递归程序一定要按照自然的（目标的）顺序去写</span><br><span class="line">    //先有数 然后左括号(递归数完了用符号)</span><br><span class="line">    // 然后符号 然后右括号</span><br><span class="line">    //注意是引用</span><br><span class="line">    int helper(string s,int&amp; j)</span><br><span class="line">    &#123;</span><br><span class="line">        stack&lt;int&gt; sta;</span><br><span class="line">        int n=s.size();</span><br><span class="line">        int num=0;</span><br><span class="line">        char sign=&#x27;+&#x27;;</span><br><span class="line">        while(j&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[j]==&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                num=helper(s,++j);</span><br><span class="line">            &#125;</span><br><span class="line">            if(isdigit(s[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                num=10*num+(s[j]-&#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            //&quot;)&quot;也可以进来，碰到)时进行num进栈</span><br><span class="line">            if(!isdigit(s[j])&amp;&amp;s[j]!=&#x27; &#x27;||j==n-1)</span><br><span class="line">            &#123;</span><br><span class="line">                switch(sign)</span><br><span class="line">                &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        sta.push(num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        sta.push(-num);</span><br><span class="line">                        break;</span><br><span class="line">/*                     case &#x27;*&#x27;:</span><br><span class="line">                        int tmp=sta.top();</span><br><span class="line">                        sta.pop();</span><br><span class="line">                        sta.push(num*tmp);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        int tmp1=sta.top();</span><br><span class="line">                        sta.pop();</span><br><span class="line">                        sta.push(num*tmp1);</span><br><span class="line">                        break; </span><br><span class="line">                        */</span><br><span class="line">                &#125;</span><br><span class="line">                num=0;</span><br><span class="line">                sign=s[j]; </span><br><span class="line">            &#125;</span><br><span class="line">            if(s[j]==&#x27;)&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">        while(!sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=sta.top();</span><br><span class="line">            sta.pop();  </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        int j=0;</span><br><span class="line">        return helper(s,j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>中缀转后缀+后缀相加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中缀转后缀注意事项：</span><br><span class="line">有一个符号栈stack&lt;char&gt;，一个输后缀结果的vector&lt;string&gt;</span><br><span class="line">1.碰到数字输出</span><br><span class="line">2.碰到优先级相同的运算符，直接push stack</span><br><span class="line">3.碰到优先级低于栈顶的运算符，将stack中的所有pop并输出到结果中，再将这个符号push进栈</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">后缀相加：</span><br><span class="line">新建一个stack，stack压vector中元素</span><br><span class="line">1.碰到符号从stack中pop出两个，运算后压入</span><br><span class="line">2.循环最后得到的表示结果</span><br><span class="line"></span><br><span class="line">注意string str不能直接用char初始化，使用str(n,char)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isPrior(char a,char b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a==&#x27;+&#x27;||a==&#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        return b==&#x27;*&#x27;||b==&#x27;/&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool isOperater(char a)</span><br><span class="line">&#123;</span><br><span class="line">    return a==&#x27;+&#x27;||a==&#x27;-&#x27;||a==&#x27;*&#x27;||a==&#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; getans(string s)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;char&gt; sta;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isOperater(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            if( !sta.empty() &amp;&amp; isPrior(s[i],sta.top()) )</span><br><span class="line">            &#123;</span><br><span class="line">                while(!sta.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(string(1,sta.top()));</span><br><span class="line">                    sta.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            while(sta.top()!=&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(string(1,sta.top()));</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isdigit(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            int num=0;</span><br><span class="line">            while(isdigit(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                num=10*num+(s[i]-&#x27;0&#x27;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">          ans.push_back(to_string(num)); </span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(string(1,sta.top()));</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int getnum(vector&lt;string&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    stack&lt;string&gt; sta;</span><br><span class="line">    int i=0;</span><br><span class="line">    int num=0;</span><br><span class="line">    while(i&lt;s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==&quot;+&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=0;</span><br><span class="line">            int r=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            int l=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(to_string(l+r));</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&quot;-&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=0;</span><br><span class="line">            int r=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            int l=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(to_string(l-r));</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&quot;*&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=0;</span><br><span class="line">            int r=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            int l=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(to_string(l*r));</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&quot;/&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=0;</span><br><span class="line">            int r=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            int l=stoi(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(to_string(l/r));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return stoi(sta.top());</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;10-(5+2)*2+1&quot;;</span><br><span class="line">    vector&lt;string&gt; ans=getans(s);</span><br><span class="line">    int res=getnum(ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isSign(char a)</span><br><span class="line">&#123;</span><br><span class="line">    return a==&#x27;@&#x27;||a==&#x27;x&#x27;||a==&#x27;+&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">bool isPriority(char a,char b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a==&#x27;+&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        return b==&#x27;@&#x27;||b==&#x27;x&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a==&#x27;x&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        return b==&#x27;@&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool isEqual(char a,char b)</span><br><span class="line">&#123;</span><br><span class="line">    return a==b;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; getReversePoland(string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;char&gt; sta;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    int i=0;</span><br><span class="line">    int n=s.size();</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isdigit(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            long long num=0;</span><br><span class="line">            while(i&lt;n&amp;&amp;isdigit(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                num=num*10+(s[i]-&#x27;0&#x27;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            ans.push_back(to_string(num));</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isSign(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            while(!sta.empty()&amp;&amp; ( isPriority(s[i],sta.top()) || isEqual(s[i],sta.top()) ) )</span><br><span class="line">            &#123;</span><br><span class="line">                    ans.push_back(string(1,sta.top()));</span><br><span class="line">                    sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(string(1,sta.top()));</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">long long getans(string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; input=getReversePoland(s);</span><br><span class="line">    stack&lt;long long&gt; sta;</span><br><span class="line">    for(int i=0;i&lt;input.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isSign(input[i][0]))</span><br><span class="line">        &#123;</span><br><span class="line">            long long r=sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            long long l=sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            switch(input[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                case &#x27;@&#x27;:</span><br><span class="line">                    sta.push(l|(l+r));</span><br><span class="line">                    break;</span><br><span class="line">                case &#x27;x&#x27;:</span><br><span class="line">                    sta.push(l*r);</span><br><span class="line">                    break;</span><br><span class="line">                case &#x27;+&#x27;:</span><br><span class="line">                    sta.push(l+r);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(stoll(input[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sta.top();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string input;</span><br><span class="line">    cin&gt;&gt;input;</span><br><span class="line">    cout&lt;&lt;getans(input)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="17-并查集union-find"><a href="#17-并查集union-find" class="headerlink" title="17.并查集union find"></a>17.并查集union find</h1><p>解决连接问题：找两个点是是否连接在一起，网络中节点间的连接状态</p>
<p>连接问题</p>
<p>求并集+查找集合</p>
<p><img src="C:\Users\zx\AppData\Roaming\Typora\typora-user-images\image-20210917182133508.png" alt="image-20210917182133508"></p>
<p>基于rank优化+路径压缩</p>
<p><img src="C:\Users\zx\AppData\Roaming\Typora\typora-user-images\image-20210917214811456.png" alt="image-20210917214811456"></p>
<p><img src="C:\Users\zx\AppData\Roaming\Typora\typora-user-images\image-20210917215707765.png" alt="image-20210917215707765"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class union_find</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int* parent;</span><br><span class="line">    int* rank;//sz[i]为以i为根的集合元素个数</span><br><span class="line">    int count;</span><br><span class="line">public:</span><br><span class="line">    union_find(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int count=n;</span><br><span class="line">        parent=new int[n];</span><br><span class="line">        rank=new int[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~union_find()</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] parent;</span><br><span class="line">        delete[] rank;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int p)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(p&gt;=0&amp;&amp;p&lt;=count);</span><br><span class="line">/*         while(p!=parent[p])</span><br><span class="line">        &#123;</span><br><span class="line">            parent[p]=parent[parent[p]];</span><br><span class="line">            p=parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[p]; */</span><br><span class="line">        if(p!=parent[p])</span><br><span class="line">        &#123;</span><br><span class="line">            parent[p]=find(parent[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    bool isConnect(int p,int q)</span><br><span class="line">    &#123;</span><br><span class="line">        return find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    void unionEle(int p,int q)</span><br><span class="line">    &#123;</span><br><span class="line">        int pRoot=find(p);</span><br><span class="line">        int qRoot=find(q);</span><br><span class="line">        if(qRoot==pRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(rank[pRoot]&lt;rank[qRoot])</span><br><span class="line">        &#123;</span><br><span class="line">            parent[pRoot]=qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(rank[pRoot]&gt;rank[qRoot])</span><br><span class="line">        &#123;</span><br><span class="line">            parent[qRoot]=pRoot;           </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            parent[pRoot]=qRoot;</span><br><span class="line">            rank[qRoot]+=1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-拓扑排序"><a href="#18-拓扑排序" class="headerlink" title="18.拓扑排序"></a>18.拓扑排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基于bfs的kahn算法</span><br><span class="line">1.初始化邻接矩阵和入度矩阵</span><br><span class="line">2.使用queue维护入度为0的队列，找入口</span><br><span class="line">3.BFS拓扑排序：从queue中BFS，终点入度减少，入度为0加入queue，直到queue为空</span><br></pre></td></tr></table></figure>

<p>思路：基于有向无环图，维护一个入度为0的队列，每次找出入度为0的节点取出来，同时该节点指向的节点的入度要–，减为0时，将该节点入队，直到que为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    int n=prerequisites.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; adj(numCourses);</span><br><span class="line">    vector&lt;int&gt; indegree(numCourses);</span><br><span class="line">    //初始化了邻接表和入度表</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        adj[prerequisites[i].back()].emplace_back(prerequisites[i].front());</span><br><span class="line">        indegree[prerequisites[i].front()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    //找入口</span><br><span class="line">    for(int i=0;i&lt;numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(indegree[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    //BFS拓扑排序</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int front=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        count++;</span><br><span class="line">        for(int j=0;j&lt;adj[front].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[adj[front][j]]--;</span><br><span class="line">            if(indegree[adj[front][j]]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(adj[front][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return count==numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-前缀树-trie树"><a href="#19-前缀树-trie树" class="headerlink" title="19.前缀树(trie树)"></a>19.前缀树(trie树)</h1><p>![](D:\OneDrive - 东南大学\面试准备\算法\image\prefixTree.png)</p>
<p>![Trie_use](D:\OneDrive - 东南大学\面试准备\算法\image\Trie_use.png)</p>
<p>Trie树实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode&#123;</span><br><span class="line">public:</span><br><span class="line">    char val;</span><br><span class="line">    bool isEnd;</span><br><span class="line">    TrieNode* children[26];</span><br><span class="line">public:</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            children[i]=nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode(char tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        val=tmp;</span><br><span class="line">        isEnd=false;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            children[i]=nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode(char tmp,bool end)</span><br><span class="line">    &#123;</span><br><span class="line">        val=tmp;</span><br><span class="line">        isEnd=end;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            children[i]=nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class Trie &#123;</span><br><span class="line">private:</span><br><span class="line">        TrieNode* root;</span><br><span class="line">public:</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        for(auto c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node-&gt;children[c-&#x27;a&#x27;]==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;children[c-&#x27;a&#x27;]=new TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            node=node-&gt;children[c-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd=true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        for(auto c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node-&gt;children[c-&#x27;a&#x27;]==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node-&gt;children[c-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        return node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        for(auto c:prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node-&gt;children[c-&#x27;a&#x27;]==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node-&gt;children[c-&#x27;a&#x27;];</span><br><span class="line">        &#125;   </span><br><span class="line">        return true;     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie* obj = new Trie();</span><br><span class="line"> * obj-&gt;insert(word);</span><br><span class="line"> * bool param_2 = obj-&gt;search(word);</span><br><span class="line"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zengxiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zengxiang21.github.io/2021/11/16/%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95/">https://zengxiang21.github.io/2021/11/16/%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zengxiang21.github.io" target="_blank">zx的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/id/85/1280/774" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/16/%E9%85%8D%E7%BD%AEcode-server/"><img class="prev-cover" src="https://picsum.photos/id/859/1919/1919" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">配置code-server</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/16/hello-world/"><img class="next-cover" src="https://picsum.photos/id/946/6578/4699 https://picsum.photos/id/329/5472/3648 https://picsum.photos/id/85/1280/774" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zengxiang</div><div class="author-info__description">zx的博客,欢迎访问</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zengxiang21" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">1.排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">稳定的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97-%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92"><span class="toc-number">1.7.</span> <span class="toc-text">荷兰国旗(三路快排)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%89%8Dk%E5%A4%A7%E7%9A%84%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">求前k大的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.11.</span> <span class="toc-text">求第k大的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy%E5%92%8Cstrncpy"><span class="toc-number">1.12.</span> <span class="toc-text">strcpy和strncpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strncpy"><span class="toc-number">1.13.</span> <span class="toc-text">strncpy:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memcpy%E5%92%8Cmemmove"><span class="toc-number">1.14.</span> <span class="toc-text">memcpy和memmove</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcmp"><span class="toc-number">1.15.</span> <span class="toc-text">strcmp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strstr"><span class="toc-number">1.16.</span> <span class="toc-text">strstr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">2.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">2.2.</span> <span class="toc-text">判断链表是否相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">找链表的中点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">链表交点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%8E%AF%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">链表环的交点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">合并升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%BF%9D%E7%95%99%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">删除升序链表重复节点（一个不保留）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%8C%87%E9%92%88%E6%B3%95-pre-cur"><span class="toc-number">2.8.</span> <span class="toc-text">两指针法 pre cur</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%EF%BC%88%E4%BF%9D%E7%95%99%E4%B8%80%E4%B8%AA%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">删除链表重复节点（保留一个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%8C%87%E9%92%88%E6%B3%95-ppre-pre-cur"><span class="toc-number">2.10.</span> <span class="toc-text">三指针法 ppre pre cur</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.11.</span> <span class="toc-text">链表相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.12.</span> <span class="toc-text">交换相邻两个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.13.</span> <span class="toc-text">链表插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.14.</span> <span class="toc-text">链表冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">3.树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">迭代遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">根据先序和中序遍历构建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">是否为子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E6%89%93%E5%8D%B0-%E8%A6%81%E7%94%A8%E9%98%9F%E5%88%97%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%B7%9F%E8%BF%AD%E4%BB%A3%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86stack%E6%90%9E%E6%B7%B7%E4%BA%86"><span class="toc-number">3.4.</span> <span class="toc-text">层次打印(要用队列，不要跟迭代中序遍历stack搞混了)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%B8%8B%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%85%83%E7%B4%A0-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">最下层最左边的元素(层序遍历的方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">判断是否是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">3.7.</span> <span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.8.</span> <span class="toc-text">判断出栈顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEvec%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.9.</span> <span class="toc-text">根据vec判断是否是后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">3.10.</span> <span class="toc-text">二叉搜索树删除节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.11.</span> <span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">路径之和（自顶向下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">3.13.</span> <span class="toc-text">最大路径和(自底向上)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E4%B8%8D%E4%B8%80%E5%AE%9A%E8%BF%87%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="toc-number">3.14.</span> <span class="toc-text">最大路径和不一定过根节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%92%8C%E8%B7%AF%E5%BE%84-%E5%8F%8C%E5%B1%82dfs"><span class="toc-number">3.15.</span> <span class="toc-text">求和路径(双层dfs)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9B%9E%E6%BA%AF"><span class="toc-number">4.</span> <span class="toc-text">4.回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DFS"><span class="toc-number">4.1.</span> <span class="toc-text">(1)DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">4.1.1.</span> <span class="toc-text">括号生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B9%8B%E5%92%8C"><span class="toc-number">4.1.2.</span> <span class="toc-text">组合之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9Fip"><span class="toc-number">4.1.3.</span> <span class="toc-text">复原ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">4.1.4.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%B9%B3%E9%9D%A2%E5%9B%9E%E6%BA%AF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.5.</span> <span class="toc-text">二维平面回溯注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">4.1.6.</span> <span class="toc-text">单词搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">4.1.7.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floodfill%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.8.</span> <span class="toc-text">floodfill算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">4.1.9.</span> <span class="toc-text">岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5"><span class="toc-number">4.1.10.</span> <span class="toc-text">黄金矿工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%B2%89%E5%B2%9B%E7%9A%84%E6%96%B9%E6%B3%95-isvisited%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.11.</span> <span class="toc-text">非沉岛的方法(isvisited数组方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%88%90k%E4%B8%AA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number">4.1.12.</span> <span class="toc-text">分成k个和相等的子集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BFS"><span class="toc-number">4.2.</span> <span class="toc-text">(2)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.1.</span> <span class="toc-text">单向BFS模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">4.2.2.</span> <span class="toc-text">单词接龙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E9%94%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">密码锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F-%E6%9C%8B%E5%8F%8B%E5%9C%88"><span class="toc-number">4.2.4.</span> <span class="toc-text">省份数量+朋友圈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.</span> <span class="toc-text">5.动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">子序列问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS-%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">5.2.</span> <span class="toc-text">最长公共子序列（LCS)+最多的不相交的线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">5.3.</span> <span class="toc-text">最大子序列和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">5.4.</span> <span class="toc-text">输出最大子数组和的每个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="toc-number">5.5.</span> <span class="toc-text">字符串最长公共子数组并输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E4%B8%B2%E6%95%B0%E9%87%8F"><span class="toc-number">5.6.</span> <span class="toc-text">回文串数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">5.7.</span> <span class="toc-text">最大正方形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E5%B9%B6%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84"><span class="toc-number">5.8.</span> <span class="toc-text">最小路径和并输出最小路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">5.9.</span> <span class="toc-text">三角形最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.10.</span> <span class="toc-text">解码方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.11.</span> <span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.12.</span> <span class="toc-text">编辑距离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">6.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0atoi"><span class="toc-number">6.1.</span> <span class="toc-text">实现atoi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0string%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">实现string类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">6.3.</span> <span class="toc-text">字符串匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.4.</span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%8B%9F%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">6.5.</span> <span class="toc-text">字符串模拟大数相乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97%E6%89%BE%E6%9C%80%E5%A4%A7"><span class="toc-number">6.6.</span> <span class="toc-text">字符串排列找最大</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">7.智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text">shared_ptr实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">unique_ptr实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">8.大厂常考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU"><span class="toc-number">8.1.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">异或运算性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1"><span class="toc-number">8.2.2.</span> <span class="toc-text">一个只出现一次，其他出现两次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1"><span class="toc-number">8.2.3.</span> <span class="toc-text">一个只出现一次，其他出现三次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1"><span class="toc-number">8.2.4.</span> <span class="toc-text">两个只出现一次，其他出现两次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BD%99%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1"><span class="toc-number">8.2.5.</span> <span class="toc-text">三个只出现一次，其余出现两次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.6.</span> <span class="toc-text">常用位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rand8%E5%AE%9E%E7%8E%B0Rand12"><span class="toc-number">8.2.7.</span> <span class="toc-text">Rand8实现Rand12</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.2.8.</span> <span class="toc-text">单调栈模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84"><span class="toc-number">8.2.9.</span> <span class="toc-text">技巧循环数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">8.2.10.</span> <span class="toc-text">接雨水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E9%98%B5"><span class="toc-number">8.2.11.</span> <span class="toc-text">柱状图中最大矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">8.2.12.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">8.2.13.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84a-b-c-0"><span class="toc-number">8.2.14.</span> <span class="toc-text">求不重复的a+b+c&#x3D;0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">8.2.15.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AE%9A%E4%B9%89%E4%B8%8B%E7%9A%84prefix"><span class="toc-number">8.2.16.</span> <span class="toc-text">不同定义下的prefix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-shuffle"><span class="toc-number">8.2.17.</span> <span class="toc-text">洗牌算法(shuffle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%95%B0%E7%B1%BBcomplex"><span class="toc-number">8.2.18.</span> <span class="toc-text">实现复数类complex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">8.2.19.</span> <span class="toc-text">自己实现循环队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">9.设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.局部静态变量实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E6%A3%80%E6%9F%A5%E9%94%81-Double-check-lock"><span class="toc-number">9.1.2.</span> <span class="toc-text">2.双检查锁(Double-check-lock)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">简单工厂模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.</span> <span class="toc-text">10.应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c11-%E5%AE%9E%E7%8E%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">10.1.</span> <span class="toc-text">c11++实现消费者生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11%E5%AE%9E%E7%8E%B0%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="toc-number">10.2.</span> <span class="toc-text">c++11实现三个线程顺序打印</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">11.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">11.2.</span> <span class="toc-text">求x的平方根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE0-n-1%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">11.3.</span> <span class="toc-text">寻找0~n-1缺失的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">11.4.</span> <span class="toc-text">山峰数组最小元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%E5%85%83%E7%B4%A0"><span class="toc-number">11.5.</span> <span class="toc-text">寻找峰值元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="toc-number">11.6.</span> <span class="toc-text">寻找重复数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B7%A6%E8%BE%B9%E5%85%A8%E5%B0%8F%E4%BA%8E%EF%BC%8C%E5%8F%B3%E8%BE%B9%E5%85%A8%E5%A4%A7%E4%BA%8E%E7%9A%84%E5%85%83%E7%B4%A0-%E7%B1%BB%E4%BC%BC%E6%89%BE%E6%9E%A2%E8%BD%B4"><span class="toc-number">11.7.</span> <span class="toc-text">找到数组中左边全小于，右边全大于的元素(类似找枢轴)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">11.8.</span> <span class="toc-text">旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">11.9.</span> <span class="toc-text">含重复元素的旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">11.10.</span> <span class="toc-text">下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bool%E5%8F%98%E9%87%8F%E5%8F%96%E5%8F%8D"><span class="toc-number">11.11.</span> <span class="toc-text">bool变量取反</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">11.12.</span> <span class="toc-text">数组交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E5%9C%A8%E5%89%8D%EF%BC%8C%E5%81%B6%E6%95%B0%E5%9C%A8%E5%90%8E%EF%BC%8C%E4%B8%8D%E6%94%B9%E5%8F%98%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.13.</span> <span class="toc-text">奇数在前，偶数在后，不改变相对位置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%AD%90%E5%BA%8F%E5%88%97-Longest-Increasing-Squence-%E3%80%81%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">12.子序列(Longest Increasing Squence)、子串问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">12.1.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">12.2.</span> <span class="toc-text">最小覆盖子串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">13.贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">13.1.</span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">13.2.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%B3%E6%AC%A1%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">最小跳次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4"><span class="toc-number">13.4.</span> <span class="toc-text">覆盖花园的最少水龙头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">14.</span> <span class="toc-text">14.位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0a-b"><span class="toc-number">14.1.</span> <span class="toc-text">位运算实现a+b</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E7%9A%841%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">计算二进制表示的1的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">15.</span> <span class="toc-text">15.双指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">16.数学问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%E5%90%8E%E5%B0%BE%E9%83%A8%E7%9A%840"><span class="toc-number">16.1.</span> <span class="toc-text">阶乘后尾部的0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">16.2.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%9A%84%E5%B9%82"><span class="toc-number">16.3.</span> <span class="toc-text">三的幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">16.4.</span> <span class="toc-text">计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%81%9A%E6%B3%95"><span class="toc-number">16.5.</span> <span class="toc-text">递归做法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">16.6.</span> <span class="toc-text">计算机通用处理方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E5%B9%B6%E6%9F%A5%E9%9B%86union-find"><span class="toc-number">17.</span> <span class="toc-text">17.并查集union find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">18.</span> <span class="toc-text">18.拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E5%89%8D%E7%BC%80%E6%A0%91-trie%E6%A0%91"><span class="toc-number">19.</span> <span class="toc-text">19.前缀树(trie树)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/24/objective-c/" title="Objective-C"><img src="https://picsum.photos/id/701/1858/1393" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Objective-C"/></a><div class="content"><a class="title" href="/2022/03/24/objective-c/" title="Objective-C">Objective-C</a><time datetime="2022-03-24T08:11:43.297Z" title="发表于 2022-03-24 16:11:43">2022-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/vue/" title="Vue"><img src="https://picsum.photos/id/306/1024/768" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/2022/01/12/vue/" title="Vue">Vue</a><time datetime="2022-01-12T11:55:24.457Z" title="发表于 2022-01-12 19:55:24">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/node/" title="Nodejs"><img src="https://picsum.photos/id/369/4692/3128" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nodejs"/></a><div class="content"><a class="title" href="/2022/01/11/node/" title="Nodejs">Nodejs</a><time datetime="2022-01-11T12:42:19.228Z" title="发表于 2022-01-11 20:42:19">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/12/Ajax/" title="Ajax"><img src="https://picsum.photos/id/144/4912/2760" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ajax"/></a><div class="content"><a class="title" href="/2021/12/12/Ajax/" title="Ajax">Ajax</a><time datetime="2021-12-12T02:18:29.742Z" title="发表于 2021-12-12 10:18:29">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/jQuery/" title="jQuery"><img src="https://picsum.photos/id/908/1920/1280" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery"/></a><div class="content"><a class="title" href="/2021/12/03/jQuery/" title="jQuery">jQuery</a><time datetime="2021-12-03T02:28:02.101Z" title="发表于 2021-12-03 10:28:02">2021-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zengxiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>