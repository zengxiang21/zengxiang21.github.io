<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Objective-C | zx的博客</title><meta name="keywords" content="博客,zx"><meta name="author" content="zengxiang"><meta name="copyright" content="zengxiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="objective-C概述介绍•Objective-C简称Obj-C或者OC •C: C语言. •Objective:面向对象的 •Objective-C: 面向对象的C语言. –所以,OC的本质还是C语言. –OC是在C的基础之上增加了一小部分的面向对象的语法.将C语言复杂的、繁琐的语法封装的更为简单. –完全兼容C语言.也就是说在OC语言中可以写任意的C语言的代码. 历史•20世纪80年代初期">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C">
<meta property="og:url" content="https://zengxiang21.github.io/2022/03/24/objective-c/index.html">
<meta property="og:site_name" content="zx的博客">
<meta property="og:description" content="objective-C概述介绍•Objective-C简称Obj-C或者OC •C: C语言. •Objective:面向对象的 •Objective-C: 面向对象的C语言. –所以,OC的本质还是C语言. –OC是在C的基础之上增加了一小部分的面向对象的语法.将C语言复杂的、繁琐的语法封装的更为简单. –完全兼容C语言.也就是说在OC语言中可以写任意的C语言的代码. 历史•20世纪80年代初期">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsum.photos/id/701/1858/1393">
<meta property="article:published_time" content="2022-03-24T08:11:43.297Z">
<meta property="article:modified_time" content="2022-04-28T13:50:36.059Z">
<meta property="article:author" content="zengxiang">
<meta property="article:tag" content="博客,zx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picsum.photos/id/701/1858/1393"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zengxiang21.github.io/2022/03/24/objective-c/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Objective-C',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-28 21:50:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="zx的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 音视频</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picsum.photos/id/701/1858/1393')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zx的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 音视频</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Objective-C</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-24T08:11:43.297Z" title="发表于 2022-03-24 16:11:43">2022-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-28T13:50:36.059Z" title="更新于 2022-04-28 21:50:36">2022-04-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Objective-C"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="objective-C概述"><a href="#objective-C概述" class="headerlink" title="objective-C概述"></a>objective-C概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>•Objective-C简称Obj-C或者OC</p>
<p>•C: C语言.</p>
<p>•Objective:面向对象的</p>
<p>•Objective-C: 面向对象的C语言.</p>
<p>–所以,OC的本质还是C语言.</p>
<p>–OC是在C的基础之上增加了一小部分的面向对象的语法.将C语言复杂的、繁琐的语法封装的更为简单.</p>
<p>–完全兼容C语言.也就是说在OC语言中可以写任意的C语言的代码.</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>•20世纪80年代初期,Brad Cox结合C语言和Smalltalk的优势设计出了Objective-C语言.</p>
<p>•1985年,乔布斯创建NeXT公司,致力于设计经济实惠且功能强大的工作站,并选择Unix作为其工作站的操作系统.</p>
<p>•后来,NeXT公司设计出了NextStep – 使用OC语言编写的一套功能强大的界面工具包.</p>
<p>•1995年,NeXT公司获得OC的全部商业版权.</p>
<p>•1996年,苹果公司收购NeXT.NextStep得到了Mac开发人员的广泛认可.NextStep更名为Cocoa,从此OC成为开发Mac平台的主力语言.</p>
<p>•随着iPhone、iPad的火爆.OC又成为了iOS平台上的中流砥柱.</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>•苹果在2014年的WWDC大会上正式推出Swift,在2015年的WWDC上宣布年底发布的Swift2.0将开源.Swift语言的优点:快速、现代、安全、互动且全面优于Objective-C语言.</p>
<p>•按照苹果的行事风格,Swift一定会取代OC成为iOS开发的主力语言.但是目前来看,要实现这一目标,还有一段路需要走.</p>
<p>–原因之一很多的企业在此之前他们已经使用Objective-C语言开发好了自己的程序.使用Swift重写是不可能的.</p>
<p>–原因之二是Swift刚刚发布,还有很多Bug没有完善,企业不愿意在小白鼠.</p>
<p>–原因之三在于Swift本身还没有成型.在后期发布的版本中有大量的变化甚至包括语法的变化.</p>
<p>•所以,Swift要想取代OC,个人分析至少需要2-3年.</p>
<p>•OC的光芒注定要被Swift的闪耀遮盖.</p>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204161505669.png" alt="image-20220324201213460"></p>
<h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="oc基础"><a href="#oc基础" class="headerlink" title="oc基础"></a>oc基础</h1><p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202203281733160.png" alt="image-20220328171229838"></p>
<p>•后缀名</p>
<p>–C程序的源文件的后缀名为.c</p>
<p>–OC程序的源文件的后缀名为.m</p>
<p>•m 代表message 代表OC中最重要的机制:消息机制.</p>
<p>•OC是完全兼容C语言的.</p>
<p>–在.m文件中可以写任意的C代码.</p>
<p>–.m文件中可以写OC代码、C代码、C++代码.</p>
<h3 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h3><ol>
<li>以#开头，预处理指令</li>
<li>作用：#include的增强版，将文件内容在预编译时候拷贝进写指令的地方</li>
<li>增强：同一个文件无论#inport多少次，只会包含一次(#include需要条件编译)</li>
</ol>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>•框架: 1个提供了功能类似的类和函数的集合.</p>
<p>–通俗的解释: 苹果或者第三方事先将一些牛X的功能写好.把这些功能模块封装在1个1个的类或者函数之中.供我们直接使用.这些类和函数的集合就叫做框架. 一个框架中提供的功能都是类似的.</p>
<p>–有点像C语言的函数库</p>
<p>–框架有很多: Foundation、AVFoundation、UIKit……</p>
<p>•Foundation框架</p>
<p>–提供了OC最基础的功能,数据类型的支持以及输入输出……</p>
<p>–其他的框架都是基于Foundation框架的</p>
<p>–Foundation.h 头文件引入了Foundation框架中的所有的头文件.</p>
<h3 id="NSlog"><a href="#NSlog" class="headerlink" title="NSlog"></a>NSlog</h3><p>•这是定义在Foundation框架中的函数.</p>
<p>•作用: 是printf函数的增强版.向控制台屏幕输出信息.</p>
<p>•语法: <strong>NSLog</strong><strong>(@”<strong><strong>格式控制字符串</strong></strong>”,<strong><strong>变量列表</strong></strong>);</strong></p>
<p>•增强的地方:</p>
<p>–自动换行,不需要手动加‘\n’在输出完信息后会自动换行.</p>
<p>–在输出信息的同时,还会输出其他的信息</p>
<p>•显示执行这句代码的时间.</p>
<p>•显示这句代码是由那1个程序来执行的.</p>
<p>•程序运行的时候,进程的ID PID</p>
<p>•线程ID</p>
<p>•最后面才是要输出的信息.</p>
<p>•NSLog函数支持使用格式控制符,来输出变量的值.格式控制符支持C语言的printf函数的格式控制符.并且用法也一致.</p>
<p>•特别注意</p>
<p>–NSLog函数的第1个参数,格式控制字符串的前面要加1个@符号.</p>
<p>–NSLog函数默认情况会在输出完信息后自动换行.如果我们手动的加了上’\n’换行符则自动换行失效.</p>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding&gt;</span><br></pre></td></tr></table></figure>

<p>•C语言的字符串存储方式</p>
<p>–使用字符数组存储</p>
<p>–使用字符指针将字符串常量存储在数据段.</p>
<p>•OC中专门设计1个新的类型来保存字符串.无需关心其内部是如何实现的.</p>
<p>–NSString类型的指针变量.用来保存字符串的地址.</p>
<p>​    NSString *str=@”zx”</p>
<p>–OC中的字符串常量必须加1个前缀@符号.   @“jack”</p>
<p>–OC字符串常量与C字符串常量的区分</p>
<p>–NSString指针只能保存OC字符串地址,不能保存C字符串地址.</p>
<p>–使用%@输出OC字符串，%p为指针地址，%@为指针指向的值</p>
<p>–NSLog函数的第1个参数是NSString所以只能给1个OC字符串.</p>
<h4 id="c语言中字符指针和其他指针的区别"><a href="#c语言中字符指针和其他指针的区别" class="headerlink" title="c语言中字符指针和其他指针的区别"></a>c语言中字符指针和其他指针的区别</h4><p>其实呀，对于  char *p=”afjfkjkladfsjije”;  这句话中的指针着实很奇怪。</p>
<p>   当你  cout&lt;&lt;*p&lt;&lt;endl;  的时候，它输出的是那个字符串的首个字符——‘a’。</p>
<p>　　当你  cout&lt;&lt;p&lt;&lt;endl;   的时候，它输出的是整个字符串的内容——“”afjfkjkladfsjije””。</p>
<p>感觉到奇怪了吧，为什么这句话是输出整个字符串的内容，而不是地址呢。那么，我告诉你：没有为什么！</p>
<p>然而，经过高人指点了一下，发现是有原因的，什么原因呢？我也不太清楚，等明白了再告诉大家吧！下面补充上输出字符串指针地址的代码。</p>
<p>　　下面我就给出一段代码来验证我的说法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(p[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">h</span><br><span class="line">0x7ffeb4aaf7d8</span><br></pre></td></tr></table></figure>

<h3 id="NS前缀"><a href="#NS前缀" class="headerlink" title="NS前缀"></a>NS前缀</h3><p>•NextStep -&gt; Cocoa 实际上是NeXT公司开发的.</p>
<p>•为了区分这些东西的前身是NeXT,就使用1个前缀NS</p>
<h3 id="符号"><a href="#符号" class="headerlink" title="@符号"></a>@符号</h3><p>•将C语言的字符串转换为OC字符串</p>
<p>“jack”-&gt;@”jack”</p>
<p>•OC中新增的关键字绝大部分以@符号开头</p>
<p>@autoreleasepool</p>
<h3 id="类的定义实现"><a href="#类的定义实现" class="headerlink" title="类的定义实现"></a>类的定义实现</h3><p>声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名:NSObject&#123; </span><br><span class="line">// 类变量声明</span><br><span class="line">&#125;</span><br><span class="line">// 类属性声明</span><br><span class="line">// 类方法和声明</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation 类名</span><br><span class="line">// 类方法定义</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">类名-&gt;属性名</span><br><span class="line">*类名.属性名</span><br></pre></td></tr></table></figure>

<p>oc适用对象分为两个步骤：</p>
<p>1.Allocation(内存分配)   :为新的对象动态分配一段内存地址 </p>
<p>2.Initialization(初始化):为这段内存空间中填上合适的初始值</p>
<p> 只有这两个步骤都完成后,这个对象才能够真正的开始行使功能</p>
<p>创建对象的基本步骤</p>
<p>两个步骤在代码中是分别完成的 但是通常我们将它们合起来一次完成:</p>
<p>classname* anObject = [[Rectangle alloc] init];</p>
<p>将创建对象的两个步骤分开使得我们可以对这两步过 程分别进行控制内存分配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名 *对象名 = [类名 new];</span><br><span class="line">A *a = [A new];</span><br><span class="line">A *a = [[A alloc] init];</span><br></pre></td></tr></table></figure>

<p>概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。</p>
<p>差别在于，采用new的方式只能采用默认的init方法完成初始化，</p>
<p>采用alloc的方式可以用其他定制的初始化方法。</p>
<p>1、分配内存空间</p>
<p>a、使用alloc方法在堆区分配Person类的内存空间，存储创建的对象。</p>
<p>b、分配的内存空间的数据会被自动清空，即所有的实例变量的初始值为0。</p>
<p>c、返回分配的内存空间的地址。指针接收地址。</p>
<p>[Person alloc]在堆区创建对象，定义指针p1存储对象在堆区的内存空间地址。</p>
<p>Person * p1 = [Person alloc];</p>
<p>注：</p>
<p>OC中使用[ ]调用方法，方法和调用的对象层级对应。</p>
<p>如：[类类方法] [对象实例方法]</p>
<p>类中属性默认protected</p>
<p>加@public</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (return_type) method_name:( argumentType1 )argumentName1 </span><br><span class="line">joiningArgument2:( argumentType2 )argumentName2 ... </span><br><span class="line">joiningArgumentn:( argumentTypen )argumentNamen &#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><ul>
<li>对象方法以-开头，如 -(void)xx；</li>
<li>对象方法只能由对象来调用；</li>
<li>对象方法中可以访问当前对象的成员变量；</li>
<li>调用格式 [对象名 对象方法名]。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204151447617.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明没有返回值的方法</span><br><span class="line">- (void)method;</span><br><span class="line">//声明有返回值的方法</span><br><span class="line">- (int)method;</span><br><span class="line">//声明有返回值有参数的方法</span><br><span class="line">- (int)method: (int)var;</span><br><span class="line">//声明有返回值有多个参数的方法</span><br><span class="line">- (int)method: (int)var1 andVar2: (int)var2;</span><br></pre></td></tr></table></figure>

<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p><a target="_blank" rel="noopener" href="http://lib.csdn.net/base/objective-c">Objective-C</a>里面既有实例方法也类方法。类方法(Class Method) 有时被称为工厂方法(Factory Method)或者方便方法(Convenience  method)。工厂方法的称谓明显和一般意义上的工厂方法不同，从本质上来说，类方法可以独立于对象而执行，所以在其他的语言里面类方法有的时候被称为静态方法。</p>
<p>以+开头的方法是类方法。</p>
<p>它是属于类本身的方法，不属于类的某一个实例对象，不需要实例化类，用类名即可使用，通过类方法将消息发送给类。</p>
<ul>
<li><p>类方法以+开头，如+(void)put；</p>
</li>
<li><p>类方法只能由类来调用；</p>
</li>
<li><p>类方法中不能直接访问实例(成员)变量，因为类方法由类来调用，并没有创建存储空间来存储类中的成员变量。</p>
</li>
<li><p>注意点一：类方法<br> 1，类方法可以调用类方法。<br> 2，类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。<br> 3，类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<br> 4，类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</p>
</li>
<li><p>注意点二：self的规则(相当于this指针)</p>
<p>self：自己的；和Java、C#中的this关键字有些类似<br> 可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，在类方法中self指向当前对象，在类方法中self指向当前类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在对象方法利用&quot;self-&gt;成员变量名&quot;访问当前对象内部的成员变量</span><br><span class="line">[self 方法名]可以调用其他对象方法\类方法</span><br></pre></td></tr></table></figure>

<p>大家需要记住下面的规则：</p>
<p> （1）谁调用了当前方法，self就代表谁</p>
<p> * self出现在对象方法中，self就代表对象</p>
<p> * self出现在类方法中，self就代表类</p>
<p> 1，实例方法里面的self，是对象的首地址。<br> 2，类方法里面的self，是Class.<br> 尽管在同一个类里面的使用self，但是self却有着不同的解读。在类方法里面的self，可以翻译成class  self；在实例方法里面的self，应该被翻译成为object  self。在类方法里面的self和实例方法里面的self有着本质上的不同，尽管他们的名字都叫self。</p>
<p> 类方法创造的对象要不要用release释放？<br> 答 不需要 这个对象被放到自动释放池中</p>
<p> Object-C中的私有方法和私有成员变量</p>
<p> 成员变量默认对内是共有的，对外是私有的</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明没有返回值的类方法</span></span><br><span class="line">+ (<span class="keyword">void</span>)method;</span><br><span class="line"><span class="comment">//声明有返回值的类方法</span></span><br><span class="line">+ (<span class="keyword">int</span>)method;</span><br><span class="line"><span class="comment">//声明有返回值有参数的类方法</span></span><br><span class="line">+ (<span class="keyword">int</span>)method: (<span class="keyword">int</span>)var;</span><br><span class="line"><span class="comment">//声明有返回值有多个参数的类方法</span></span><br><span class="line">+ (<span class="keyword">int</span>)method: (<span class="keyword">int</span>)var1 andVar2: (<span class="keyword">int</span>)var2;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204151449444.png" alt="image-20220415144952467"></p>
<h4 id="对象方法声明和实现"><a href="#对象方法声明和实现" class="headerlink" title="对象方法声明和实现"></a>对象方法声明和实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.m</span><br><span class="line">//  ClassDemo 类</span><br><span class="line">//</span><br><span class="line">//  Created by ZhaiKun on 2017/10/9.</span><br><span class="line">//  Copyright © 2017年 ZhaiKun. All rights reserved.</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> 类：具有相同特征和行为的对象的集合</span><br><span class="line"> 对象：个人的理解是 万物皆对象</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//类的声明</span><br><span class="line">//Person 类名 首字母大写</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    //类的属性定义在 &#123; &#125; 中</span><br><span class="line">@public</span><br><span class="line">    NSString *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//方法的声明</span><br><span class="line">- (void)noParamMethod;//声明一个 返回值为空void 无参数 名为noParamMethod的方法</span><br><span class="line"> </span><br><span class="line">//带有一个参数的方法</span><br><span class="line">- (void)oneParamMethod:(NSString *)nameParam;//声明一个 返回值为空void 参数类型为NSString * 参数名为nameParam名为oneParamMethod的方法</span><br><span class="line"> </span><br><span class="line">//带多个参数的方法</span><br><span class="line">- (void)paramsMethod:(int)age1 :(int)age2;</span><br><span class="line"> </span><br><span class="line">//在类方法的实现中，可以直接访问类的属性</span><br><span class="line">- (int)classSelfParamMethod;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">//类的实现</span><br><span class="line">@implementation Person</span><br><span class="line">//方法的实现</span><br><span class="line">- (void)noParamMethod&#123;</span><br><span class="line">    NSLog(@&quot;noParamMethod方法的实现&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)oneParamMethod:(NSString *)nameParam&#123;</span><br><span class="line">    nameParam = @&quot;带有一个参数的方法&quot;;</span><br><span class="line">    NSLog(@&quot;%@&quot;, nameParam);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)paramsMethod:(int)age1 :(int)age2&#123;</span><br><span class="line">    NSLog(@&quot;多个参数的方法：%d&quot;, age1+age2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (int)classSelfParamMethod&#123;</span><br><span class="line">    age = 18;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *person = [Person new];//类的一个实例对象，类的每一个对象是各不相同的，类中的属性和方法必须通过类的实例对象进行调用</span><br><span class="line">        //person-&gt;name = @&quot;类属性的调用&quot;;</span><br><span class="line">        (*person).name = @&quot;类属性的另一种调用方式&quot;;</span><br><span class="line">        NSLog(@&quot;%@&quot;, person-&gt;name);</span><br><span class="line">        </span><br><span class="line">        //方法的调用</span><br><span class="line">        [person noParamMethod];</span><br><span class="line">        [person oneParamMethod:@&quot;&quot;];</span><br><span class="line">        [person paramsMethod:1 :2];</span><br><span class="line">        NSLog(@&quot;在方法中直接调用类的属性：%d&quot;, [person classSelfParamMethod]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204151630180.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204151645349.png" alt="image-20220415164545389"></p>
<p>isa指针指向代码段，对象空间只有属性，方法在代码段(方法代码一样，保存一份就行)</p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204151656770.png" alt="image-20220415165636766"></p>
<p>方法返回值为当前类对象，携程instancetype</p>
<h4 id="对象属性默认值"><a href="#对象属性默认值" class="headerlink" title="对象属性默认值"></a>对象属性默认值</h4><p>基本数据类型为0</p>
<p>oc指针为nil</p>
<p>c指针为NULL</p>
<p>在objective-c中定义多个类之后，会难以找到类的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark o#pragma mark -</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">	//可能发生异常的代码,异常后面的代码直接掠过跳到catch中</span><br><span class="line">&#125; </span><br><span class="line">@catch (NSException *exception) &#123;</span><br><span class="line">    //发生异常执行的代码</span><br><span class="line">&#125;</span><br><span class="line">@finally&#123;&#125;</span><br><span class="line">//c语言异常无法处理</span><br></pre></td></tr></table></figure>

<p>NsException对象常用属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name : 用于唯一地识别异常的短字符串。名称是必需的</span><br><span class="line">reason:一个更长的包含造成异常原因的“人类可读的”字符串。原因是必需的。</span><br><span class="line">userInfo：主要当异常被抛出时，返回原因等信息的一个字典。</span><br></pre></td></tr></table></figure>

<h4 id="打印指针"><a href="#打印指针" class="headerlink" title="打印指针"></a>打印指针</h4><p>我们知道c语言中对于指针的操作是可以直接通过打印指针而得到对象的地址的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s的值：%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s的地址：%p&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;首字符为：%c&quot;</span>,*s);</span><br><span class="line"></span><br><span class="line">s的值：abc</span><br><span class="line">s的地址：<span class="number">0x107f3ced8</span></span><br><span class="line">首字符为：a</span><br></pre></td></tr></table></figure>

<p>如此我们联想oc当中的字符串NSString，现在我们用oc的方式初始化一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;abc&quot;;</span><br><span class="line">NSLog(&quot;str的值为：%@&quot;,str);</span><br><span class="line">NSLog(&quot;str的地址为：%p&quot;,str);</span><br><span class="line"></span><br><span class="line">str的值为：abc</span><br><span class="line">str的地址为：0x1027510c8 </span><br></pre></td></tr></table></figure>

<p>其实NSString本身是一个对象，它不同于char *这些基本类型。本质上OC的对象是一个结构体。<br> NSLog在打印%@格式的对象时，会直接调用对象的description方法。与基本数据类型的处理是有区别的。所以oc的%@也并不是意味着值的打印，它代表的是打印对象。</p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204161502423.png" alt="NewImage"></p>
<p>create  groups 会参加编译(黄色文件夹)，create file reference不会参加编译(蓝色文件夹)</p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象只能用一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Iphone.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    //1.通过指针访问对象</span><br><span class="line">    Iphone *ip =  [Iphone new];     // 创建一个对象，并用指针ip接收</span><br><span class="line">    ip-&gt;_size = 4.3;  //这种是指针访问结构体成员变量的专用写法。OC的对象都是指针，存储着堆中的一块内存地址。              </span><br><span class="line">    ip.weight = 10;        // 通过点语法来访问对象的成员变量</span><br><span class="line">    [ip powerOff];      // 通过指针来访问对象的方法</span><br><span class="line">    </span><br><span class="line">    //2. 匿名对象，无指针</span><br><span class="line">    [Iphone new]; // 这里创建了一个对象，但是这个对象并没有用指针来接收，这个对象就是匿名对象</span><br><span class="line">    </span><br><span class="line">     注意：每次创建一个匿名对象，都会给这个对象分配不同的存储空间，也就是说每个匿名对象都不相同。</span><br><span class="line">     //3.没有两个相同的匿名对象</span><br><span class="line">    [Iphone new]-&gt;_cpu = 5;   // 给第1个匿名对象_cpu赋值</span><br><span class="line">    [Iphone new]-&gt;_size = 4.0; //给第2个匿名对象_size赋值</span><br><span class="line">    [Iphone new]-&gt;_weight = 15; //给第3个匿名对象_weight赋值</span><br><span class="line">    [[Iphone new] powerOff];  //调用第4个匿名对象powerOff方法</span><br><span class="line">    NSLog(@&quot;%@&quot;,[Iphone new]); //打印第5个匿名对象</span><br><span class="line"></span><br><span class="line">     //猜猜看，这里打印的结果全为0。</span><br><span class="line">     //原因是每次赋值时，都创建了新的匿名对象，NSLog打印的是一个新的匿名对象，它的成员变量并没有赋值。所以都为0。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   //4. 匿名对象可以作为实参进行传递</span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    Iphone *ip = [Iphone new];</span><br><span class="line">    [p sendSignal:ip];    //这里是通过指针，作为实参传递</span><br><span class="line">  </span><br><span class="line">    [p sendSignal:[Iphone new]];//这里是使用匿名对象，作为实参传递，但是[Iphone new]对象在这次使用之后就会被销毁，除非有新的指针引用它。</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>(1)C语言中的static<br>a、修饰局部变量<br>b、修饰全局变量<br>c、修饰函数</p>
<p>(2)OC中的static关键字<br>a、static不能修饰属性，也不能修饰方法<br>b、static可以修饰方法中的局部变量<br>如果方法中的局部变量被static修饰，这个变量就会变成静态变量存储在常量区，当方法执行完毕之后，不会回收，下次再执行这个方法的时候，直接使用，而不用再次声明</p>
<h4 id="查看类在代码段地址方式"><a href="#查看类在代码段地址方式" class="headerlink" title="查看类在代码段地址方式"></a>查看类在代码段地址方式</h4><ol>
<li>调试查看isa指针</li>
<li>类方法中打印self指针</li>
<li>调用对象或类的class方法</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名: 父类</span><br><span class="line">&#123;</span><br><span class="line">       //成员变量声明</span><br><span class="line">&#125;</span><br><span class="line">       //方法声明</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>OC类只能有一个直接父类，但是可以有无限多个间接父类。Objective C 不支持多重继承, 而 C++ 支持.</p>
<p>oc的继承具有：1.单根性  2.传递性</p>
<h4 id="NSObject类"><a href="#NSObject类" class="headerlink" title="NSObject类"></a>NSObject类</h4><p>Foundation框架中的一个类，在这个类中有一个new方法，用于创建对象，所有类都必须直接或间接继承NSObject类</p>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只需要利用super 给 父类的方法 发送一个消息, 那么系统就会自动调用父类的方法</span><br><span class="line">如果以后想在 子类中调用 父类的方法 可以使用super</span><br><span class="line">如果想在给 父类方法 进行扩展的同时 保留父类的方法, 那么可以使用super调用父类同名的方法</span><br></pre></td></tr></table></figure>

<p><strong>super</strong> 是个编译器的指令符号, 只是告诉编译器在执行的时候,去调谁的方法. </p>
<p>self 是一个隐私参数 </p>
<p>super 并不是隐藏的参数，它只是一个“编译器指示符”，它和 self 指向的是相同的消息接收者</p>
<ol>
<li><p>super 的作用 </p>
<ul>
<li><p>直接调用父类中的某个方法 </p>
</li>
<li><p> super 在对象方法中，那么就会调用父类的对象方法 </p>
</li>
<li><p>super 在类方法中，那么就会调用父类的类方法 </p>
</li>
<li><p>子类的类方法中，可以使用super关键字调用弗父类方法</p>
</li>
<li><p>super只能调用父类的方法，不能访问属性</p>
</li>
<li><p>super特指当前类或者对象的该方法从父类继承过来的</p>
</li>
</ul>
</li>
<li><p>使用场合 </p>
</li>
</ol>
<p>​            子类重写父类的方法时想保留父类的一些行为</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>@private</p>
<p>@protected</p>
<p>@package</p>
<p>@public</p>
<p>默认protected</p>
<p>属性定义在implementation中为真私有，外界不会提示</p>
<p>方法不写声明，只写实现，则为私有方法</p>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。  里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。  LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>派生的基石</p>
<ol>
<li>一个基类指针不仅能存基类对象，还能指向派生类对象，此时只能访问派生类对象中的基类成员，没法访问派生类中独有的成员；如果同一方法重写过，则和c++一样会引发多态</li>
<li>如果指针为NSObject类型，那么这个指针可以存储任意OC对象的地址</li>
</ol>
<h4 id="“-”"><a href="#“-”" class="headerlink" title="“%@”"></a>“%@”</h4><p>使用%@打印对象时，底层方法：</p>
<ol>
<li><p>调用传入对象的description方法</p>
<p>dscription定义在NSObject类之中，每个oc对象都有，返回字符串格式@“&lt;对象所属类名:对象的地址&gt;”</p>
<p>可以通过重写description方法改变输出格式</p>
</li>
<li><p>拿到该方法的返回值，返回值为1字符串</p>
</li>
<li><p>将字符串打印出来</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204181443655.png" alt="image-20220418144332543"></p>
<p><img src="https://img-blog.csdnimg.cn/20210314205733608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zNjg1MDk5Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="代码段存储类的步骤"><a href="#代码段存储类的步骤" class="headerlink" title="代码段存储类的步骤"></a>代码段存储类的步骤</h4><ol>
<li>在代码段创建一个Class对象，Class类是Foundation类中的一个类，该Class对象就是用来存储类信息</li>
<li>将类的信息存储在Class对象之中</li>
</ol>
<p>类是以Class对象存储在代码段</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6545546-68ba4df535430268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>selector选择器，数据类型，所以在内存中申请空间存储数据</p>
<p>SEL是一个类，SEL对象</p>
<p>Class对象不仅要存类名，还要存类方法</p>
<ol>
<li>先创建一个SEL对象</li>
<li>将方法的信息存在SEL对象中</li>
<li>SEL是一个typedef类型，自定义时已经加*，声明SEL时不需要加星号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL　变量名　=　@selector(方法名字); </span><br></pre></td></tr></table></figure>

<p>[p1 sayHi]实现原理：</p>
<ol>
<li>先拿到存储sayHi方法的SEL对象，也就是拿到存储sayHi方法的SEL数据。SEL消息</li>
<li>将这个SEL消息发给p1对象</li>
<li>这个时候p1对象接收到SEL消息以后，知道要调用方法</li>
<li>根据对象的isa指针找到存储类的类对象</li>
<li>找到累对象，搜寻是否有与传入的SEL数据一致的</li>
</ol>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>1.OC代码调用；</p>
<p>2.NSObject的performSelector调用；</p>
<p>如果方法名有冒号，则要带着冒号</p>
<p>如果有参数，使用performSelector: withObject:</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用."></a>使用.</h4><p>赋值调用setter</p>
<p>取值调用getter</p>
<h4 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h4><p>setter必须以set开头加属性首字母大写setAge</p>
<h3 id="语法"><a href="#语法" class="headerlink" title=".语法"></a>.语法</h3><p>对象名.去掉下划线属性名</p>
<p>如果没有封装getter和setter方法就没法使用.语法</p>
<h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>自动生成getter和setter的声明，写在@interface中</p>
<p>@property 数据类型 属性名</p>
<p>@property int age</p>
<ol>
<li>@property只是生成getter  setter 的声明.<br>@synthesize是生成getter  setter 的实现.</li>
</ol>
<pre><code> 这种写法是Xcode4.4之前的写法. 从Xcode4.4以后.Xcode对@property做了1个增强
</code></pre>
<ol start="2">
<li><p>@property增强</p>
<p>只需要写1个@property 编译器就会自动</p>
<ol>
<li>生成私有属性.</li>
<li>.生成getter setter的声明.</li>
<li>.生成getter setter的实现.</li>
</ol>
</li>
</ol>
<pre><code> @property NSString *name;
 
 做的事情
 1). 自动的生成1个私有属性,属性的类型和@property类型一致 属性的名称和@property的名称一致 属性的名称自动的加1个下划线.
 
 2). 自动的生成这个属性的getter setter方法的声明
 
 3). 自动的生成这个属性的getter setter方法的实现.
 
     setter的实现: 直接将参数的值赋值给自动生成的私有属性.
     getter的实现: 直接返回生成的私有属性的值.
</code></pre>
<p>  3.使用注意.</p>
<pre><code>1). @property的类型一定要和属性的类型一致. 
    名称要和属性的名称一致 只是去掉下划线.










2). 也可以批量声明相同类型的@property










3). @property生成的方法实现没有做任何逻辑验证.
 
    setter: 直接赋值
    getter： 直接返回.
 
    所以,我们可以重写setter来自定义验证逻辑.如果重写了setter 还会自动生成getter
    如果重写了getter 还会自动生成setter 










    如果同时重写getter setter 那么就不会自动生成私有属性了.
</code></pre>
<ol start="4">
<li>如果你想为类写1个属性 并且为这个属性封装getter setter<br>1个@property就搞定.</li>
</ol>
<ol start="5">
<li>继承.<br>父类的@property一样可以被子类继承.<br>@property生成的属性是私有的 在子类的内部无法直接访问生成的私有属性。<br>但是可以通过setter getter来访问。</li>
</ol>
<h3 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h3><p>@property只能声明，@synthesize则可以实现getter和setter</p>
<p>@synthesize+@property名字</p>
<p>@synthesize+@property名字=已经存在的属性名字</p>
<p>@synthesize age</p>
<ul>
<li><p>@synthesize student;   等价于 @synthesize student = student</p>
<p>会生成私有属性student</p>
</li>
<li><p>@synthesize student = _student</p>
<p>不会生成私有属性，直接使用_student</p>
<h4 id="以后只需要写-property，编译器会自动补充"><a href="#以后只需要写-property，编译器会自动补充" class="headerlink" title="以后只需要写@property，编译器会自动补充"></a>以后只需要写@property，编译器会自动补充</h4><p>同时重写getter和setter那么就不会自动生成私有属性</p>
</li>
</ul>
<p>OC是弱类型语言，编译器不会报错</p>
<h3 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h3><p>静态类型：一个指针指向本类对象</p>
<p>动态类型：一个指针指向非本类对象</p>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><p>是OC中所有类的基类，根据LSP可以指向任意OC对象</p>
<p>NSObject是万能指针</p>
<p>如果要调用指向之类对象的方法，就要做强制类型转换</p>
<h3 id="id指针"><a href="#id指针" class="headerlink" title="id指针"></a>id指针</h3><p>万能指针，可以指向任意的OC对象</p>
<p>id id1=[Person new]</p>
<p>typedef struct objc_object *id</p>
<p>id声明时不需要加*</p>
<h4 id="id指针和NSObject区别"><a href="#id指针和NSObject区别" class="headerlink" title="id指针和NSObject区别"></a>id指针和NSObject区别</h4><p> 相同点: 万能指针 都可以执行任意的OC对象.</p>
<p> 不同点: 通过NSObject指针去调用对象的方法的时候.编译器会做编译检查.<br>        通过id类型的指针去调用对象的方法的时候,编译器直接通过.无论你调用什么方法.</p>
<p> 注意: id指针只能调用对象的方法  不能使用点语法.如果使用点语法就会直接报编译错误 。<br> 如果我们要声明1个万能指针 千万不要使用NSObject 而是使用id</p>
<h4 id="父类中的类方法创建1个父类对象返回"><a href="#父类中的类方法创建1个父类对象返回" class="headerlink" title="父类中的类方法创建1个父类对象返回."></a>父类中的类方法创建1个父类对象返回.</h4><p> 1). 如果返回值写为父类类型的.那么子类来调用这个方法得到的就是父类指针.<br>     解决的方式: 把返回值改为id类型的.</p>
<p> 2). 方法的内部创建的对象的是 不要写死. 因为写死创建的对象就固定了.<br>     我们希望那1个类来调用这个方法就创建那1个类的对象.</p>
<p>​     把类名写为self 那1个类来调用这个方法 self就指的是那1个类.创建的就是那1个类的对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(id) person&#123;</span><br><span class="line">	return [self new]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3). 方法的返回值是id类型的.问题就是任意指针都可以接收这个方法的返回值.<br>     编译器连个警告都没有.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str=[Person person]</span><br></pre></td></tr></table></figure>

<p>​     如果方法的返回值是instancetype<br>​     代表方法的返回值是当前这个类的对象.</p>
<h4 id="一、什么是instancetype"><a href="#一、什么是instancetype" class="headerlink" title="一、什么是instancetype"></a>一、什么是instancetype</h4><p>instancetype是clang 3.5开始提供的一个关键字，表示某个方法返回的未知类型的OC对象。<br> 之前就接触过关键字<strong>id</strong>也可以用来表示未知类型的对象，那这两个有什么区别呢？</p>
<h4 id="二、id和instancetype的区别"><a href="#二、id和instancetype的区别" class="headerlink" title="二、id和instancetype的区别"></a>二、id和instancetype的区别</h4><h5 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h5><p>·instancetype用来在编译期确定实例的类型<br> ·id在编译时期编译器不检查类型，只能返回未知类型的对象，调用任何方法不会给出错误提示</p>
<h5 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h5><p>·instancetype只能作为返回值<br> ·id既可以作为返回值也可以作为参数</p>
<h5 id="区别三"><a href="#区别三" class="headerlink" title="区别三"></a>区别三</h5><p>·对于init方法，id和instancetype是没有区别的，因为编译器会把id优化成instancetype，当明确返回类型就是当前class时，使用instancetype能避免id带来的编译不出错误的情况。</p>
<p>1). 如果方法内部是在创建当前类的对象,不要写死成类名 【类名 new】;<br>         而是用self代替类名.</p>
<p>2). 如果方法的返回值是当前类的对象,也不要写死了. 而是写instancetype</p>
<h3 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h3><p> 1). 判断对象中是否有这个方法可以执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(BOOL)respondsToSelector:(SEL)aSelector;</span><br><span class="line">最常用的是这个方法. </span><br><span class="line">Person *p1 = [Person new];</span><br><span class="line">[p1 sayHi];</span><br><span class="line">BOOL b1=[p1 respondsToSelector:@selector(length)]</span><br></pre></td></tr></table></figure>

<p> 2). 判断类中是否有指定的类方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(BOOL)instancesRespondToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>

<p> 3). 判断指定的对象是否为 指定类的对象或者子类对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(BOOL)isKindOfClass:(Class)aClass;</span><br><span class="line">BOOL b1 = [s1 isKindOfClass:[Person class]];</span><br><span class="line">判断s1对象是否为Person对象或者Person的子类对象.</span><br></pre></td></tr></table></figure>

<p> 3). 判断对象是否为指定类的对象 不包括子类.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(BOOL)isMemberOfClass:(Class)aClass;</span><br><span class="line">s1 isMemberOfClass:[Student class]];</span><br><span class="line">判断s1对象是否为1个Student对象. 不包括Student的子类对象.</span><br></pre></td></tr></table></figure>

<p> 4). 判断类是否为另外1个类的子类.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(BOOL)isSubclassOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建对象,我们之前说:</p>
<p>类名 *指针名 =  [类名  new];</p>
<p>new实际上是1个类方法.</p>
<p>new方法的作用:<br>-&gt; 创建对象。<br>-》 初始化对象<br>-&gt; 把对象的地址返回.</p>
</li>
</ol>
<pre><code> new方法的内部,其实是先调用的alloc方法. 再调用的init方法.
 
 alloc方法是1个类方法,作用: 那1个类调用这个方法 就创建那个类的对象,并把对象返回.
 init方法 是1个对象方法,作用: 初始化对象.
 
 创建对象的完整步骤:
 应该是先使用alloc创建1个对象,然后再使用init初始化这个对象 才可以使用这个对象.
 虽然没有初始化的对象 有的时候 也可以使用. 但是千万不要这么做.
 使用1个未经初始化的对象是极其危险的.
 
 Person *p1 = [Person new];
 完全等价于
 Person *p1 = [[Person alloc] init];
</code></pre>
<p>​<br>  2. init方法.</p>
<pre><code> 作用: 初始化对象,为对象的属性赋初始值 这个init方法我们叫做构造方法.

      init方法做的事情:初始化对象.
      为对象的属性赋默认值.
      
      如果属性的类型是基本数据类型就赋值为0
                    C指针           NULL
                    OC指针          nil

 所以.我们创建1个对象如果没有为这个对象的属性赋值 这个对象的属性是有默认值的.
 所以,我们每次新创建1个对象,这个对象的属性都被初始化了.
</code></pre>
<ol start="3">
<li><p>我们想要让创建的对象的属性的默认值不是 nil NULL 0<br>而是我们自定义的.<br>那么这个时候,我们就可以重写init方法. 在这个方法中按照我们自己的想法为对象的属性赋值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重写init方法的规范:</span><br><span class="line">1). 必须要先调用父类的init方法.然后将方法的返回值赋值给self</span><br><span class="line"></span><br><span class="line">2). 调用init方法初始化对象有可能会失败,如果初始化失败.返回的就是nil</span><br><span class="line"></span><br><span class="line">3). 判断父类是否初始化成功. 判断self的值是否为nil 如果不为nil说明初始化成功.</span><br><span class="line"></span><br><span class="line">4). 如果初始化成功 就初始化当前对象的属性.</span><br><span class="line"></span><br><span class="line">5). 最后 返回self的值.</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code> 解惑
 1). 为什么要调用父类的init方法.
     因为父类的init方法 会初始化父类的属性. 所以必须要保证当前对象中的父类属性也同时被初始化.
 
 2). 为什么要赋值给self？
     因为.调用父类的init方法 会返回初始化成功的对象
     实际上返回的就是当前对象。但是我们要判断是否初始化成功.
 
 无论如何,记住重写init方法的规范.
 
 - (instancetype)init
 &#123;
     if(self = [super init])
     &#123;
        //初始化当前类的属性的代码;
     &#125;
     return self;
 &#125;
 
 什么时候需要重写init方法:
 如果你希望创建出来的对象的属性的默认值不是 nil NULL 0 而是我们指定的值.
 那么这个时候我们就可以重写init方法.
</code></pre>
<ol start="3">
<li><p>重写init方法以后.<br> 稍稍不爽的: 这样每次创建出来的对象的属性的值都是一样的.</p>
<p> 创建对象的时候,对象的属性的值由创建对象的人来指定.而不是写死在init方法中</p>
<p> <img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204201643587.png" alt="image-20220420164341957"></p>
</li>
</ol>
<pre><code> 自定义构造方法.
 
 规范:
 1). 自定义构造方法的返回值必须是instancetype
 2). 自定义构造方法的名称必须以initWith开头.
 3). 方法的实现和init的要求一样.
 
  Dog *d1 = [[Dog alloc] initWithName:@&quot;小黄&quot; andAge:2];
  Person *p1 = [[Person alloc] initWithName:@&quot;小明&quot; andAge:19 andWeight:56.3f andHeight:175.4f];
</code></pre>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  1. 内存管理</span><br><span class="line">     内存的作用:存储数据.</span><br><span class="line"> </span><br><span class="line">     1). 如何将数据存储到内存之中.</span><br><span class="line">         声明1个变量.然后将数据存储进去.</span><br><span class="line"> </span><br><span class="line">     2). 当数据不再被使用的时候,占用的内存空间如何被释放.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  2. 内存中的五大区域</span><br><span class="line"> </span><br><span class="line">     栈: 局部变量. 当局部变量的作用域被执行完毕之后,这个局部变量就会被系统立即回收.</span><br><span class="line">     堆: OC对象.使用C函数申请的空间.</span><br><span class="line">     BSS段: 未初始化的全局变量、静态变量. 一旦初始化就回收 并转存到数据段之中.</span><br><span class="line">     数据段: 已经初始化的全局变量、静态变量. 直到程序结束的时候才会被回收.</span><br><span class="line">     代码段: 代码. 程序结束的时候,系统会自动回收存储在代码段中的数据.</span><br><span class="line"> </span><br><span class="line">     栈、BSS段、数据段、代码段存储在它们中的数据的回收,是由系统自动完成的.不需要我们干预.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  3. 分配在堆区中的OC对象,是肯定需要被回收的.</span><br><span class="line"> </span><br><span class="line">     iPhone 内存机制.</span><br><span class="line"> </span><br><span class="line">     40M 警告</span><br><span class="line">     45M 警告</span><br><span class="line">     120M 闪退.</span><br><span class="line"> </span><br><span class="line">     存储在堆中的OC对象,系统不会自动回收. 直到程序结束的时候才会被回收.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  4. 内存管理的范围:</span><br><span class="line">     只需要管理存储在堆中的OC对象的回收.其他区域中的数据的回收是系统自动管理的.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  5. 对象应该什么时候被回收?</span><br><span class="line"> </span><br><span class="line">     当有人使用这个对象的时候,这个对象就千万不能回收.</span><br><span class="line">     只有在没有任何人使用这个对象的时候,才可以回收.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  6. 引用计数器</span><br><span class="line">     </span><br><span class="line">     1). 每1个对象都有1个属性.叫做retainCount.叫做引用计数器. 类型是unsigned long 占据8个字节.</span><br><span class="line">         引用计数器的作用: 用来记录当前这个对象有多少个人在使用它.     </span><br><span class="line">         默认情况下,创建1个对象出来 这个对象的引用计数器的默认值是1.</span><br><span class="line"> </span><br><span class="line">     2). 当多1个人使用这个对象的时候.应该先让这个对象的引用计数器的值+1 代表这个对象多1个人使用.</span><br><span class="line"> </span><br><span class="line">     3). 当这个对象少1个人使用的时候.应该先让这个对象的引用计数器的值-1 代表这个对象少1个人使用.</span><br><span class="line"> </span><br><span class="line">     4). 当这个对象的引用计数器变为0的时候.代表这个对象无人使用. 这个时候系统就会自动回收这个对象.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  7. 如何操作引用计数器.</span><br><span class="line"> </span><br><span class="line">     1). 为对象发送1条retain消息. 对象的引用计数器就会加1. 当多1个人使用对象的时候才发.</span><br><span class="line"> </span><br><span class="line">     2). 为对象发送1条release消息.对象的引用计数器就会减1. 当少1个人使用对象的时候才发.</span><br><span class="line"> </span><br><span class="line">     3). 为对象发送1条retainCount消息. 就可以去到对象的引用计数器的值.</span><br><span class="line"> </span><br><span class="line">     就这样++ -- 当对象的引用计数器变为0的时候,对象就会被系统立即回收.</span><br><span class="line"> </span><br><span class="line">     在对象被回收的时候.会自动调用对象的dealloc方法.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  8. 内存管理的分类</span><br><span class="line"> </span><br><span class="line">     MRC: Manual Reference Counting 手动引用计数.手动内存管理.</span><br><span class="line"> </span><br><span class="line">          当多1个人使用对象的时候,要求程序员手动的发送retain消息.少1个人使用的时候程序员手动的发送relase消息.</span><br><span class="line"> </span><br><span class="line">     2011年之前 iOS5之前</span><br><span class="line">     ARC: Automatic Reference Counting  自动引用计数.自动内存管理.</span><br><span class="line">          系统自动的在合适的地方发送retain relase消息.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     我们今天学习的MRC.</span><br><span class="line">     学习MRC的理由:</span><br><span class="line">     1). 面试必考 100%</span><br><span class="line">     2). 早期的APP开发使用的MRC技术.</span><br><span class="line">     3). iOS大牛都是从MRC成长起来的. 方便交流.</span><br><span class="line">     4). ARC是基于MRC</span><br><span class="line">  </span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="第一个MRC程序"><a href="#第一个MRC程序" class="headerlink" title="第一个MRC程序"></a>第一个MRC程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">  1. iOS5开始. Xcode4.2开始就支持ARC</span><br><span class="line">     Xcode7 默认支持ARC开发.</span><br><span class="line">     默认使用的开发方式就是ARC的模式.</span><br><span class="line"></span><br><span class="line">     关闭ARC开启MRC.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2. 当对象的引用计数器变为0的时候,系统会自动回收对象.</span><br><span class="line">     在系统回收对象的时候.会自动的调用对象的dealloc方法.</span><br><span class="line"></span><br><span class="line">     重写dealloc方法的规范:</span><br><span class="line">     必须要调用父类的dealloc方法. 并且要放在最后一句代码.</span><br><span class="line">     子类的某些对象实例是继承自父类的。因此，我们需要调用父类的dealloc方法，</span><br><span class="line">来释放父类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3. 测试引用计数器.</span><br><span class="line"></span><br><span class="line">     1). 新创建1个对象,这个对象的引用计数器的值默认是1.</span><br><span class="line">     2). 当对象的引用计数器变为0的时候.对象就会被系统立即回收 并自动调用dealloc方法.</span><br><span class="line">     3). 为对象发送retain消息 对象的引用计数器就会+1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    4. 为对象发送release消息.并不是回收对象.而是让对象的引用计数器-1</span><br><span class="line">       当对象的引用计数器的值变为0的时候.对象才会被系统立即回收.</span><br><span class="line"></span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ is dead.&quot;</span>,_name);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>) sayHi&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="comment">//Person.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc;</span><br><span class="line">-(<span class="keyword">void</span>)sayHi;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    Person* p1=[[Person alloc]init];</span><br><span class="line">    p1.name=<span class="string">@&quot;zx&quot;</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count=[p1 retainCount];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;count=%lu&quot;</span>,count);</span><br><span class="line">    [p1 release];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>内存管理的重点</p>
<p>  1). 什么时候为对象发送retain消息.</p>
<pre><code>  当多1个人使用这个对象的时候,应该先为这个对象发送retain消息.
</code></pre>
<p>  2). 什么时候为对象发送releaee消息.</p>
<pre><code>  当少1个人使用这个对象的时候.应该为这个对象发送1条release消息.
</code></pre>
</li>
<li><p>在ARC机制下,retain release dealloc这些方法方法无法调用.</p>
</li>
<li><p>内存管理的原则<br>1). 有对象的创建,就要匹配1个release</p>
<p>2). retain的次数和release的次数要匹配.</p>
<p>3). 谁用谁retain. 谁不用谁release.</p>
<pre><code>谁负责retain 谁就负责relase
</code></pre>
<p>4). 只有在多1个人用的时候才retain 少1个人使用的时候才release</p>
</li>
</ol>
<pre><code> 有始有终,有加就有减. 有retain就应该匹配1个release 一定要平衡.
</code></pre>
<h3 id="野指针和僵尸对象"><a href="#野指针和僵尸对象" class="headerlink" title="野指针和僵尸对象"></a>野指针和僵尸对象</h3><ol>
<li><p>野指针</p>
<p>C语言中的野指针: 定义1个指针变量.没有初始化.这个指针变量的值是1个垃圾值,指向1块随机的空间.这个指针就叫做野指针.</p>
<p>OC中的野指针: 指针指向的对象已经被回收了.这样的指针就叫做野指针.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person* p1=[Person new];</span><br><span class="line">[p1 release]</span><br><span class="line">//此时p1为野指针</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>对象回收的本质.内存回收的本质: 申请1个变量,实际上就是向系统申请指定字节数的空间.这些空间系统就不会再分配给别人了.<br>当变量被回收的时候,代表变量占用的字节空间从此以后系统可以分配给别人使用了.<br>但是字节空间中存储的数据还在.</li>
</ol>
<p>​         回收对象:<br>         所谓的对象的回收,指的是对象占用的空间可以分配给别人.<br>         当这个对象占用的空间没有分配给别人之前 其实对象数据还在.</p>
<ol start="3">
<li><p>僵尸对象<br>1个已经被释放的对象,但是这个对象所占的空间还没有分配给别人.这样的对象叫做僵尸对象.</p>
<p>我们通过野指针去访问僵尸对象的时候.有可能没问题 也有可能有问题.</p>
<p>当僵尸对象占用的空间还没有分配给别人的时候.这是可以的.<br>当僵尸对象占用的空间分配给了别人使用的时候 就不可以.</p>
</li>
</ol>
<ol start="4">
<li><p>我们认为只要对象称为了僵尸对象,无论如何 都不允许访问了.<br>就希望如果访问的是僵尸对象,无论如何报错.</p>
<p>僵尸对象的实时检查机制.可以将这个机制打开. 打开之后. 只要访问的是僵尸对象,无论空间是否分配 就会报错.</p>
</li>
</ol>
<ol start="5">
<li><p>为什么不默认打开僵尸对象检测.</p>
<p>一旦打开僵尸对象检测 那么在每访问1个对象的时候 都会先检查这个对象是否为1个僵尸对象,<br>这样是极其消耗性能的.</p>
</li>
<li><p>使用野指针访问僵尸对象会报错. 如何避免僵尸对象错误..</p>
<p>当1个指针称为野指针以后.将这个指针的值设置nil</p>
<p>当1个指针的值为nil 通过这个指针去调用对象的方法(包括使用点语法)的时候.不会报错. 只是没有任何反应.</p>
<pre><code>             但是如果通过直接访问属性 -&gt; 就会报错.
</code></pre>
</li>
<li><p>无法复活1个僵尸对象.</p>
</li>
</ol>
<p>​         僵尸对象到底能不能用，不能报错</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol>
<li>内存泄露.指的是1个对象没有被及时的回收.在该回收的时候而没有被回收<br>一直驻留在内存中,直到程序结束的时候才回收.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main&#123;</span><br><span class="line">	Person* p1=[Person new];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>单个对象的内存泄露的情况.</p>
<p>1). 有对象的创建,而没有对应的relase</p>
<p>2). retain的次数和relase的次数不匹配.</p>
<p>3). 在不适当的时候,为指针赋值为nil</p>
<p>4). 在方法中为传入的对象进行不适当的retain</p>
</li>
</ol>
<ol start="3">
<li><p>如何保证单个对象可以被回收</p>
<p>1). 有对象的创建 就必须要匹配1个relase</p>
<p>2). retain次数和release次数一定要匹配.</p>
<p>3). 只有在指针称为野指针的时候才赋值为nil</p>
<p>4). 在方法中布要随意的为传入的对象retain.</p>
</li>
<li><p>当属性是1个OC对象的时候. setter方法的写法.</p>
</li>
</ol>
<p>将传进来的对象赋值给当前对象的属性,代表传入的对象多了1个人使用,所以我们应该先为这个传入的对象发送1条retain消息 再赋值.</p>
<p>当当前对象销毁的时候.代表属性指向的对象少1个人使用. 就应该在dealloc中relase</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    //当人对象挂的时候,代表当前这个人对象就不会再使用_car指向的对象了.</span><br><span class="line">    //我们说,当不再使用1个对象的时候 应该为这个对象发送1条releaexiaoxi</span><br><span class="line">    [_car release];</span><br><span class="line">    NSLog(@&quot;人挂了.&quot;);</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setCar:(Car *)car</span><br><span class="line">&#123;</span><br><span class="line">    //将传入的车对象赋值给当前对象的_car属性.</span><br><span class="line">    //代表: 传入的对象多了1个人使用.</span><br><span class="line">    //那么就应该先为这个对象发送1条retain消息</span><br><span class="line">    //[car retain];//为传进来的对象发送1条retain消息,代表多1个人使用.</span><br><span class="line">    //_car = [car retain];</span><br><span class="line">    </span><br><span class="line">  if(_car!=car)&#123;   //如果新旧对象bu是一个</span><br><span class="line">    [_car release];</span><br><span class="line">    _car = [car retain];</span><br><span class="line">    //为传进来的对象发送1条retain消息,让他的引用计数器的值+1 代表多1个人使用.</span><br><span class="line">    //再将传入的对象赋值给当前对象的_car属性.</span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">        </span><br><span class="line">    //当我们将传入的Car对象赋值给_car属性的时候.</span><br><span class="line">    //代表1: _car属性原本指向的对象少1个人使用.</span><br><span class="line">    //代表2: 传入的对象多1个使用.</span><br><span class="line">    //所以,我们应该先将_car属性原本指向的对象release 再将传入的新对象retain</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (Car *)car</span><br><span class="line">&#123;</span><br><span class="line">    return _car;</span><br><span class="line">&#125;</span><br><span class="line">- (void)drive</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;走,去拉萨,开车&quot;);</span><br><span class="line">    [_car run];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Car.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;时速为%d的车子报废了.&quot;</span>,_speed);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSpeed:(<span class="keyword">int</span>)speed</span><br><span class="line">&#123;</span><br><span class="line">    _speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)speed</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;时速为%d的车子在行驶.&quot;</span>,_speed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  用面向对象模拟1个案例:</span><br><span class="line">   </span><br><span class="line">  凤姐开车去拉萨.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  人类:</span><br><span class="line">    属性: 车.</span><br><span class="line">    行为: 开车.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  车类:</span><br><span class="line">    属性: 速度.</span><br><span class="line">    行为: 行驶.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  1. 当属性是1个OC对象的时候. setter方法的写法.</span><br><span class="line"> </span><br><span class="line">     将传进来的对象赋值给当前对象的属性,代表传入的对象多了1个人使用,所以我们应该先为这个传入的对象发送1条retain消息 再赋值.</span><br><span class="line"> </span><br><span class="line">     当当前对象销毁的时候.代表属性指向的对象少1个人使用. 就应该在dealloc中relase</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     代码写法:</span><br><span class="line"> </span><br><span class="line">     - (void)setCar:(Car *)car</span><br><span class="line">     &#123;</span><br><span class="line">        _car = [car retain];</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     - (void)dealloc</span><br><span class="line">     &#123;</span><br><span class="line">        [_car release];</span><br><span class="line">        [super dealloc];</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  2. 当属性是1个OC对象的时候,setter方法照着上面那样写,其实还是有Bug的.</span><br><span class="line">     当为对象的这个属性多次赋值的时候.就会发生内存泄露.</span><br><span class="line">     发生泄露的原因: 当为属性赋值的时候, 代表旧对象少1个人用.新对象多1个人使用.</span><br><span class="line">     应该relase旧的 retain新的.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     - (void)setCar:(Car *)car</span><br><span class="line">     &#123;</span><br><span class="line">         [_car release];</span><br><span class="line">         _car = [car retain];</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  3.</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    Car *bmw = [Car new];</span><br><span class="line">    bmw.speed = 100;</span><br><span class="line">    </span><br><span class="line">    p1.car = bmw;</span><br><span class="line">    [p1 drive];</span><br><span class="line"></span><br><span class="line">    [bmw release]; </span><br><span class="line">    bmw.speed = 200;</span><br><span class="line">    p1.car = bmw;</span><br><span class="line"></span><br><span class="line">    [p1 release];</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    Person *p1 = [Person new];</span><br><span class="line">    </span><br><span class="line">    Car *bmw = [Car new];</span><br><span class="line">    bmw.speed = 200;</span><br><span class="line">    p1.car = bmw;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Car *benz = [Car new];</span><br><span class="line">    benz.speed = 400;</span><br><span class="line">    p1.car = benz;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [benz release];</span><br><span class="line">    [bmw release];</span><br><span class="line">    [p1 release];</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    Person *fj = [Person new];//1</span><br><span class="line">    </span><br><span class="line">    Car *bmw = [Car new];//1</span><br><span class="line">    bmw.speed = 100;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    fj.car = bmw;//bmw  2</span><br><span class="line">    </span><br><span class="line">    [fj drive];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [bmw release];//bmw 1</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [fj drive];//?能不能开车?</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [fj release];//0</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204231505868.png" alt="image-20220423150537635"></p>
<p>如果对象属性不是oc对象不用这样写</p>
<p>@property如果采用类属性为直接赋值，不对，采用property参数</p>
<h3 id="property参数"><a href="#property参数" class="headerlink" title="property参数"></a>property参数</h3><p>@property 参数分为4类</p>
<p>//@property 参数分为4类<br>/*<br>1.与set方法内存管理相关参数<br>retain: 要生成符合内存管理原则的set方法(应用与对象类型     OC对象)，注意只是setter生成，dealloc要自己写<br>assign: 直接赋值,(对象类型,基本数据类型    非OC对象)<br>copy : (后面讲解)<br>*/</p>
<p>//2.多线程相关<br>//nonatomic: 不生成多线程线管代码,使用这个就可以了(效率高一点)<br>//atomic:生成多线程线管代码(不写默认是这种方式)，加线程安全锁<br>//实际开发中,只要是对象类型的@property都写成下面</p>
<p>//3.是否要生成set与get方法<br>//readwrite: 可读可写属性,同时生成set与get方法<br>//readonly : 只读属性,只生成get方法</p>
<p>//4.set与get方法名称相关的参数，标准的名字<br>//setter:设置生成的set方法名称（加冒号）<br>//getter:设置生成的get方法名称</p>
<p>@property (nonatomic,retain) Car * car;<br>@property (nonatomic,retain)NSString * name;<br>@property (nonatomic,assign)int age; //int float double char<br>@property (nonatomic,assign)int weight;<br>@property (nonatomic,assign,readonly)int idCard;<br>@property (nonatomic,assign,setter = abc:,getter = zhuanghuimei)int height;<br>//改变set与get方法名称很多都是用在BOOL类型的变量<br>@property (nonatomic,assign,setter = isDeid:,getter = isDeid)BOOL isDeid;</p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204231752001.png" alt="image-20220423175233963"></p>
<p>getter=getter方法名字用来指定@property生成的getter.方法的名字，<br>setter=setter方法名字，用来指定@property生成的setter.方法的名字，注意，setter方法是带参数的所以要加I个冒号，<br>记住：如果使用getter setter修改了生成的方法的名字，<br>在使用点语法的时候，编译器会转换为调用修改后的名字的代码。<br>修改生成的getter setter方法名字，因为默认情况下生成的方法的名字已经是最标准的名字了，<br>所以，一般情况下不要去改，<br>1),无论什么情况都不要改setter.方法的名字，因为默认情况下生成的名字就已经是最标准的了，<br>2),什么时候修改getter方法的名字，当属性的类型是1个B00L类型的时候，就修改这个getter的名字以1s开头提高代码的阅读性，</p>
<p>总结<br>1.与多线程相关的参数：用nonatomic<br>2.与生成的setter方法实现相关的参数<br>        属性的类型是0C对象的时候使用retain<br>        属性的类型是非0C对象的时候使用assign<br>3.只读读写，<br>        如果你希望生成的封装是只读封装那么就使用readonly<br>        如果希望读写封装readwrite<br>4.</p>
<p>​        1)无论什么情况都不要改setter方法的名字，因为默认情况下生成的名字就已经是最标准的了，<br>​        2)什么时候修改getter方法的名字，当属性的类型是1个B00L类型的时候，就修改这个getter的名字以is开头提高代码的阅读性。</p>
<h3 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h3><p>1.当两个类相互包含的时候，当Person.h中包含Book,h而Book.h中又包含Person.h<br>    这个时候，就会出现循环引用的问题，就会造成无限递归的问题，而导致无法编译通过，<br>2.解决方案：<br>    其中一边不要使用#mport引入对方的头文件，<br>    而是使用@class类名；来标注这是1个类。这样子就可以在不引入对方头文件的情况下，告诉编译器这    是1个类。<br>3.@class与#import的区别<br>    1).#imp0rt是将指定的文件的内容拷贝到写指令的地方。<br>    2).class并不会拷贝任何内容，只是告诉编译器，这是1个类，这样编译器在编译的时候才可以知道这是1个类。</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>两个类均包含另一个类的属性，赋值后，两边使用retain，最后release会造成内存泄露</p>
<img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241129835.png" alt="image-20220424112940285" style="zoom:50%;" />

<p>解决方案：</p>
<p>一端使用retain，一端使用assign，使用assign那段dealloc中不在需要release</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Book.h&quot;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,retain)NSString *name;</span><br><span class="line">@property(nonatomic,assign)Book *book;</span><br><span class="line">- (void)read;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;人死了&quot;);</span><br><span class="line">    [_name release];</span><br><span class="line">    //[_book release];</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line">- (void)read</span><br><span class="line">&#123;</span><br><span class="line">    [_book castZhiShi];</span><br><span class="line">    NSLog(@&quot;啊,书真好&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Book.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>)Person *owner;</span><br><span class="line"><span class="comment">//传智播客 传播知识 播撒智慧 的一帮侠客们.</span></span><br><span class="line">- (<span class="keyword">void</span>)castZhiShi;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//Book.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Book.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [_name release];</span><br><span class="line">    [_owner release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;书被烧了&quot;</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)castZhiShi</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;书中自有黄金屋,书中自有颜如玉!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241230914.png" alt="image-20220424123029903"></p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241245487.png" alt="image-20220424124541232"></p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241246512.png" alt="image-20220424124610403"></p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241253797.png"></p>
<p><img src="/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220424125413694.png" alt="image-20220424125413694"></p>
<p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204241256589.png" alt="image-20220424125646654"></p>
<h3 id="自动释放池-MRC常用"><a href="#自动释放池-MRC常用" class="headerlink" title="自动释放池(MRC常用)"></a>自动释放池(MRC常用)</h3><p><strong>1.自动释放池的原理.</strong></p>
<p>存入到自动释放池中的对象,在自动释放池被销毁的时候.会自动调用存储在该自动释放池中的所有对象的release方法.</p>
<p><strong>可以解决的问题:</strong></p>
<p>将创建的对象,存入到自动释放池之中. 就不再需要手动的relase这个对象了.</p>
<p>因为池子销毁的时候 就会自动的调用池中所有的对象的release。</p>
<p><strong>自动释放池的好处</strong>: </p>
<p>将创建的对象存储到自动释放池中,不需要再写release</p>
<p><strong>2.如何创建自动释放池.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这对大括弧代表这个自动释放池的范围.</p>
<p><strong>3.如何将对象存储到自动释放池之中</strong></p>
<p>在自动释放池之中调用对象的autorelease方法.就会将这个对象存入到当前自动释放池之中.</p>
<p>这个autorealse方法返回的是对象本身. 所以,我们可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line">   Person *p1 = [[[Person alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候,当这个自动释放池执行完毕之后,就会立即为这个自动释放池中的对象发送1条release消息.</p>
<p>目前为止,我们感受到得autorelase的好处:<br>创建对象,调用对象的autorelease方法 将这个对象存入到当前的自动释放池之中.</p>
<p>我们就不需要再去release 因为自动释放池销毁的时候 就会自动的调用池中所有对象的release</p>
<p><strong>3.使用注意</strong></p>
<p>​    1). 只有在自动释放池中调用了对象的autorelease方法,这个对象才会被存储到这个自动释放池之中.<br>​    如果只是将对象的创建代码写在自动释放之中,而没有调用对象的autorelease方法.是不会将这个对象存储到这个自动释放池之中的.</p>
<p>​    2). 对象的创建可以在自动释放池的外面,在自动释放池之中,调用对象的autorelease方法,就可以将这个对象存储到这个自动释放池之中.</p>
<p>​    3). 当自动释放池结束的时候.仅仅是对存储在自动释放池中的对象发送1条release消息 而不是销毁对象.</p>
<p>​    4). 如果在自动释放池中,调用同1个对象的autorelease方法多次.就会将对象存储多次到自动释放池之中.<br>​    在自动释放池结束的时候.会为对象发送多条release消息.那么这个是就会出现僵尸对象错误.<br>​    所以,1个自动释放池之中,只autorelease1次,只将这个对象放1次, 否则就会出现野指针错误.</p>
<p>​    5). 如果在自动释放池中,调用了存储到自动释放中的对象的release方法.<br>​    在自动释放池结束的时候,还会再调用对象的release方法.<br>​    这个时候就有有可能会造成野指针操作.<br>​    </p>
<p>也可以调用存储在自动释放池中的对象的retain方法.</p>
<p> 6). 将对象存储到自动释放池,并不会使对象的引用计数器+1<br>     所以其好处就是:创建对象将对象存储在自动释放池,就不需要在写个release了.</p>
<p> 7).  自动释放池可以嵌套.<br>      调用对象的autorelease方法,会讲对象加入到当前自动释放池之中<br>      只有在当前自动释放池结束的时候才会像对象发送release消息.</p>
<p><strong>4.autorelease的规范.</strong><br>    0). 创建对象,将对象存储到自动释放池之中. 就不需要再去手动的realse。</p>
<pre><code> 1). 类方法的第1个规范:
  一般情况下,要求提供与自定义构造方法相同功能的类方法.这样可以快速的创建1个对象
 
 2). 我们一般情况下,写1个类. 会为我们的类写1个同名的类方法,用来让外界调用类方法来快速的得到1个对象.
  规范:使用类方法创建的对象,要求这个对象在方法中就已经被autorelease过了.
  这样,我们只要在自动释放池中, 调用类方法来创建对象, 那么创建的对象就会被自动的加入到自动释放中.
  提供1个类方法来快速的得到1个对象.
  **规范**
  a. 这个类方法以类名开头. 如果没有参数就直接是类名 如果有参数就是 类名WithXX:
  b. 使用类方法得到的对象,要求这个对象就已经被autorelease过了.
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(instancetype)person</span><br><span class="line"></span><br><span class="line">return [[[self alloc] init] autorelease];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​     这样,我们直接调用类方法.就可以得到1个已经被autorelease过的对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line">    Person *p1 = [Person person];</span><br><span class="line">    //这个p1对象已经被autorelase过了.不需要再调用autorelase</span><br><span class="line">    //这个p1对象就被存储到当前自动释放池之中.</span><br><span class="line">&#125;//当自动释放池结束.就会为存储在其中的p1对象发送release消息.</span><br></pre></td></tr></table></figure>

<p><strong>5.实际上Apple的框架中的类也是遵守这个规范的.</strong></p>
<p>通过类方法创建的对象都是已经被autorelease过的了.</p>
<p>所以,我们也要遵守这个规范. 类方法返回的对象也要被autorealse过.</p>
<p>以后,我们凡事创建对象是调用类方法创建的对象 这个对象已经是被autorelease过的了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Pig.h&quot;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line">    Pig *p1 = [Pig pigWithName:@&quot;猪猪&quot; andAge:1 andWeight:100];</span><br><span class="line">    NSString *str0 = [[[NSString alloc] initWithFormat:@&quot;jack&quot;] autorelease];</span><br><span class="line">    NSString *str1 = [NSString stringWithFormat:@&quot;jack&quot;];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//    NSString *str = [NSString alloc] initWithFormat:&lt;#(nonnull NSString *), ...#&gt;;</span><br><span class="line">//    [NSString string]; </span><br><span class="line">//    </span><br><span class="line">//    Pig *p1 = [[Pig alloc] initWithName:@&quot;八戒&quot; andAge:2 andWeight:260];</span><br><span class="line">//    </span><br><span class="line">//    Pig *p2 = [Pig pigWithName:@&quot;八戒&quot; andAge:2 andWeight:260];</span><br><span class="line">//    </span><br><span class="line"> </span><br><span class="line">//    @autoreleasepool</span><br><span class="line">//    &#123;</span><br><span class="line">//        Person *p1 = [[[Person alloc] init] autorelease];</span><br><span class="line">//</span><br><span class="line">//        Car *c1 = [[[Car alloc] init] autorelease];</span><br><span class="line">//        </span><br><span class="line">//        p1.car = c1;</span><br><span class="line">//    &#125;</span><br><span class="line">//    </span><br><span class="line"></span><br><span class="line">//自动释放池唯一的作用: 省略创建对象匹配的那个release</span><br><span class="line">//其他的和我们昨天讲的都是一样的.</span><br><span class="line"></span><br><span class="line">//    @autoreleasepool</span><br><span class="line">//    &#123;</span><br><span class="line">//        Person *p1 = [[[Person alloc] init] autorelease];</span><br><span class="line">//        @autoreleasepool</span><br><span class="line">//        &#123;</span><br><span class="line">//        </span><br><span class="line">//            Person *p2 = [[[Person alloc] init] autorelease];</span><br><span class="line">//            </span><br><span class="line">//            @autoreleasepool</span><br><span class="line">//            &#123;</span><br><span class="line">//                 Person *p3 = [[[Person alloc] init] autorelease];</span><br><span class="line">//            &#125;</span><br><span class="line">//            </span><br><span class="line">//        &#125;</span><br><span class="line">//        </span><br><span class="line">//        </span><br><span class="line">//    &#125;</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//    @autoreleasepool</span><br><span class="line">//    &#123;</span><br><span class="line">//        </span><br><span class="line">//        Person *p1 = [[[Person alloc] init] autorelease];//1</span><br><span class="line">//        </span><br><span class="line">//     </span><br><span class="line">//        </span><br><span class="line">//        //在自动释放池中调用同1个对象的autorelease多少次 就会降这个对象存储到自动释放池中多少词.</span><br><span class="line">    </span><br><span class="line">//        //[p1 retain];//2</span><br><span class="line">//        //[p1 autorelease];//将p1对象 存储到当前的自动释放池</span><br><span class="line">//        </span><br><span class="line">//        </span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">//    Person *p1 =  [Person new];</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    [p1 release];</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><ol>
<li><strong>什么是ARC</strong></li>
</ol>
<p>  Automatic Reference Counting，自动引用计数. 即ARC. </p>
<p>  顾名思义:系统自动的帮助我们去计算对象的引用计数器的值,</p>
<p>  可以说是WWDC2011和iOS5引入的最大的变革和最激动人心的变化. </p>
<p>  ARC是新的LLVM3.0编译器的一项特性,使用ARC,可以说一举解决了广大iOS开着所憎恨的手动管理内存的麻烦.</p>
<p>  在程序中使用ARC非常简单,只需要像往常那样编写代码. </p>
<p>  只不过永远不要写retain、release、autorelease 永远要手动的调用 dealloc 这三个关键字就好,这是ARC的最基本的原则.</p>
<p>  当ARC开启时, 编译器会自动的在合适的地方插入retain、release、autorelase代码. </p>
<p>  编译器自动为对象做引用计数. 而作为开发者,完全不需要担心编译器会做错(除非开发者自己错用了ARC).</p>
<p>  需要特别注意的是: ARC是编译器机制. 在编译器编译代码的时候,会在适时的位置加入retain、release和autorealse代码.</p>
<ol start="2">
<li><strong>ARC机制下,对象何时被释放</strong></li>
</ol>
<p>  本质: 对象的引用计数器为0的时候,自动释放.</p>
<p>  表象: 只要没有强指针指向这个对象,这个对象就会立即回收.</p>
<ol start="3">
<li><strong>强指针与弱指针.</strong></li>
</ol>
<p>  强指针: 默认情况下,我们声明1个指针 这个指针就是1个强指针. </p>
<p>​      我们也可以使用__strong来显示的声明这是1个强指针.</p>
<p>​      </p>
<p>​      Person *p1; 这是1个强指针. 指针默认情况下都是1个强指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__strong Person *p2; 这也是1个强指针.使用__strong来显示的声明强指针.</span><br></pre></td></tr></table></figure>

<p>  弱指针: 使用__weak标识的指针就叫做弱指针.</p>
<p>​      </p>
<p>  无论是强指针还是弱指针,都是指针,都可以用来存储地址,这1点没有任何区别 。</p>
<p>  都可以通过这个指针访问对象的成员.</p>
<p>  唯一的区别就是在ARC模式下.他们用来作为回收对象的基准. </p>
<p>  如果1个对象没有任何强类型的指针指向这个对象的时候,对象就会被立即自动释放</p>
<ol start="4">
<li><strong>确认程序是否开启ARC机制.</strong></li>
</ol>
<p>  1).默认情况下,Xcode开启ARC机制.</p>
<p>  2).ARC机制下,不允许调用retain、relase、retainCount、autorelease方法.</p>
<p>  3).众所周知，iOS开发的时候，使用ARC的话，dealloc函数是不需要实现的，写了反而会出错。如果需要重写dealloc(在画面关闭的时候，需要把ViewController的某些资源释放)。在dealloc中 不允许[super dealloc];dealloc在ARC下的作用就是释放 系统无法释放的该对象占用的资源,或者其他对象对该对象的引用</p>
<ol start="5">
<li><strong>演示第1个ARC案例</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  @autoreleasepool</span><br><span class="line">   &#123;</span><br><span class="line">     Person *p1 = [Person new];//p1是1个强指针.</span><br><span class="line">    //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.</span><br><span class="line">    NSLog(@&quot;------&quot;);</span><br><span class="line">   &#125;//当执行到这里的时候.p1指针被回收,那么Person对象就没有任何</span><br><span class="line">   //强指针指向它了. 对象就在这被回收.</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ARC下单个对象内存管理"><a href="#ARC下单个对象内存管理" class="headerlink" title="ARC下单个对象内存管理"></a>ARC下单个对象内存管理</h3><ol>
<li><p>ARC下的单个对象的内存管理.</p>
<p>在ARC的机制下: 当1个对象没有任何的强指针指向它的时候 这个对象就会被立即回收.</p>
<p> 1). <strong>当指向对象的所有的强指针被回收的时候,对象就会被立即回收.</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">       Person *p1 = [Person new];//p1是1个强指针.</span><br><span class="line">       Person *p2 = p1;//p2也是个强指针.p1和p2都指向Person对象.</span><br><span class="line">       //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.</span><br><span class="line">       NSLog(@&quot;------&quot;);</span><br><span class="line">    &#125;//当执行到这里的时候.p1指针被回收,p2指针也被回收.那么Person对象就没有任何</span><br><span class="line">    //强指针指向它了. 对象就在这被回收.</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2).<strong>将所有指向对象的强指针赋值为nil的时候.对象就会被立即回收.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        Person *p1 = [Person new];//p1是1个强指针.</span><br><span class="line">        //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.</span><br><span class="line">        </span><br><span class="line">        p1 = nil;//当执行到这句话的时候.p1赋值为nil.</span><br><span class="line">        //p1指针不再执行Person对象.</span><br><span class="line">        //Person对象没有被任何的指针所指向,所以.Person对象在这里被释放.</span><br><span class="line">        NSLog(@&quot;------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这两种情况就叫做没有任何强指针指向对象.<br> 1). <strong>指向对象的所有强指针被回收掉</strong><br> 2). <strong>指向对象的所有的强指针赋值为nil</strong></p>
<ol start="2">
<li><p>强指针与弱指针.</p>
<p>1). <strong>强指针与弱指针的声明.</strong></p>
<p> 默认情况下,所有的指针都是强类型的,也就是说我们之前声明的指针变量都是强类类型的</p>
<p> p1指针是强类型的,因为默认情况下指针都是强类型的.<br> Person *p1 = [[Person alloc] init];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不过我们可以使用__strong来显示的标识指针是强类型指针.</span><br><span class="line">__strong Person *p2 = [Person new];</span><br><span class="line">这个时候p2指针类型是强指针类型的.其实写不写__strong都是强类型的指针</span><br><span class="line">指针类型也可以是弱指针类型.</span><br><span class="line">使用__weak标识指针的类型是弱类型指针.</span><br><span class="line">__weak Person *p3 = p2;</span><br><span class="line">这个时候,p3指针就是1个弱类型的指针. p3弱指针也指向p2指针指向的对象.</span><br></pre></td></tr></table></figure>

<p>在操作对象的时候,通过强指针或者弱指针都可以操作,没有任何区别.</p>
</li>
</ol>
<p>2). <strong>ARC模式下的对象回收标准</strong></p>
<p> ARC机制下释放1个对象的标准是: 没有任何强指针指向对象的时候,对象就会被释放.<br> 如果这个时候有弱指针指向,也会被释放.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        //使用__strong来标识p1指针是强类型的,其实不写__strong也是强类型的.</span><br><span class="line">        __strong Person *p1 = [[Person alloc] init];</span><br><span class="line">        </span><br><span class="line">        //使用__weak标识指针p2的类型是弱类型指针.</span><br><span class="line">        __weak Person *p2 = p1;</span><br><span class="line">        //这个时候,p2指针和p1指针都指向Person对象.</span><br><span class="line">        </span><br><span class="line">        //这个时候如果设置p1的值为nil</span><br><span class="line">        p1 = nil;</span><br><span class="line">        //这个时候Person对象只有被1个弱指针p2指向,没有任何强指针指向</span><br><span class="line">        //所以Person对象在这里被回收.</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3).<strong>最重要的1点:不能创建对象用1个弱指针存储这个对象的指针.</strong><br> 这样的话,刚创建出来的对象,就没有任何强指针指向,创建出来就会被回收.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        //创建1个对象,将这个对象的地址赋值给1个弱指针</span><br><span class="line">        //后果就是创建出来的这个对象没有被任何强指针指向.</span><br><span class="line">        //刚创建出来就会被释放.</span><br><span class="line">        __weak Person *p1 = [[Person alloc] init];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4). <strong>在ARC机制下. 当对象被回收的时候. 原来指向这个对象的弱指针会被自动设置为nil</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;  </span><br><span class="line">  //  [Person new];</span><br><span class="line">//    __weak Person *p2 = p1;</span><br><span class="line">//    </span><br><span class="line">//    p1 = nil;  </span><br><span class="line">//    [p2 sayHi];//这个地方报错.  </span><br><span class="line">//    NSLog(@&quot;~~~~~~&quot;);    </span><br><span class="line">//    __weak Person *p1 = [[Person alloc] init];   </span><br><span class="line">//    return 0; </span><br><span class="line">//    __strong Person *p1 = [Person new];</span><br><span class="line">//    __weak Person *p2 = p1;   </span><br><span class="line">//    p1 = nil;</span><br><span class="line">//    Person *p1 = [Person new];</span><br><span class="line">//    Person *p2 = p1;</span><br><span class="line">//    __weak Person *p3 = p2;</span><br><span class="line">//    p1 = p2 = nil;</span><br><span class="line">//    @autoreleasepool</span><br><span class="line">//    &#123;      </span><br><span class="line">//        Person *p1 = [Person new];       </span><br><span class="line">//        p1 = nil;       </span><br><span class="line">//    &#125;</span><br><span class="line">//    </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ARC下多个对象内存管理"><a href="#ARC下多个对象内存管理" class="headerlink" title="ARC下多个对象内存管理"></a>ARC下多个对象内存管理</h3><ol>
<li><p>ARC机制下的对象的回收的标准: 当没有任何强类型的指针指向对象的时候,这个对象就会被立即回收.</p>
</li>
<li><p>强类型指针 弱类型指针.</p>
</li>
<li><p>什么情况下叫做对象没有强指针向指向.</p>
<p>1).  指向对象的强指针被回收.</p>
<p>2).  指向对象的强指针被赋值为nil</p>
</li>
<li><p>在ARC的机制下,@property参数不能使用retain</p>
<p>因为retain代表生成的setter方法是MRC的标准的内存管理代码.</p>
<p>而我们在ARC的机制下不需要这些代码.</p>
<p>所以,在ARC机制下的setter方法 什么都不需要做.直接赋值就可以了.</p>
</li>
<li><p>ARC机制下,我们关注的重点.</p>
<p>当1个类的属性是1个OC对象的时候.这个属性应该声明为强类型的还是弱类型的.</p>
<p>很明显,应该声明为1个强类型的.</p>
<p>问题来了?</p>
<p>如何控制@property生成的私有属性,是1个强类型的还是1个弱类型的呢?</p>
<p>使用参数, strong和weak</p>
<p>@property(nonatomic,strong)Car *car;</p>
<p>代表生成的私有属性_car 是1个强类型的.</p>
<p>@property(nonatomic,weak)Car *car;</p>
<p>代表生成的私有属性_car 是1个弱类型的.</p>
<p>如果不写,默认是strong.</p>
</li>
<li><p>使用建议.</p>
<p>1). 在ARC机制下.如果属性的类型是OC对象类型的.绝大多数场景下使用strong</p>
<p>2). 在ARC机制下.如果属性的类型不是OC对象类型的.使用assign</p>
<p>3).  strong和weak都是应用在属性的类型是OC对象的时候. 属性的类型不是OC对象的时候就使用assign.</p>
<p>在ARC机制下,将MRC下的retain换位strong</p>
<p>@property(nonatomic,strong)Car *car;</p>
<p>做的事情:</p>
<p>1).  生成私有属性.并且这个私有属性是strong</p>
<p>2).  生成getter setter方法的声明</p>
<p>3).  生成getter setter方法的声明</p>
</li>
</ol>
<p>​     setter的实现:直接赋值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">  Person *p1 = [Person new];</span><br><span class="line">  Car *c1 = [Car new];</span><br><span class="line">  p1.car = c1;</span><br><span class="line">  c1= nil;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ARC下的循环引用"><a href="#ARC下的循环引用" class="headerlink" title="ARC下的循环引用"></a>ARC下的循环引用</h3><p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204251036414.png" alt="image-20220425103628159"></p>
<p>当两个都是强指针时，大括号后对象内的属性有强指针，导致两个内存都不会释放</p>
<p> 在ARC机制下.当两个对象相互引用的时候.如果两边都使用strong 那么就会先内存泄露.</p>
<p> 解决方案: 1端使用strong 1端使用weak</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    Person *p1 = [Person new];</span><br><span class="line">    Book *b1 = [Book new];</span><br><span class="line">    p1.book = b1;</span><br><span class="line">    b1.owner = p1;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Book.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>)Person *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Book.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Book.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;书被烧了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Book.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)Book *book;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;人死了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="property参数总结"><a href="#property参数总结" class="headerlink" title="@property参数总结"></a>@property参数总结</h3><ol>
<li><p>开发程序分为ARC和MRC</p>
</li>
<li><p>与多线程相关的参数.</p>
<pre><code>    atomic : 默认值 安全,但是效率低下.
 
    nonatomic: 不安全,但是效率高.
 
    无论在ARC还是在MRC都可以使用.
 
    **使用建议: 无论是ARC还是MRC 都使用nonatomic**
</code></pre>
</li>
<li><p>retain: </p>
<pre><code>    **只能用在MRC的模式下.**代表生成的setter方法是标准的内存管理代码.
 
    当属性的类型是OC对象的时候.绝大多数情况下使用retain. **只有在出现了循环引用的时候1边retain 1边assign**
</code></pre>
</li>
<li><p>assign:</p>
<pre><code>    **在ARC和MRC的模式下都可以使用assign.**

    当属性的类型是非OC对象的时候 使用assign.
</code></pre>
</li>
<li><p>strong:</p>
<pre><code>    **只能使用在ARC机制下. 当属性的类型是OC对象类型的时候,绝大多数情况下使用strong**
 
    **只有出现了循环引用的时候, 1端strong 1端weak**
</code></pre>
</li>
<li><p>weak:</p>
<pre><code>    只能使用在ARC机制下. 当属性的类型是OC对象的时候. 只有出现了循环引用的时候, 1端strong 1端weak
</code></pre>
</li>
<li><p>readonly readwrite </p>
<pre><code>    无论是ARC还是MRC 都可以使用.
</code></pre>
</li>
<li><p>setter getter 无论在ARC下还是在MRC下都可以改.</p>
</li>
</ol>
<p> -—————————-</p>
<pre><code>     在ARC机制下.原来使用retain的用strong
 
     出现循环引用的时候. MRC: 1边retain 1边assign  ARC: 1边strong 1边weak
</code></pre>
<h3 id="MRC-ARC转化"><a href="#MRC-ARC转化" class="headerlink" title="MRC ARC转化"></a>MRC ARC转化</h3><p><img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204251100052.png" alt="image-20220425110052066"></p>
<p>Compiler Flags填写**-fno-objc-arc** ,使用的便是MRC</p>
<ol>
<li><p>有可能会遇到的问题.</p>
<pre><code>    程序使用的是ARC机制开发的,但是其中的某些类使用的是MRC.
</code></pre>
</li>
<li><p>使用命令.  -fno-objc-arc</p>
</li>
</ol>
<p>将MRC程序转化为ARC</p>
<p>Edit——Convert——To Objective-C ARC</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>分类.</p>
<pre><code>    类别、类目、category
</code></pre>
</li>
<li><p>写1个学生类:类中有很多个方法.</p>
<pre><code>    吃 喝 拉 撒 睡.... 基本行为

    学习、敲代码、写书.... 学习

    玩Dota 玩LOL 玩CF.... 玩

    爬山、跑步、踢足球..... 运动

    ......

   如果将这些方法都写在同1个类模块中.当然完全是可以的.

   如果全都写在一个模块中,就显的很臃肿. 后期难以维护和管理.

   默认情况下1个类独占1个模块.这个是将所有的成员都写在这1个模块中.就很男管理.

   我们的想法: 那就让1个类占多个模块.将功能相似的方法定义在同1个模块中.
</code></pre>
</li>
</ol>
<p>​            这样的好处: 方便维护和管理</p>
<pre><code>       如何将1个类分成多个模块呢?
</code></pre>
<p>​        New File——Category</p>
<img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204251455939.png" alt="image-20220425145456868" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204251455398.png" alt="image-20220425145534711" style="zoom:50%;" />



<ol start="3">
<li><p>分类:</p>
<pre><code>1). 顾名思义: 将1个类分为多个模块.

2). 如何为1个类添加分类.

3). 会生成1个.h 和1个.m的模块.
</code></pre>
</li>
</ol>
<p>​     a. 模块的文件名:  本类名+分类名.h   本类名+分类名.m</p>
<pre><code>   4). 添加的分类也分为声明和实现.
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface 本类名 (分类名)</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>​     代表不是新创建1个类.而是对已有的类添加1个分类. 小括弧中写上这个分类的名字.</p>
<p>​     因为1个类可以添加多个分类 为了区分每1个分类.所以分类要取名字.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student (itcast)</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>​     这是分类的实现.</p>
<ol start="4">
<li><p>分类的使用.</p>
<ol>
<li>如果要访问分类中定义的成员,就要把分类的头文件引进来.</li>
</ol>
</li>
<li><p>分类的作用: 将1个类分为多个模块</p>
</li>
</ol>
<p> -——————————————-</p>
<p> 使用分类注意的几个地方:</p>
<ol>
<li><p>分类只能增加方法,不能增加属性</p>
</li>
<li><p>在分类之中可以写@property 但是不会自动生成私有属性. 也不会自动生成getter setter的实现.</p>
</li>
</ol>
<p>​    只会生成getter setter的声明.</p>
<p>​    所以,你就需要自己写getter 和 setter的声明. 也需要自己定义属性 这个属性就必须在本类中.</p>
<p> 3.在分类的方法实现中不可以直接访问本类的真私有属性(定义在本类的@implementation之中)</p>
<p>​    但是可以调用本类的getter setter来访问属性.</p>
<p>​    本类的@property生成的私有属性,只可以在本类的实现中访问.</p>
<p>​    分类中不能直接访问私有属性 真.</p>
<p>​    分类可以使用 getter setter 来访问.</p>
<ol start="4">
<li>分类中可以存在和本类同名方法的.</li>
</ol>
<p>​    当分类中有和本类中同名的方法的时候,优先调用分类的方法.哪怕没有引入分类的头文件.</p>
<p>​    如果多个分类中有相同的方法,优先调用最后编译的分类</p>
<p> -———————————–</p>
<p> 什么时候需要使用分类.</p>
<p> 当1个类的方法很多很杂的时候. 当1个类很臃肿的时候.</p>
<p> 那么这个时候我们就可以使用分类. 将这个类分为多个模块.将功能相似的方法写在同1个模块之中.</p>
<p> xiahuaxian</p>
<p> GC与ARC.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line">#import &quot;Student+itcast.h&quot;</span><br><span class="line">#import &quot;Student+sb.h&quot;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">  Student *s1 = [Student new];</span><br><span class="line">  [s1 sayHi];</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非正式协议"><a href="#非正式协议" class="headerlink" title="非正式协议"></a>非正式协议</h3><ol>
<li><p>分类的作用在于可以将我们写类分为多个模块.</p>
<pre><code>    可以不可以为系统的类写1个分类呢?
 
    为系统自带的类写分类 这个就叫做非正式协议.
</code></pre>
</li>
<li><p>分类的第2个作用:</p>
<pre><code>    为1个已经存在的类添加方法.
</code></pre>
</li>
<li><p>NSString类都挺好的. 就是差了1个方法.</p>
<pre><code>    统计字符串对象中有多少个阿拉伯数字.
</code></pre>
</li>
</ol>
<p> 分类的作用</p>
<p>​         1). 将臃肿的类分为多个模块 方便管理.</p>
<pre><code>     2). 扩展1个类.
</code></pre>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ol>
<li><p>ARC机制垃圾回收机制的区别.</p>
<pre><code>    GC: 程序在运行的期间,有1个东西叫做垃圾回收器.不断的扫描堆中的对象是否无人使用.
</code></pre>
</li>
</ol>
<p>​             Person *p1 = [Person new];</p>
<p>​             p1 = nil;</p>
<pre><code>       ARC: 不是运行时. 在编译的时候就在合适的地方插入retain......
</code></pre>
<p>​                     插入的代码足以让对象无人使用的时候 引用计数器为0</p>
<h3 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h3><ol>
<li><p>延展: Extension</p>
<p>   1). 是1个特殊的分类. 所以延展也是类的一部分.</p>
<p>   2). 特殊之处:</p>
<p>​     a. <strong>延展这个特殊的分类没有名字.</strong></p>
<p>​     b. <strong>只有声明没有实现.和本类共享1个实现.</strong></p>
</li>
<li><p> 延展的语法</p>
</li>
</ol>
<p>  语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface 本类名 ()</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>  **没有实现. 和本类共享1个实现.**没有impletation</p>
<p> 3.为类添加延展的步骤</p>
<p>  <strong>只有1个.h文件. 文件名称: 本类名_取得文件名.h</strong></p>
<p><strong>Person_itcast.h</strong></p>
<p>  这个文件中只有延展的声明.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>延展的基本使用.</li>
</ol>
<p>  1). 延展的本质是1个分类. 作为本类的一部分.</p>
<p>​    只不过是1个特殊的分类</p>
<p>​    没有名字.</p>
<p>  2). 延展只有声明,没有单独的实现. 和本类共享一个实现.</p>
<ol start="5">
<li>延展和分类的区别</li>
</ol>
<p>  1). 分类有名字.延展没有名字 是1个匿名的分类.</p>
<p>  2). 每1个分类都有单独的声明和实现. 而延展只有声明 没有单独的实现 和本类共享1个实现,</p>
<p>  3). 分类中只能新增方法. 而延展中任意的成员都可以写.</p>
<p>  4). 分类中可以写@property 但是只会生成getter setter的声明.</p>
<p>​    延展中写@property 会自动生成私有属性 也会生成getter setter的声明和实现.</p>
<ol start="6">
<li><p>延展的应用场景.</p>
<p>1). 要为类写1个私有的@property.</p>
</li>
</ol>
<p>​     生成getter、setter方法只能在类的内部访问 不能在外部访问.</p>
<p>​     其实,我们可以想: @property生成私有属性、生成getter setter的实现,不要声明.</p>
<p>   2). 延展100%的情况下不会独占1个文件. 都是将延展直接写在本类的实现文件中.</p>
<p>​     这个时候,写在延展中的成员,就相当于是这个类的私有成员.只能在本类的实现中访问.</p>
<p>​     外部不能访问.</p>
<p>   3). 什么时候使用延展?</p>
<p>​     当我们<strong>想要为类定义私有成员的时候,就可以使用延展.</strong> 将延展定义在这个类的实现文件中.</p>
<p>​     <strong>如果想要为类写1个真私有属性,虽然我们可以定义在@implementation之中.但是不要这么写 这样很不规范.</strong>  </p>
<p>​     写1个延展.将这个私有属性定义在延展中.</p>
<p>​     如果要为类写1个私有方法,建议将声明写在延展中, 实现写在本类的实现中. 提供代码的阅读性</p>
<p>​     如果想要为类写1个私有的@property 就直接写在延展就可以了</p>
<p>   4). <strong>延展天生就是来私有化类的成员的.</strong></p>
<p>​     如果类的成员只希望在类的内部访问,那么就将其定义在延展中.</p>
<p>​     如果类的成员允许被外界访问 定义在本类的@interface中.</p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><ol>
<li><p><strong>OC在C的基础之上新增了一些数据类型.</strong></p>
<p>BOOL</p>
<p>Boolean</p>
<p>class</p>
<p>nil</p>
<p>SEL</p>
<p>id</p>
<p>block</p>
</li>
<li><p><strong>block是1个数据类型.</strong></p>
<p>int double float char …….</p>
<p>既然是1个数据类型,那么就可以声明这个数据类型的变量. 所以我们完全也可以声明1个block类型的变量.</p>
<p>不同类型的变量中可以存储不同类型的数据.</p>
<p>那么block类型的变量中可以存储什么样的数据呢?</p>
<p>1). block是1个数据类型 所以我们可以声明1个block类型的变量.</p>
<p>2). block类型的变量中专门存储1段代码. 这段代码可以有参数 可以有返回值.</p>
</li>
<li><p><strong>block变量的声明</strong></p>
<p>1). 虽然block变量中是用来存储1段代码的.但是1个block变量中并不是任意的1段代码都可以存进去的</p>
</li>
</ol>
<p>​     而是有限定的.</p>
<p>​     也就是说.在声明block变量的时候.<strong>必须要指定这个block变量存储的代码段是否有参数.是否有返回值.</strong></p>
<p>​     一旦指定以后,这个block变量中就只能存储这样的代码了.</p>
<p>​     声明了1个block变量.返回值是void 参数是1个int类型的.</p>
<p>​     这个时候. 这个block变量中就只能存储无返回值并且有1个int参数的代码段.</p>
<p>   2). 声明block变量的语法格式:</p>
<p>​     返回值类型 (^block变量的名称)(参数列表);</p>
<p>​     void (^myBlock1)(); 表示声明了1个block类型的变量叫做myBlock1 这个变量中只能存储没有返回值没有参数的代码段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (^myBlock2)(); </span><br><span class="line"></span><br><span class="line">int (^myBlock3)(int num1,int num2);</span><br></pre></td></tr></table></figure>

<p>   3). 最重要的</p>
<p>​     声明block变量的时候要指定这个block变量可以存储的代码段的返回值和参数描述.</p>
<p>​     一旦指定.这个block变量中就只能存储这样的代码段了. 其他格式的代码段无法存储.</p>
<ol start="4">
<li><p><strong>初始化block变量</strong></p>
<p>1). 原理: 写1个符合block要求的代码段.存储到block变量中就可以了.</p>
<p>2). 代码段的书写格式:</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ^返回值类型(参数列表)&#123;</span><br><span class="line">     	代码段;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   3). 写1个无参数无返回值的代码段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^void()&#123;</span><br><span class="line"> 	NSLog(@&quot;我爱你&quot;);</span><br><span class="line"> 	NSLog(@&quot;我恨你&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     这个时候,我们就可以将这段代码使用赋值符号存储到 无返回值无参数要求的block变量中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^myBlock1)();</span><br><span class="line">myBlock1 =  ^void()&#123;</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;我爱你&quot;);</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;我恨你&quot;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     当然也可以在声明block变量的同时使用符合要求的代码段初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (^myBlock1)() =  ^void()&#123;</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;我爱你&quot;);</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;我恨你&quot;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   4). 有返回值的代码段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^int()&#123;</span><br><span class="line"> int num1 = 10 + 20;</span><br><span class="line"> return num1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     我们就可以将这段代码赋值给符合要求的block变量.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> (^myBlock2)() =  ^<span class="keyword">int</span>()&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> num1 = <span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> num1;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   5). 既有参数既有返回值的代码段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^int(int num1,int num2)&#123;</span><br><span class="line"> int num3= num1 + num2;</span><br><span class="line"> return num3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     所以 我们可以将这个代码赋值给符合要求的block变量.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^myBlock3)(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2) =  ^<span class="keyword">int</span>(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)&#123;</span><br><span class="line">     <span class="keyword">int</span> num3= num1 + num2;</span><br><span class="line">     <span class="keyword">return</span> num3;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>   6). 注意.</p>
<p>​     赋值给block变量的代码段必须要符合block变量的要求. 否则就会报错.</p>
<ol start="5">
<li><p><strong>如何执行存储在block变量中的代码段.</strong></p>
<p><strong>语法格式: block变量名();</strong></p>
<p>有参数就传参数.有返回值就接.</p>
</li>
<li><p><strong>关于block的简写.</strong></p>
<p>1). 如果我们写的代码段没有返回值.那么代码段的void可以省略.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^myBlock1)() =  ^()&#123;</span><br><span class="line">  NSLog(@&quot;我爱你&quot;);</span><br><span class="line">  NSLog(@&quot;我恨你&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     注意,我说的是代码段的返回值如果是void可以省略,声明block变量的返回值无论是什么不可以省略.</p>
<p>   2). 如果我们写的代码段没有参数,那么代码段的小括弧写可以省略.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int (^myBlock2)() =  ^int&#123;</span><br><span class="line">  int num1 = 10 + 20;</span><br><span class="line">  return num1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​     再次强调: 我们说的是代码段.</p>
<p>​     所以,当1个代码段既没有参数,也没有返回值的适合,就只写^</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^myBlock1)() =  ^&#123;</span><br><span class="line"> NSLog(@&quot;我爱你&quot;);</span><br><span class="line"> NSLog(@&quot;我恨你&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   3).声明block变量的时候.如果有指定参数.可以只写参数的类型而不写参数的名称;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int (^myBlock3)(int,int) =  ^int(int num1,int num2)&#123;</span><br><span class="line">    int num3= num1 + num2;</span><br><span class="line">    return num3;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>   注意: 这个地方我们说的是声明block变量的时候 再写代码段的时候 类型和名称都要写.</p>
<p>   4).<strong>无论代码段是否有返回值.在写代码的时候.可以不写返回值类型 省略.</strong></p>
<p>​    如果在写代码段的时候,省略了返回值,这个时候系统会自动的确定返回值的类型.</p>
<p>​    如果代码段中没有返回任何数据 那么它会认为这个代码段是没有返回值的.</p>
<p>​    如果代码中有返回数据 返回的数据是什么类型 它就会认为这个代码段是什么类型的</p>
<p>  建议: 仍然按照我们最标准的写法来写block变量和block代码段.因为这样可以提高代码的阅读性.</p>
<ol start="7">
<li><p><strong>简化block变量的复杂定义.</strong></p>
<pre><code>    1). 问题: 定义block变量的时候.要写好大1串啊! 类型好长.

    2). typedef的使用场景: 将1个长类型定义为1个短类型.

    3). 我们也可以使用typedef将长的block类型 定义为1个短类型.
</code></pre>
</li>
</ol>
<p>​     <strong>typedef 返回值类型 (^新类型)(参数列表);</strong></p>
<p>​     <strong>typedef void (^NewType)(); 代表重新定义了1个类型叫做NewType 是1个block类型 无参数无返回值的block类型</strong></p>
<ol start="8">
<li><p><strong>关于block块访问外部变量的问题.</strong></p>
<p>1). 在block代码块的内部可以取定义在外部的变量的值, 定义在外部的局部变量和全局变量.</p>
<p>2). 在block代码块的内部可以修改全局变量的值.但是不能修改定义在外部的局部变量的值.</p>
<p>3). <strong>如果你希望我们定义的局部变量可以允许在block代码的内部去修改,那么就为这个局部变量加1个__block的修饰符</strong>.</p>
</li>
</ol>
<p> ——-总结——-</p>
<p> \1.  block是1个数据类型.</p>
<p> \2.  block变量是来存储1段代码的.</p>
<p> \3.  block变量的声明.</p>
<p> \4.  block变量的初始化</p>
<p> \5.  执行存储在block变量中的代码.</p>
<p> \6.  关于4个简写.</p>
<p> \7.  使用typedef将复杂的block定义简化.</p>
<p> \8.  访问外部变量的问题.</p>
<h3 id="block的使用"><a href="#block的使用" class="headerlink" title="block的使用"></a>block的使用</h3><ol>
<li><p>block是1个数据类型.能不能不能作为函数的参数呢? 当然是可以的.</p>
</li>
<li><p>如何为函数定义block类型的参数?</p>
<pre><code>    a. 就是在小括弧中声明1个指定格式的block变量就可以了.
 
    b. 可以使用typedef简化定义,这样看起来就不会晕了.
</code></pre>
</li>
<li><p>如何调用带block参数的函数呢?</p>
<pre><code>    a. 如果要调用的函数的参数是block类型的,那么要求在调用的时候传入1个和形参block要求的代码段.

  b. 调用的时候,可以先讲代码段存储到1个block变量中,然后再传递这个block变量
</code></pre>
</li>
</ol>
<p>​     也可以直接将符合要求的代码段写在小括弧中传递</p>
<pre><code>       c. 小技巧. 通过Xcode提示可以快速的生产block代码段的框架.
</code></pre>
<ol start="4">
<li><p>将block作为函数的参数可以实现什么样的效果?</p>
<p>可以将调用者自己写的1段代码 传递到 函数的内部去执行.</p>
</li>
<li><p>block也可以作为函数的返回值.</p>
<pre><code>    当将block作为函数的返回值的时候,**返回值的类型就必须要使用typedef定义的短类型.**
</code></pre>
</li>
<li><p>block与函数</p>
<pre><code>    相同点: 都是封装1段代码.

   不同点:

           1). block是1个数据类型.函数是1个函数.

           2). 我们可以声明block类型的变量  函数就只是函数. 

            3). **block可以作为函数的参数. 而函数不能直接作为函数的参数.**
</code></pre>
</li>
</ol>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ol>
<li>协议:protocol.</li>
</ol>
<p>  作用: </p>
<pre><code>      1). **专门用来声明一大堆方法**. (**不能声明属性,也不能实现方法,只能用来写方法的声明**).
  
      2). 只要某个类遵守了这个协议.就相当于拥有这个协议中的所有的方法声明.而不用自己去定义.
</code></pre>
<ol start="2">
<li>协议的声明.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol 协议名称 &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">方法的声明;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<pre><code>       新建1个协议的方式.  NewFile OC-File - protocol
   
        协议的文件名: .h 并且只有1个.h文件.
   
       在协议中,只能用来声明方法,协议的作用:就是专门用来写方法声明的.
</code></pre>
<ol start="3">
<li><p>类遵守协议.</p>
<pre><code>    协议就是用来写方法声明的,就是用来被类遵守的.

    如果想要让1个类,拥有协议中定义的所有的方法声明.那么就让这个类遵守这个协议.

   类只要遵守1个协议,那么这个类就拥有了这些协议中定义的所有的方法的声明了.
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名 : 父类名 &lt;协议名称&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  : 表示继承.</span><br><span class="line">//  &lt;&gt; 表示遵守的协议.</span><br></pre></td></tr></table></figure>

<pre><code>       当1个类,遵守了1个协议,那么就相当于这个类拥有了协议中定义的所有的方法的声明.
  
       这个类只是拥有了这个协议中的方法的声明而已. 没有实现.所以 这个类,就应该实现协议中的方法.
  
      如果类不实现协议中的方法,其实也不会报错.编译器只是会报警告.
  
      但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.
</code></pre>
<ol start="4">
<li><p>类是单继承. 但是协议可以多遵守</p>
<pre><code>    1个类只能有1个父类

    但是1个类可以同时遵守多个个协议
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名 : 父类名  &lt;协议名称1,协议名称2......&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<pre><code>       当1个类遵守了多个协议之后,就相当于这个类拥有了所有协议中定义的方法的声明.
  
      那么这个类,就应该实现所有协议中的方法
  
      如果不实现,其实也不会报错.编译器只是会报警告.
  
      但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.
</code></pre>
<p>  -——-</p>
<pre><code>       当1个类遵守了某个协议.就相当于这个类拥有了这份协议中的所有的方法的声明.
   
       但是仅仅只是有方法的声明而已,没有是实现,要类自己去实现.
   
        如果类不实现.编译器不会报错. 只是给1个警告.
   
        当我们创建对象,如果不调用这个协议方法,就不会报错.
   
       如果要调用这个协议方法,那就会报错.
</code></pre>
<ol start="5">
<li><p>@required 与 @optional</p>
<pre><code>    当1个类遵守了1份协议.这个类就拥有这个协议中的所有的方法声明 仅仅是只有声明而已.还要自己实现.

    如果不实现呢?也不会报错 只是给1个警告

    @required 与 @optional这两个修饰符是专门用来修饰协议中的方法的.

    在协议中,如果方法的声明被@required修饰,那么遵守这个协议的类必须要实现这个方法,否则编译器会发出警告.

    在协议中,如果方法的声明被@optional修饰,那么遵守这个协议的类如果不实现这个方法.编译器也不会报警告

    其实,无论是@required还是@optional你都可以不实现. 编译器是不会报错的. 仍然可以编译 运行.

    唯一的区别就是: 当遵守协议的类不实现协议中的方法的时候,@required会给1个警告. @optional警告都木有.

    这两个关键字的主要作用:在于程序员沟通,告诉遵守协议的类 哪些方法是必须要实现的,
</code></pre>
</li>
</ol>
<p>​         因为这些方法我会调用.</p>
<pre><code>       默认的是@required
</code></pre>
<ol start="6">
<li><p>协议可以从另外1个协议继承,并且可以多继承.</p>
<pre><code>    协议可以继承另外1个协议.  A 协议 继承了 B协议. 那么A协议中不仅有自己的方法的声明,还有B协议中的方法的声明.

    如果有1个类遵守了A协议，那么这个类就拥有了, A、B协议中的所有的方法的声明.

    协议之间继承的语法格式
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol A协议名称 &lt;B协议名称&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<pre><code>       代表A协议继承自B协议, A协议中既有自己的方法声明,也有B协议中的方法声明.
  
       NSOBject: 这是1个类. 是所有的OC类的基类. 这个类是苹果早就定义好得.
  
      NSOBject: 这也是1个协议. 也是苹果早就定义好得. 这个协议被NSObject类遵守.
</code></pre>
<p>​            所以,所有的OC对象都拥有这个协议中的所有的方法.</p>
<p>​            这个协议我们也叫做基协议.</p>
<pre><code>       写协议的规范: 任何1个协议,必须要间接的或者直接的去遵守这个NSObject基协议.
   
       协议的名称可以和类的名称相同:
</code></pre>
<ol start="7">
<li><p>@protocol类型限制.</p>
<p>  1). 要求某个指针保存的是遵守指定协议的对象.   </p>
<p>​    NSObject<myProtocol> *obj;</p>
<p>​    id<myProtocol> *obj;</p>
<p>  2). 要求某个指针变量保存的是继承了某个类,并遵守了指定协议的对象.</p>
<p>  3). 属性案例:  男孩子的女朋友</p>
<p>  4). 为什么要求对象遵守协议?</p>
<p>​    因为我要调用对象的这个方法 你只有遵守了这个协议才有这个方法.</p>
<p>  5). 协议与继承,</p>
<p>​    超人 鸟  飞机 装X飞.</p>
</li>
<li><p> 案例: 婴儿饿了要哭 困了要睡 保姆开照顾. 老师也能当保姆.</p>
</li>
</ol>
<h3 id="协议类型限制"><a href="#协议类型限制" class="headerlink" title="协议类型限制"></a>协议类型限制</h3><ol>
<li><p>请声明1个指针.这个指针可以指向任意的对象,但是要求指向的对象要遵守指定的协议.</p>
<pre><code>    如果不遵守 最起码要报1个警告.

   要求声明1个指针 指向1个遵守了学习协议的对象, 否则最起码要给哥哥1个警告.

   NSObject&lt;协议名称&gt; *指针名;

   这个时候,这个指针可以指向遵守了指定协议的任意对象. 否则就会报1个警告.

   NSObject&lt;StudyProtocol&gt; *obj = [Student new];

    当然了完全也可以使用id指针.

   id&lt;协议名称&gt; 指针名;

   id&lt;StudyProtocol&gt; id1 =  [Student new];
</code></pre>
</li>
<li><p>声明1个指针变量,要求这个指针变量指向的对象必须遵守多个协议</p>
<pre><code>    NSObject&lt;StudyProtocol,SBProtocol&gt; *obj1 = [Student new];

    id&lt;StudyProtocol,SBProtocol&gt; obj1 = [Student new];
</code></pre>
</li>
<li><p>定义1个指针,指向遵守了学习协议的学生对象.</p>
</li>
<li><p>WHY?</p>
<pre><code>    1). 遵守了某个协议的类,就相当于这个类拥有了这个协议所定义的行为.

    2). 因为我要调用这个对象中的协议方法.
</code></pre>
</li>
</ol>
<p>​             只有类遵守了协议,这个类中一定才会有协议方法.</p>
<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><ol start="0">
<li><p>注意</p>
<pre><code>    我们暂时只是将实现的简单的语法. 应用
</code></pre>
</li>
<li><p>什么是代理模式.</p>
<pre><code>    传入的对象,代替当前类完成了某个功能,称为代理模式.
</code></pre>
</li>
<li><p>利用协议实现代理模式的主要思路.</p>
<pre><code>    1). 定义1个协议.里面声明代理类需要实现的方法列表. 比如这里的1个代理类需要实现wash cook方法.

    2). 创建1个代理类(比如猪猪) 遵守上面的代理协议 并实现方法

    3). 在需要代理的类中,定义1个对象属性 类型为id 且遵守代理协议的属性.

    4). 在代理的类中,调用代理对象的方法
</code></pre>
</li>
</ol>
<p>  代理模式:</p>
<pre><code>       有1个对象中有1个属性, 这个属性的可以是任意的对象,但是这个对象必须具有指定的行为.
</code></pre>
<p>​            这个时候就可以使用协议.</p>
<pre><code>       将行为定义在代理之中.
   
       对象的属性的类型 id&lt;协议&gt;
   
       只要遵守了这个协议的对象都可以作为这个类的代理.
</code></pre>
<ol start="3">
<li><p>代理设计模式的场合</p>
<pre><code>       1). 当对象A发生了一些事情,想告知对象B 让对象B称为对象A的代理.
 
                               2). 对象B想监听对象A的一些行为. 让B称为A的代理,
 
                               3). 当对象A无法处理某些场景的时候,想让对象B帮忙处理.
</code></pre>
</li>
<li><p>婴儿饿了就会哭 哭的时候要有1个人喂他吃奶.  </p>
<pre><code>    困了就要睡.困的时候就要1个人去哄他睡觉.
</code></pre>
</li>
</ol>
<p>​            用代理设计模式.为婴儿找1个可以照顾它的人.</p>
<p>   Baby</p>
<p>​    属性:</p>
<p>​     姓名</p>
<p>​     年龄.</p>
<p>​     照顾他的人.</p>
<p>​    行为:</p>
<p>​     哭</p>
<p>​     吃奶</p>
<p>​     睡觉</p>
<p>​     犯困的行为.</p>
<p>   可以照顾这个小孩子的人要求:</p>
<p>​    喂奶 哄孩子睡觉.</p>
<h3 id="Foundation框架"><a href="#Foundation框架" class="headerlink" title="Foundation框架"></a>Foundation框架</h3><p> Foundation框架. </p>
<p> NSString</p>
<p> NSMutableString</p>
<p> NSArray</p>
<p> NSMutableArray</p>
<p> NSDictionary</p>
<p> NSMutableDictionary</p>
<p> NSFileManger</p>
<p> NSDate</p>
<p> NSVlue</p>
<p> NSNumber</p>
<p> copy</p>
<ol>
<li>框架: 就是系统(苹果)或者第三方(其他的一些高手)事先写好了一些很牛X功能的类.</li>
</ol>
<p>​             把这些类交给我们使用.这些类的集合我们叫做框架.</p>
<p>​             框架中有很多很多功能相似的类. 函数库</p>
<p>   <strong>Foundation框架:</strong>  是1个包 这里面有很多类、函数、定义了一些数据类型.</p>
<p>​           这个框架中的类都是一些最基础的类. NSString NSObject</p>
<p>​           其他的框架都是基于Foundation框架的.</p>
<p>   <strong>UIKit.</strong></p>
<p>   <strong>AVFoundation.</strong></p>
<p>   …..</p>
<ol start="2">
<li><p>Foundation框架中的最常用的类. 简单的爆.量大.</p>
</li>
<li><p>NSString</p>
<pre><code>    1). NSString是1个数据类型.保存OC字符串的.
</code></pre>
</li>
</ol>
<p>​             NSString的本质是1个类.既然是1个类.</p>
<p>​             所以,最标准的创建NSString对象的方式:</p>
<p>​                     NSString *str1 = [NSString new];</p>
<p>​                     NSString *str2 = [[NSString alloc] init];</p>
<p>​                     NSString *str3 = [NSString string];</p>
<p>​             使用这种方式创建的字符串是1个空的字符.  @””</p>
<p>​             <strong>NSString对象就是用来存储字符串</strong>.</p>
<pre><code>       2). NSString是OC中最常用的1个类了.**所以OC提供了一种更为快速的创建字符串对象的方式.**
</code></pre>
<p>​             <strong>使用前缀@</strong></p>
<p>​             @”jack”; 本质上这是1个NSString对象.这个NSString对象中存储的是”jack”这个字符串.</p>
<p>​            NSString *str1 = @”rose”;</p>
<p>​            1).  <strong>@”rose”本质上是1个NSString对象,这个对象中存储的是字符串”rose”.</strong></p>
<pre><code>        2).  将这个字符串对象的地址返回赋值给str1指针.
</code></pre>
<p>​             <strong>%p: 打印指针变量的值.打印地址.</strong></p>
<p>​             <strong>%@:  打印指针指向的对象.</strong></p>
<ol start="4">
<li><p>NSString的恒定性.</p>
<pre><code>    1). 当我们使用简要的创建字符串对象的时候.也就是使用1个OC字符串常量来初始化字符串指针的时候，**这个字符串对象是存储在 常量区(数据段) 的.**
</code></pre>
</li>
</ol>
<p>​             NSString *str = @”jack”;</p>
<p>​             <strong>当我们调用NSString的类方法来创建对象的时候，存储在堆区</strong></p>
<p>​             NSString *str =  [NSString stringWithFormar:@”jack”];</p>
<pre><code>         NSString *str1 = [NSString new];
   
        2). 当在内存中创建1个字符串对象以后.这个字符串对象的内容就无法更改.
</code></pre>
<p>​             当我们重新为字符串指针初始化值的时候.并不是修改原来的字符串对象 </p>
<p>​             而是重新的创建1个字符串对象 将这个字符串对象的地址重新复制给字符串指针变量.</p>
<pre><code>       3). 当系统准备要在内存中创建字符串对象的时候.会先检查内存中是否有相同内容的字符串对象.
</code></pre>
<p>​             如果有,直接指向. 如果没有才会重新创建.</p>
<pre><code>       4). 存储在常量区的数据不会被回收. 所以存储在常量区的字符串对象也不会被回收.
</code></pre>
<h3 id="NSString常用成员"><a href="#NSString常用成员" class="headerlink" title="NSString常用成员"></a>NSString常用成员</h3><ol>
<li><p>NSString是1个类.那么肯定其中有很多的方法.</p>
</li>
<li><p>使用频率最最高的几个方法.</p>
<pre><code>    1). 使用拼接的方式创建1个NSString对象.
</code></pre>
</li>
</ol>
<p>​             + (instancetype)stringWithFormat:(NSString *)format, … </p>
<p>​            NSString* str1=[NSString StringWithFormat:@”大家好我叫%s，我今年%d虽了”，name,age];</p>
<pre><code>       2). 得到字符串的长度.
</code></pre>
<p>​             @property (readonly) NSUInteger <strong>length</strong>;</p>
<pre><code>       3). 得到字符串中指定下标的字符.
</code></pre>
<p>​             - (unichar)<strong>characterAtIndex</strong>:(NSUInteger)index;</p>
<pre><code>         返回值是unichar类型的 要打印的话使用%C
 
     4). 判断两个字符串的内容是否相同.
</code></pre>
<p>​             a. 能否使用 == 来判断两个OC字符串的内容是否相同.</p>
<p>​             b. == 运算符的作用: 比较左右两边的数据是否相同.</p>
<p>​                      -&gt;  10 == 10  这个时候直接比较的是左右两边的数据是否相同.</p>
<p>​                      -&gt;  a == b  两边也可以写1个变量.这个时候比较是左右两边的变量的值是否相同.</p>
<p>​                      -&gt;  如果两边是1个指针变量.那么比较的也是变量的值. 只不过指针变量的值是地址.</p>
<p>​             c. 所以,如果我们要比较两个OC字符串的内容是否相同.不能使用 == 去比较.</p>
<p>​              因为 == 比较的是字符串指针变量的值.而我们要比的是两个字符串指针指向的字符串对象的内容是否相同.</p>
<p>​             c. 调用方法: </p>
<p>​                      - (BOOL)<strong>isEqualToString</strong>:(NSString *)aString;</p>
<p>​                      就可以比较当前字符串对象和传入的字符串对象的内容是否相同.</p>
<pre><code>           5). 将C语言的字符串转换为OC字符串对象.
</code></pre>
<p>​                     + (instancetype)<strong>stringWithUTF8String</strong>:(NSString *)string;</p>
<pre><code>           6). 将OC字符串对象转换为C语言的字符串.
</code></pre>
<p>​                     @property (nullable, readonly) __strong const char *<strong>UTF8String</strong></p>
<p>​                    char* str1=str.UTF8String;</p>
<h3 id="NSString常用方法"><a href="#NSString常用方法" class="headerlink" title="NSString常用方法"></a>NSString常用方法</h3><ol>
<li><p>将字符串写入到指定的文件中.</p>
<pre><code>    \- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;
</code></pre>
</li>
<li><p>将文件中的内容读取到字符串中.</p>
<pre><code>    \+ (nullable instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;
 
    nullable 代表返回的对象有可能是nil
</code></pre>
</li>
<li><p>使用<strong>NSURL</strong>读写资源.</p>
<pre><code>    1). NSURL对象. 专门用来保存资源地址的. 资源地址: 本地磁盘路径、网页地址、ftp文件地址.

    2). 资源路径的地址的写法:
</code></pre>
</li>
</ol>
<p>​                     http://  开头的是网页路径的写法.</p>
<p>​                     file://  开头的是本地磁盘的路径</p>
<p>​                     ftp://   开头的是ftp文件资源的路径</p>
<p>​                     如果要讲1个资源路径的地址保存到NSURL对象中 地址一定要是标准写法.</p>
<pre><code>       3). 如何将资源地址存储到NSURL对象中.
</code></pre>
<p>​                     NSURL *url1 = [NSURL <strong>URLWithString</strong>:@”<a href="http://www.itcast.cn&quot;]">http://www.itcast.cn&quot;]</a>;</p>
<p>​                     NSURL *url2 = [NSURL URLWithString:@”<a href="ftp://server.itcast.cn/ccc.txt&quot;]">ftp://server.itcast.cn/ccc.txt&quot;]</a>;</p>
<p>​                     NSURL *url3 = [NSURL URLWithString:@”file:///Users/Apple/Desktop/abc.txt”];</p>
<pre><code>       4). 字符串就提供了对应的方法去读写NSURL对象中封装的资源路径
</code></pre>
<p>​                     从指定资源路径读取文本内容.</p>
<p>​                     + (nullable instancetype)<strong>stringWithContentsOfURL</strong>:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;</p>
<p>​                     将字符串的内容写入到资源路径中.</p>
<p>​                     - (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;</p>
<p>​                     如果要向网页或者ftp写内容要有权限.</p>
<ol start="4">
<li><p>字符串比较.</p>
<pre><code>    \- (NSComparisonResult)compare:(NSString *)string;
</code></pre>
</li>
<li><p>字符串比较:忽略大小写的比较:</p>
</li>
<li><p>字符串的相等判断. </p>
</li>
<li><p>判断字符串是否以指定的字符串开头</p>
<pre><code>    \- (BOOL)hasPrefix:(NSString *)str;
</code></pre>
</li>
<li><p>判断字符串是否以指定的字符串结尾</p>
<pre><code>    \- (BOOL)hasSuffix:(NSString *)str;
</code></pre>
</li>
<li><p>在主串中搜索子串.从前往后</p>
<pre><code>       \- (NSRange)rangeOfString:(NSString *)searchString;

            返回值是1个NSRange类型的结构体变量.
       
                typdef struct _NSRange &#123;
</code></pre>
<p>​                     NSUInteger location; 代表子串在主串出现的下标.</p>
<p>​                     NSUInteger length; 代表子串在主串中匹配的长度.</p>
<pre><code>       &#125; NSRange;
  
      如果没有找到:
  
      location 为NSUInteger的最大值, 也就是NSNotFound
  
       length 的值为0
  
      这个方法,是从前往后搜索. 第1次匹配的子串.
</code></pre>
</li>
<li><p>在主串中搜索子串.从后往前.</p>
</li>
</ol>
<p>​            NSString *str = @”i love itcast love!”;</p>
<p>​            NSRange range =  [str rangeOfString:@”love” options:NSBackwardsSearch];</p>
<ol start="11">
<li><p>NSRange结构体.</p>
<pre><code>   1). 是Foundation框架中定义的1个结构体.
</code></pre>
</li>
</ol>
<p>​             typedef struct _NSRange {</p>
<p>​              NSUInteger location;</p>
<p>​              NSUInteger length;</p>
<p>​             } NSRange;</p>
<p>​             NSRange range;</p>
<p>​             这个结构体变量一般情况下用来表示1段范围.特别用在子串在主串中的范围表示.</p>
<p>​    @”hahajackhehe” @”jack” </p>
<p>​     4  4</p>
<p>​    NSRange range = {4, 4};</p>
<p>  2). 声明并初始化结构体变量的方式.</p>
<p>​    1). 最原始的方式.</p>
<p>​       NSRange range;</p>
<p>​       range.location = 3;</p>
<p>​       range.length = 4;</p>
<p>​    2). 第二种方式:   NSRange range = {3, 7};</p>
<p>​    3). 第三种方式:  NSRange range = {.location = 3,.length = 7};</p>
<p>​    4). Foundation框架中定义了1个函数.这个函数可以快速的创建1个NSRange结构体会,</p>
<p>​      NSRange range =  NSMakeRange(loc, len);</p>
<p>​      返回1个指定属性的NSRange结构体变量.</p>
<p>​    5). Foundation框架中定义了1个函数 可以将1个NSRange结构体变量转换为NSString</p>
<p>​       NSStringFromRange(ran) 函数可以将NSRange结构体变量转换为指定格式的字符串.</p>
<h3 id="字符串常用成员"><a href="#字符串常用成员" class="headerlink" title="字符串常用成员"></a>字符串常用成员</h3><ol>
<li><p>字符串的截取.</p>
<pre><code>    取到字符串中的1部分.
 
    \- (NSString *)**substringFromIndex**:(NSUInteger)from; 从指定的下标出一直截取到最后.
 
    \- (NSString *)**substringToIndex**:(NSUInteger)to; 从第0个开始截取指定的个数.
 
    \- (NSString *)**substringWithRange**:(NSRange)range; 截取指定的1段范围.
</code></pre>
</li>
<li><p>字符串的替换</p>
<pre><code>    \- (NSString *)**stringByReplacingOccurrencesOfString**:(NSString *)target withString:(NSString *)replacement
 
    将字符串中第1个参数替换为第2个参数.友情提示: 原来的指针指向字符串的内容是不会变的  会全部替换.
 
    新串是以方法的返回值返回的.
 
    **这个方法还可以做删除. 原理: 将其替换为@&quot;&quot;**
</code></pre>
</li>
<li><p>字符串数据转换为其他的类型. 使用频率很高.</p>
<pre><code>    @property (readonly) double doubleValue;
</code></pre>
</li>
</ol>
<p>​                    str.doubleValue</p>
<pre><code>       @property (readonly) float floatValue;
</code></pre>
<p>​                    str.floatValue</p>
<pre><code>       @property (readonly) int **intValue**;
</code></pre>
<p>​                    str.intValue</p>
<pre><code>       @property (readonly) NSInteger integerValue
   
       @property (readonly) long long longLongValue
   
       @property (readonly) BOOL boolValue
   
       转换注意. 从头开始转换,能转换多少就是多少. 到遇到不能转换的时候就停止转换.
</code></pre>
<ol start="4">
<li><p>去掉字符串前后的空格.</p>
<pre><code>    str =  [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

   中间的空格无法去掉.
</code></pre>
</li>
</ol>
<h3 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h3><ol>
<li><p>字符串的恒定性.</p>
<pre><code>一旦创建1个字符串对象,那么这个字符串对象的内容就无法更改, 当我们修改字符串的时候,其实是重新的创建了1个字符串对象.
</code></pre>
<p>代码案例:</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;-------------------&quot;);</span><br><span class="line">NSString *str = @&quot;&quot;; //@&quot;&quot;</span><br><span class="line">for(int i = 0; i &lt; 50000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  str = [NSString stringWithFormat:@&quot;%@%d&quot;,str,i];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;-------------------&quot;);</span><br></pre></td></tr></table></figure>

<pre><code>   会耗费很长的时间. 每次循环的时候 都会创建1个新的字符串对象.50000个,
</code></pre>
<p>   因为字符串的恒定性.</p>
<ol start="2">
<li><p>如何让这样的大批量的字符串拼接可以更加快速的1点.</p>
<pre><code>   1). 慢得原因: 因为字符串的恒定性,每次修改字符串的时候,是重新的创建1个对象,

   2). 希望: 有没有一种对象是用来存储字符串的,并且存储在这个对象中的字符串数据可以更改.
</code></pre>
</li>
<li><p>NSMutableString</p>
<pre><code>   1). **是Foundation框架中的1个类.从NSString继承.**
</code></pre>
</li>
</ol>
<p>​            所以,NSMutableString对象是用来存储字符串数据的.</p>
<pre><code>      2). NSMutbaleString在父类NSString的基础之上的做扩展.
</code></pre>
<p>​            <strong>存储在NSSMutableString对象中的字符串数据可以更改.具备可变性</strong>.</p>
<p>​            直接可以改存储在NSMutableStirng对象中的字符串数据,不会新创建对象.</p>
<ol start="4">
<li><p>NSMutableString的用法</p>
<pre><code>   1). 既然是1个类,要使用的话,就得创建1个对象.
</code></pre>
</li>
</ol>
<p>​            *<em>NSMutableString <em>str = [NSMutableString string];</em></em></p>
<p>  2). 往可变字符串对象中追加字符串.</p>
<p>​             *<em>- (void)appendString:(NSString <em>)aString;</em></em>  直接追加内容.</p>
<p>​             *<em>- (void)appendFormat:(NSString <em>)format</em></em>, … 以拼接的方式往可变字符串对象中追加内容.</p>
<p>  3). 创建NSMutableString对象的时候,记住下面这样的初始化方式是不行的.</p>
<p>​            错误：<strong>NSMutableString <em>str = @”jack”;</em></strong>   xxxx</p>
<p>​            @”jack” 是1个NSString对象,是1个父类对象.</p>
<p>​            而str指针是1个NSMutableString类型的 是1个子类类型的.    </p>
<p>​            如果通过子类指针去调用子类独有的成员 就会运行错误.</p>
<p>  4). NSMutableString从NSString继承.</p>
<p>​            在使用NSString的地方完全可以使用NSMutableString</p>
<ol start="5">
<li>使用NSMutableString来做大批量的字符串拼接.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;~~~~~~~~~~~~&quot;);</span><br><span class="line">NSMutableString *str = [NSMutableString string];</span><br><span class="line">for(int i = 0; i &lt; 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line"> [str appendFormat:@&quot;%d&quot;,i];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;~~~~~~~~~~~~&quot;);</span><br></pre></td></tr></table></figure>

<pre><code>      这个时候 &quot;biu&quot;的一下就结束了. 为什么这么快&gt;? 因为NSMutableString只有1个.每次修改的时候 直接修改的是这个对象中的数据.
</code></pre>
<ol start="6">
<li><p>使用建议</p>
<pre><code>   1). 我们平时使用的时候,还是使用NSString. 因为效率高.
</code></pre>
</li>
</ol>
<p>​                NSString *str1 = @”jack”;</p>
<p>​                NSString *str2 = @”jack”;</p>
<pre><code>      2). NSMutbaleString: 只在做大批量的字符串拼接的时候才使用.
</code></pre>
<p>​    大量拼接的时候,就不要去使用NSString 因为效率低下.\</p>
<p>​    10次以上.</p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><ol>
<li><p>回忆C语言中的数组</p>
<p>特点:</p>
<pre><code>    a. 存储多个数据.
 
    b. 类型相同.
 
    c. 长度固定.
 
    d. 每1个元素都是紧密相连的.
</code></pre>
</li>
<li><p>NSArray</p>
<pre><code>    1). 是Foundation框架中的一个类.这个类的对象是来存储多个数据的,具备数组的功能.
</code></pre>
</li>
</ol>
<p>​             所以,NSArray是OC中的数组.</p>
<pre><code>       2). 特点:
</code></pre>
<p>​                     a. <strong>只能存储OC对象.任意的OC对象</strong> </p>
<p>​                     b. <strong>长度固定</strong>. 一旦NSArray数组创建完毕之后,元素的长度固定,无法新增 无法删除元素.</p>
<p>​                     c. 每1个元素都是紧密相连的. 每1个元素仍然有自己的下标.</p>
<p>​                     d. <strong>元素的类型是id类型的.</strong></p>
<ol start="3">
<li><p>NSArray数组的创建.</p>
<pre><code>    1). 因为这是1个类,所以当然就是创建NSArray对象.
</code></pre>
</li>
</ol>
<p>​                     NSArray *arr1 = [NSArray new];</p>
<p>​                     NSArray *arr2 = [[NSArray alloc] init];</p>
<p>​                     NSArray *arr3 = [NSArray array];</p>
<p>​                     这样创建出来的NSArray数组的元素的个数是0个,因为长度固定.所以没有任何意义</p>
<pre><code>       2). 创建数组的同时指定1个数组的元素
</code></pre>
<p>​                     + (instancetype)<strong>arrayWithObject:</strong>(ObjectType)anObject</p>
<p>​                     NSArray *arr = [NSArray arrayWithObject:@”jack”];</p>
<p>​                     仍然没有意义,因为这个数组中只有1个元素</p>
<pre><code>       3). 最常用的创建NSArray数组的方式.
</code></pre>
<p>​                     + (instancetype)<strong>arrayWithObjects:</strong>(ObjectType)firstObj, …</p>
<p>​                     *<em>NSArray <em>arr = [NSArray arrayWithObjects:@”jack”,@”rose”,@”lili”,@”hanmeimei”,nil];</em></em></p>
<p>​             使用注意</p>
<p>​             1). 只能存储OC对象.不能存储非OC对象.</p>
<p>​             2). <strong>将元素写完以后,最后要写1个nil 表示元素到此结束了.</strong></p>
<pre><code>         3). 创建NSArray数组的简要方式.
</code></pre>
<p>​                     *<em>NSArray <em>arr = @[写上每1个元素的值用逗号分隔.];</em></em></p>
<p>​                     NSArray *arr = @[@”jack”,@”rose”,@”lili”];</p>
<p>​                     <strong>注意:  这种创建方式 不需要在最后加nil</strong></p>
<ol start="4">
<li><p>NSArray数组的使用.</p>
<pre><code>    1). 在NSLog函数中**使用%@可以直接输出NSArray对象中的所有的元素的值**.

    2). NSArray数组中不能存储基本数据类型.不能存储非OC对象.
</code></pre>
</li>
</ol>
<p>​                     nil的本质其实就是0 所以nil无法存储到NSArray数组中.</p>
<pre><code>       3). 这样创建数组没有任何意义.
</code></pre>
<p>​                       NSArray *arr1 = [NSArray new];</p>
<p>​                       NSArray *arr2 = [[NSArray alloc] init];</p>
<p>​                       NSArray *arr3 = [NSArray array];</p>
<p>​             这些数组是没有元素的 而NSArray数组元素无法新增和删除,所以没有任何意义.</p>
<ol start="5">
<li><p>取出存储在NSArray数组中的元素的值.</p>
<pre><code>    1). 可以使用下标取出对应的元素的值.
</code></pre>
</li>
</ol>
<p>​                     *<em>NSArray <em>arr = @[@”jack”,@”rose”,@”lili”];</em></em></p>
<p>​                     NSLog(@”%@”,arr[0]);</p>
<p>​                     NSLog(@”%@”,arr[1]);</p>
<p>​                     NSLog(@”%@”,arr[2]);</p>
<p>​                     如果下标越界 就直接运行报错.</p>
<pre><code>       2). 调用数组对象的对象方法来取出指定下标的元素的值.
</code></pre>
<p>​                    - (ObjectType)objectAtIndex:(NSUInteger)index;</p>
<p>​                     NSArray *arr = @[@”jack”,@”rose”,@”lili”];</p>
<p>​                     NSString *str = [arr objectAtIndex:3];</p>
<p>​                     NSLog(@”%@”,str);</p>
<ol start="6">
<li><p>NSArray数组的其他的常用方法</p>
<pre><code>    1). 得到NSArray数组中的元素的个数.
</code></pre>
</li>
</ol>
<p>​             @property (readonly) NSUInteger <strong>count</strong>;</p>
<pre><code>       2). 判断NSArray数组中是否包含指定的元素.
</code></pre>
<p>​             - (BOOL)<strong>containsObject</strong>:(ObjectType)anObject;</p>
<pre><code>       3). 取到NSArray数组中的第1个元素.
</code></pre>
<p>​             @property (nullable, nonatomic, readonly) ObjectType <strong>firstObject</strong></p>
<p>​             与arr[0]的区别.</p>
<p>​             如果数组中没有任何元素.arr[0]报错. firstObject取到nil 不报错.</p>
<pre><code>       4). 取到NSArray数组中的最后1个元素.
</code></pre>
<p>​             @property (nullable, nonatomic, readonly) ObjectType lastObject</p>
<pre><code>       5). 查找指定的元素在NSArray数组中第一次出现的下标.
</code></pre>
<p>​             - (NSUInteger)indexOfObject:(ObjectType)anObject;</p>
<p>​             如果没有找到 返回的是NSUInteger的最大值.</p>
<ol start="7">
<li><p>NSArray数组的遍历.</p>
<pre><code>    1). 使用for循环来遍历数组中的每1个元素.
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = @[@&quot;jack&quot;,@&quot;rose&quot;,@&quot;lili&quot;,@&quot;jack&quot;,@&quot;rose&quot;,@&quot;lili&quot;];</span><br><span class="line">   for(int i = 0; i &lt; arr.count; i++)</span><br><span class="line">   &#123;</span><br><span class="line">     //NSLog(@&quot;%@&quot;,arr[i]);</span><br><span class="line">     NSLog(@&quot;%@&quot;,[arr objectAtIndex:i]);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​                     原理: 将下标挨个挨个遍历出来 取值.</p>
<pre><code>       2). 使用增强for循环来遍历NSArray数组中的元素.
</code></pre>
<p>​                 a. 语法格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      for(元素类型 变量名 in 数组名)</span><br><span class="line">      &#123;</span><br><span class="line">        直接通过变量名就可以拿到数组中的每1个元素.</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	for(NSString* str in arr)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                 b. 声明在for()中的变量叫做迭代变量.</p>
<p>​                 c. 执行的原理.  </p>
<p>​                      将数组中的第1个元素的值赋值给迭代变量.执行循环体.  </p>
<p>​                      将数组中的第2个元素的值赋值给迭代变量.执行循环体. </p>
<p>​                      将数组中的第3个元素的值赋值给迭代变量.执行循环体.  </p>
<p>​                      …….</p>
<p>​                      将数组中的最后1个元素的值赋值给迭代变量.执行循环体.  </p>
<p>​                      结束循环.</p>
<p>​                 d. 语法总结:</p>
<p>​                      -&gt; 迭代变量的类型和数组中的元素的类型保持一致.</p>
<p>​                      -&gt; 迭代变量的名称可以任意取,根据自己的爱好.</p>
<p>​                      -&gt; in是固定的.</p>
<p>​                      -&gt; 遍历那1个数组,就降数组写在in后面.</p>
<p>​                      -&gt; 循环体里面.迭代变量的值就是元素的值.</p>
<p>​             当NSArray数组中存储的数据的类型不一致时候 迭代变量的类型建议使用id类型.</p>
<pre><code>       3). 使用block遍历.
</code></pre>
<p>​             - (void)<strong>enumerateObjectsUsingBlock</strong>:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block</p>
<p>​             <strong>这是1个方法.这个方法的作用就是来遍历数组中的每1个元素.</strong></p>
<ol start="8">
<li><p>NSArray与字符串的两个方法</p>
<pre><code>    1). 将数组中的元素连接起来组成1个新的字符串.
</code></pre>
</li>
</ol>
<p>​                 - (NSString *)componentsJoinedByString:(NSString *)separator</p>
<p>​             参数: 连接符.</p>
<pre><code>       2). 将字符串以指定的分隔符分成1个数组. 每1部分就是数组的1个元素.    
</code></pre>
<p>​                 - (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator;</p>
<h3 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h3><ol>
<li><p>NSMutableArray是NSArray的子类.</p>
<pre><code>       1). NSMutableArray仍然是1个数组.具备NSArray数组的特点.
</code></pre>
<p>​             只能存储OC对象.每1个元素的紧密相连的.</p>
<pre><code>       2). NSMutableArray相对于父类做的扩展:**NSMutableArray数组的元素可以动态的新增和删掉.**
</code></pre>
<p>​             其他的用法均与NSArray一致.</p>
<p>​             所以: NSArray数组一旦创建,其元素的个数就固定,无法新增删除.</p>
<p>​            NSMutableArray数组.元素可以新增 可以删除. 其他用法和父类一样.</p>
</li>
<li><p>NSMutableArray数组的创建.</p>
<pre><code>            NSMutableArray *arr1 = [NSMutableArray new];

           NSMutableArray *arr2 = [[NSMutableArray alloc] init];

           NSMutableArray *arr3 = [NSMutableArray array];

           这样创建出来的数组对象.数组的元素是0 仍然是有意义的 因为我们可以动态的新增和删除元素

           也可以使用这样的方式来创建可变数组对象.这个数组的元素可以新增和删除.

           NSMutableArray *arr4 = [NSMutableArray arrayWithObjects:@&quot;jack&quot;,@&quot;rose&quot;,@&quot;lili&quot;, nil];

           最容易犯错:这样写是不可以的

           NSMutableArray *arr5 = @[@&quot;jack&quot;,@&quot;rose&quot;,@&quot;lili&quot;];

           @[@&quot;jack&quot;,@&quot;rose&quot;,@&quot;lili&quot;];这是1个NSArray对象.

           arr5是1个子类指针. 子类指针指向父类对象的就有可能会出问题.
</code></pre>
</li>
</ol>
<p> ———插入———</p>
<p> \1. 任意的指针其实可以指向任意的对象.  编译不会报错 只会给1个警告.</p>
<p> \2. 虽然语法上可以乱指.但是你千万别乱指.因为运行的适合可能出错.</p>
<p>  当我们调用指针类型特有的方法的时候</p>
<p> -———————–</p>
<p> \3.  如何往可变数组中新增元素.</p>
<p>   - (void)<strong>addObject</strong>:(ObjectType)anObject; 将传入的参数作为数组的元素添加进去.</p>
<p> \4.  将另外1个数组中的每1个元素添加到可变数组中.</p>
<p>   - (void)<strong>addObjectsFromArray</strong>:(NSArray<ObjectType> *)otherArray;</p>
<p> \5. 在可变数组中指定的下标出插入1个元素.</p>
<p>  - (void)<strong>insertObject</strong>:(ObjectType)anObject <strong>atIndex:</strong>(NSUInteger)index;</p>
<p> -————-</p>
<p> \6. 删除可变数组中指定下标的元素.</p>
<p>  - (void)removeObjectAtIndex:(NSUInteger)index;</p>
<p> \7. 删除可变数组中所有的指定的元素.</p>
<p>  - (void)removeObject:(ObjectType)anObject;</p>
<p> \8. 删除指定范围中的所有指定元素.</p>
<p>  - (void)removeObject:(ObjectType)anObject inRange:(NSRange)range;</p>
<p> \9. 删除最后1个元素</p>
<p>  - (void)removeLastObject;</p>
<p> \10.删除所有的元素.</p>
<p>  - (void)removeAllObjects;</p>
<h3 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h3><ol>
<li><p>无论是NSArray还是NSMutbaleArray里面都只能存储OC对象.</p>
<pre><code>    基本数据类型是无法存储的.
</code></pre>
</li>
<li><p>如何将基本数据类型的数据存储到NSArray数组中.</p>
</li>
<li><p>自定义包装类来包装基本数据类型.</p>
<pre><code>    定义1个类,这个类的对象的作用是用来存储1个int类型的数据.再将这个对象存储到NSArray数组中.
</code></pre>
</li>
<li><p>NSNumber是Foundation框架中定义好的1个类.这个类的对象的作用就是用来包装基本数据类型的.</p>
<pre><code>    将基本数据类型存储到NSArray数组中的步骤.

    1). 先讲基本数据类型包装到NSNumber对象中.

    2). 再降NSNumber对象存储到NSArray数组中
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *number1 = [NSNumber numberWithFloat:10.1f];</span><br><span class="line">NSNumber *number2 = [NSNumber numberWithFloat:10.2f];</span><br><span class="line">NSNumber *number3 = [NSNumber numberWithFloat:10.3f];</span><br><span class="line">  NSArray *arr = @[number1,number2,number3];</span><br><span class="line">  for(NSNumber *num in arr)</span><br><span class="line">  &#123;</span><br><span class="line">     NSLog(@&quot;%f&quot;,num.floatValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>简写方式.</p>
<pre><code>    创建NSNumber对象的简写方式:

    @10;  代表是1个NSNumber对象.这个对象中包装的是整形的10
</code></pre>
</li>
</ol>
<p>​           这个不是整形的10</p>
<pre><code>       [NSNumber numberWithInt:10];
   
   包装注意:
   
        如果后面的数据是1个变量 那么这个变量就必须要使用小括弧括起来.
   
       @(10);
   
       int num = 10;
   
       @(num)
</code></pre>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><ol>
<li><p>NSArray与NSMutableArray 是OC中的数组.</p>
<pre><code>    存储数据的特点:  每1个元素紧密相连.并且每1个元素中都是直接存储的值.
 
    缺点: 数组元素的下标不固定.都有可能会发生变化.无法通过下标来唯一确定数组中的元素.
 
    希望: 有一种存储数据的方式 存储到数组中.可以快速唯一的确定数组的元素.
 
    存储数据的时候.必须要为存储的数据取1个别名.
 
    这个别名的作用: 就是用来确定别名对应的数据的.
 
    要找存储在数组中的数据. 使用别名来找 而不是通过下标来找 因为下标有可能会发生变化.
 
    这种存储数据的方式 就叫做 键值对 的存储方式
 
    Key-Value
 
    Key 就是键 就是为数据取得别名.
 
    Value 就是值 就是真正存储的数据.
</code></pre>
</li>
<li><p>NSDictionary 与 NSMutableDictionary</p>
<pre><code>    1). 它们是数组. 它们就是以键值对的形式存储数据的.
</code></pre>
</li>
</ol>
<p>​             往这个数组中存储数据的同时.必须要指定这个数据的别名才可以.</p>
<p>​             <strong>要找到存储在这个数组中的数据 通过别名来找 而不是通过下标.</strong></p>
<ol start="3">
<li><p>NSDictionary 字典数组</p>
<pre><code>    1). 存储数据的原理.
</code></pre>
</li>
</ol>
<p>​                     a. 以键值对的形式存储数据.</p>
<p>​                     b. 字典数组一旦创建,其中的元素就无法动态的新增和删除.</p>
<p>​                     c. 键: 只能是遵守了NSCoping协议的对象. 而NSString就是遵守了这个协议.</p>
<p>​                      值: 只能是OC对象.</p>
<pre><code>       2). 创建字典数组
</code></pre>
<p>​                     NSDictionary *dict1 = [NSDictionary new];</p>
<p>​                     NSDictionary *dict2 = [[NSDictionary alloc] init];</p>
<p>​                     NSDictionary *dict3 = [NSDictionary dictionary];</p>
<p>​                     <strong>这种方式创建出来的字典数组中没有任何元素.所以没有意义.</strong></p>
<pre><code>       3). 一般创建方式
</code></pre>
<p>​                     + (instancetype)dictionaryWithObjectsAndKeys:(id)firstObject, …</p>
<p>​                     将字典数组的值键 挨个的写在后面初始化.</p>
<p>​         NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@”jack”,@”name”,@”北京市XX街道”,@”address”, nil];</p>
<pre><code>       4). 简要创建方式
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = @&#123;键1:值1,键2:值2,键3:值3,........&#125;;</span><br><span class="line">NSDictionary *dict=@&#123;@&quot;name&quot;:@&quot;rose&quot;,@&quot;age&quot;:@&quot;18&quot;,@&quot;address&quot;:@&quot;BeiJingXXSttreet&quot;&#125;;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><p>使用字典数组.</p>
<pre><code>    1). 如何取出存储在字典数组中的数据.
</code></pre>
</li>
</ol>
<p>​                     a. 存储在字典数组中的元素不能使用下标去取 而是用键 也就是别名去取.</p>
<p>​                     -&gt; 使用中括弧的方式.</p>
<p>​                      字典数组名[键]; 这样就可以去到字典数组中这个键对应的值.</p>
<p>​                      <strong>NSLog(@”%@”,dict[@”name”]);</strong> 取出dict字典数组中@”name”这个键对应的值</p>
<p>​                     -&gt; 调用字典数组对象的方法也可以取出键对应的值.</p>
<p>​                      <strong>- (nullable ObjectType)objectForKey:(KeyType)aKey;</strong></p>
<p>​                    如果给定的key在数组中不存在,取到的值是nil 不会报错.</p>
<pre><code>       2). 取到字典数组的键值对的个数.
</code></pre>
<p>​                     @property (readonly) NSUInteger count;</p>
<pre><code>       3). 往字典数组中存储键值对的时候 键不允许重复
</code></pre>
<p>​                     如果键重复: 后加的无效.. ???????????????</p>
<ol start="5">
<li><p>遍历字典数组</p>
<pre><code>    1). 字典数组中的数据无法使用下标去取 所以普通的for循环遍历下标发就无用武之地了.

    2). 使用for in循环. **遍历出来的是字典数组中所有的键. 再通过键取出对应的值.**
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = @&#123;</span><br><span class="line">    @&quot;name&quot;:@&quot;rose&quot;,</span><br><span class="line">    @&quot;age&quot;:@&quot;18&quot;,</span><br><span class="line">    @&quot;address&quot;:@&quot;BeiJingXXSttreet&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(id item in dict)</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;%@ = %@&quot;,item,dict[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>      3). 使用block遍历.
</code></pre>
<p>​             [dict <strong>enumerateKeysAndObjectsUsingBlock</strong>:^(id  _Nonnull <strong>key</strong>, id  _Nonnull <strong>obj</strong>, BOOL * _Nonnull <strong>stop</strong>) {</p>
<p>​        NSLog(@”%@ = %@”,key,obj);</p>
<p>​             }];</p>
<ol start="6">
<li><p>字典数组存储数据的原理.</p>
<pre><code>    1). 当往字典数组中存储1个键值对的时候,这个键值对应该存储在下标为几的元素中呢?
</code></pre>
</li>
</ol>
<p>​                     -&gt; 并不是按照顺序挨个挨个的存储的.</p>
<p>​                     -&gt; 存储键值对的时候,会根据键和数组的长度做1个哈希算法.算出1个下标.将这个键值对存储在该下标处.</p>
<pre><code>       2). 取值的时候:
</code></pre>
<p>​                     也是根据键做1个哈希算法.就可以算出这个键值对存储的下标 然后直接找到这个下标的数据取出就可以了</p>
<pre><code>       与NSArray对比
   
               1). NSArray数组的元素 挨个挨个的屁股后面. 按照顺序来存储的.
</code></pre>
<p>​                     字典数组中不是挨个挨个的存储的.存储的下标是算出来的</p>
<pre><code>               2). **存的效率: 肯定是NSArray要高一些.**
</code></pre>
<p>​                     取得时候: 如果取值的时候,是全部一股脑的取出来.这个时候NSArray块一些.</p>
<p>​                     如果取值的时候.只会取数组中指定的几个元素.字典数组取值更快一些.</p>
<pre><code>      什么时候是有NSArray 什么时候使用字典数组?
  
      存储进去之后,一旦要取值.就是全部取出. NSArray
  
      存储进去之后.取值只会取指定的几个元素 字典数组.
</code></pre>
<p> -————————————————–</p>
<h3 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h3><ol>
<li><p>NSMutableDictionary</p>
<pre><code>   1). 是NSDictionary的子类.所以NSMutableDictionary也是1个字典数组,也是以键值对的形式存储数据的.

   2). 重点:NSMutableDictionary在父类基础之上做的扩张:
</code></pre>
</li>
</ol>
<p>​                    <strong>存储在其中的元素可以动态的新增和删除.</strong></p>
<pre><code>      3). 创建可变字典数组.
</code></pre>
<p>​                     NSMutableDictionary *dict1 = [NSMutableDictionary new];</p>
<p>​                     NSMutableDictionary *dict2 = [[NSMutableDictionary alloc] init];</p>
<p>​                     NSMutableDictionary *dict3 = [NSMutableDictionary dictionary];</p>
<p>​                     这样创建出来的可变字典数组的长度为0 但是有意义 因为可以动态的新增和删除.</p>
<p>​                     *<em>NSMutableDictionary <em>dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@”jack”,@”name”,@”18”,@”age”, nil];</em></em></p>
<p>​                     在创建可变字典数组的同时初始化键值对.</p>
<p>​                     *<em>注意:  NSMutableDictionary <em>dict = @{}; 这样是不行的.</em></em></p>
<ol start="2">
<li><p>如何新增键值对.</p>
<pre><code>           \- (void)**setObject:**(ObjectType)anObject **forKey:**(KeyType &lt;NSCopying&gt;)aKey;

           如果键重复.后添加的就会替换原有的.
</code></pre>
</li>
<li><p>如何删除.</p>
<pre><code>           \- (void)removeAllObjects; 删除所有的键值对.

           \- (void)removeObjectForKey:(KeyType)aKey; 删除指定的键值对.
</code></pre>
</li>
<li><p>也可以将字典数组的信息持久化起来.</p>
<pre><code>           将字典数组的信息保存到plist文件中.

           \- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;

           从plist文件中还原回字典.

           \+ (nullable NSDictionary&lt;KeyType, ObjectType&gt; *)dictionaryWithContentsOfFile:(NSString *)path;
</code></pre>
</li>
</ol>
<h3 id="集合的内存管理"><a href="#集合的内存管理" class="headerlink" title="集合的内存管理"></a>集合的内存管理</h3><ol>
<li><p>集合</p>
<pre><code>    NSArray集合、NSDictionary字典集合 就叫做集合.
</code></pre>
</li>
<li><p>在<strong>MRC的模式下</strong> 将1个对象存储到集合中,会不会影响对象的引用计数器.</p>
<pre><code>    **将对象存储到集合之中,会为这个对象的引用计数器+1**
 
    **当集合销毁的时候 就会像存储在集合中的所有的对象发送1条release消息.**
</code></pre>
</li>
<li><p>使用@[]或者@{}创建的集合已经是被autorelease过的了.   </p>
<pre><code>    直接调用和类同名的类方法创建的对象 也是被autorelease过的了.
</code></pre>
</li>
<li><p>在ARC的模式下.集合的元素是1个强类型的指针.</p>
</li>
</ol>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><ol>
<li><p>NSFileManger是Foundation框架提供的1个类.  </p>
<pre><code>    这个类作用: 用来操作磁盘上的文件 文件夹  对他们进行创建、删除、复制 拷贝 移动.....
</code></pre>
</li>
<li><p>NSFileManager是1个类.</p>
<pre><code>    这个类的对象是以单例模式创建的.

    如何得到NSFileManager的1个单例对象.

   掉用这个类的类方法,defaultManager 就可以得到这个类的单例对象

   NSFileManager *fileManager = [NSFileManager defaultManager];
</code></pre>
</li>
<li><p>常用方法之 判断.</p>
<pre><code>    1). 判断指定的文件或者文件夹在磁盘上是否真实的存在
</code></pre>
</li>
</ol>
<p>​            - (BOOL)fileExistsAtPath:(NSString *)path;</p>
<pre><code>       2).判断指定的路径是否真实的存储在我们的磁盘之上,并且判断这个路径是1个文件夹路径还是1个文件路径.
</code></pre>
<p>​            - (BOOL)fileExistsAtPath:(NSString *)path isDirectory:(BOOL *)isDirectory;</p>
<p>​            返回值:代表这个路径是否真实存在.</p>
<p>​            参数指针: 代表这个路径是否是1个文件夹路径</p>
<pre><code>       3). 判断指定的文件夹或者文件是否可以读取.
</code></pre>
<p>​             - (BOOL)isReadableFileAtPath:(NSString *)path;</p>
<pre><code>       4). 判断指定的文件夹或者文件是否可以写入.
</code></pre>
<p>​             - (BOOL)isWritableFileAtPath:(NSString *)path;</p>
<pre><code>       5). 判断指定的文件夹或者文件是否可以删除.
</code></pre>
<p>​             - (BOOL)isDeletableFileAtPath:(NSString *)path</p>
<ol start="4">
<li><p>常见方法之 获取信息.</p>
<pre><code>   1).获取指定文件或者文件夹的属性信息.
</code></pre>
</li>
</ol>
<p>​            - (NSDictionary *)attributesOfItemAtPath:(NSString *)path error:(NSError **)error</p>
<p>​            返回的是1个字典,如果要拿到特定的信息 通过key</p>
<pre><code>      2).获取指定目录下的所有的文件和目录. 是拿到指定目录下的所有的文件和目录 所有的后代目录和文件.
</code></pre>
<p>​            子目录的子目录的子目录 所有的都可以拿到.</p>
<p>​            - (NSArray *)subpathsAtPath:(NSString *)path;</p>
<pre><code>      3).获取指定目录下的所有的子目录和文件 不保护孙子辈.
</code></pre>
<p>​            - (NSArray *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error</p>
<ol start="5">
<li><p>常见方法之 文件/目录的创建</p>
<pre><code>   1). 在指定的目录创建文件.
</code></pre>
</li>
</ol>
<p>​            - (BOOL)createFileAtPath:(NSString *)path contents:(NSData *)data attributes:(NSDictionary *)attr</p>
<p>​              第1个参数: 要创建的文件的路径.</p>
<p>​              第2个参数: 这个文件的内容.  要传递这个文件的二进制格式. </p>
<p>​              这个二进制的数据格式 使用NSData对象来封装.</p>
<p>​               NSData: 将别的格式的数据转换为二进制数据.</p>
<p>​              将字符串转换为NSData二进制的方式.调用字符串对象的</p>
<p>​              - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding</p>
<p>​              编码参数: NSUTF8StringEncoding</p>
<p>​              指定1个编码 就可以将字符串转换为二进制数据 存储在NSData对象之中.</p>
<p>​              最后再将这个二进制对象通过这个方法写入.</p>
<p>​              如果想创建1个空文件 第2个参数就给nil</p>
<p>​             第3个参数: 指定创建的文件的属性.如果想要使用系统的默认值使用nil</p>
<pre><code>  2). 在指定的目录创建文件夹.
</code></pre>
<p>​        - (BOOL)createDirectoryAtPath:(NSString *)path withIntermediateDirectories:(BOOL)createIntermediates attributes:(NSDictionary *)attributes error:(NSError **)error</p>
<p>​            第1个参数: 路径.</p>
<p>​            第2个参数: YES,做一路创建. 如果是NO就不会做一路创建.</p>
<p>​            第3个参数: 指定属性 nil为系统默认属性.</p>
<p>​            第4个参数.</p>
<pre><code>  3).拷贝文件.
</code></pre>
<p>​        - (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error</p>
<pre><code>  4).移动文件 剪切 文件的重命名. 重名的原理: 将文件移动到原来的目录并改名.
</code></pre>
<p>​        - (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error</p>
<pre><code>  5).删除文件.
</code></pre>
<p>​        - (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error</p>
<pre><code>   注意 删除的文件不会倒废纸篓 而是直接删除,所以请小心使用.
</code></pre>
<h3 id="Foundation框架中常用的结构体"><a href="#Foundation框架中常用的结构体" class="headerlink" title="Foundation框架中常用的结构体"></a>Foundation框架中常用的结构体</h3><ol>
<li><p>定义1个变量来保存按钮在iOS界面上得位置. </p>
<pre><code>    我们定义1个结构体来表示控件在界面上得坐标.
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> int x;</span><br><span class="line"> int y;</span><br><span class="line">&#125;CZPoint;</span><br><span class="line">CZPoint p1 = &#123;20,30&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>       在Foundation框架中,已经定义了1个结构体CGPoint.
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct CGPoint &#123;</span><br><span class="line"> CGFloat x;</span><br><span class="line"> CGFloat y;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CGPoint CGPoint;</span><br></pre></td></tr></table></figure>

<pre><code>       CGFloat类型的实际上就是1个double类型的.
   
       这个结构体一般情况下是用来表示坐标的. 用来表示控件在界面上得位置.
   
       CGPoint与NSPoint都是同1个结构体,只不过定义两个名字.
   
       typedef CGPoint NSPoint;
</code></pre>
<p>   ———声明CGPoint变量并初始化的方式——-</p>
<pre><code>       1). CGPoint p1;
</code></pre>
<p>​                     p1.x = 20;</p>
<p>​                     p1.y = 30；</p>
<pre><code>       2). CGPoint p1 = &#123;20,30&#125;;
   
       3). CGPoint p1 = &#123;.x = 20, .y = 30&#125;；
   
       4). Foundation框架中提供的函数来快速的创建1个CGPoint变量.
</code></pre>
<p>​             a. <strong>CGPointMake(x,y);</strong></p>
<p>​                  <strong>CGPoint p1 =  CGPointMake(20, 30);</strong></p>
<p>​             b. <strong>NSMakePoint(x,y);</strong></p>
<p>​                  <strong>NSPoint p2 =  NSMakePoint(20, 30);</strong></p>
<ol start="2">
<li><p>声明1个变量来保存某个控件的大小.</p>
<pre><code>    1个控件的大小,无非就是两个数据. 宽度、高度.
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  double width;</span><br><span class="line">  double height;</span><br><span class="line">&#125;CZSize;</span><br><span class="line">CZSize size = &#123;50,20&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>       Foundation框架中已经定义好了1个结构体叫做CGSize;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct CGSize &#123;</span><br><span class="line">   CGFloat width;</span><br><span class="line">   CGFloat height;</span><br><span class="line">  &#125;;</span><br><span class="line">  typedef struct CGSize CGSize;</span><br><span class="line">  typedef CGSize NSSize;</span><br></pre></td></tr></table></figure>

<p>   <strong>NSSize和CGSize是同1个结构体,只不过定义了两个名称.</strong></p>
<p>   <strong>CGSize结构体一般情况下用来表示控件的大小.</strong></p>
<p>   ——CGSize声明并初始化的方式———-</p>
<pre><code>       1). CGSize size;
</code></pre>
<p>​                 size.width = 100;</p>
<p>​                 size.height = 30;</p>
<pre><code>       2). CGSize size = &#123;100,30&#125;;
   
       3). CGSize size = &#123;.width = 100, .height = 30&#125;;
   
       4). Foundation框架中提供了函数用来快速的得到1个CGSize结构体变量.
</code></pre>
<p>​                 a. CGSizeMake(width,height);</p>
<p>​                   CGSize size0 =  CGSizeMake(100, 30);</p>
<p>​                 b. NSMakeSize(w,h);</p>
<p>​                   CGSize size1 =  NSMakeSize(100, 30);</p>
<ol start="3">
<li><p>CGRect和NSRect</p>
<pre><code>    这是定义在Foundation框架中的1个结构体.
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct CGRect &#123;</span><br><span class="line">   CGPoint origin;</span><br><span class="line">   CGSize size;</span><br><span class="line"> &#125;;</span><br><span class="line"> typedef struct CGRect CGRect;</span><br></pre></td></tr></table></figure>

<pre><code>       所以,这个结构体变量一般情况下存储1个控件的位置和大小.
   
       typedef CGRect NSRect;
   
       **NSRect和CGRect是一样的.**
</code></pre>
<p>   —-CGRect的声明和初始化—–</p>
<pre><code>       1).
</code></pre>
<p>​                 CGRect rect;</p>
<p>​                 rect.origin.x = 20;</p>
<p>​                 rect.origin.y = 40;</p>
<p>​                 rect.size.width = 100;</p>
<p>​                 rect.size.height = 30;</p>
<p>​         当结构体作为另外1个结构体或者对象的1个属性的时候,不能直接{}赋值.</p>
<p>​                 CGRect rect;</p>
<p>​                 rect.origin = (CGPoint){10,20};</p>
<p>​                 rect.size = (CGSize){100,30};</p>
<pre><code>       2). 也提供了函数来快速的创建CGRect变量
</code></pre>
<p>​                 CGRect rect =  CGRectMake(10, 20, 100, 30);</p>
<p>​                 CGRect rect1 =  NSMakeRect(10, 20, 100, 30);</p>
<pre><code>     使用的时候. CGSize NSSize  建议使用CG...
</code></pre>
<h3 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h3><ol>
<li><p>我们之前学习的结构体.</p>
<pre><code>    NSRange
 
    CGPoint
 
    CGSize
 
    CGRect
 
    这些都是结构体,它们的变量是无法存储到集合之中.
</code></pre>
</li>
<li><p>解决方案:</p>
<pre><code>    先将这写结构体变量存储到OC对象中,再将OC对象存储到集合之中.
</code></pre>
</li>
<li><p>NSValue 类 的对象就是用来包装结构体变量的.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;  </span><br><span class="line">     CGSize s1 =   CGSizeMake(100, 10);</span><br><span class="line">     CGSize s2 =   CGSizeMake(100, 10);</span><br><span class="line">     CGSize s3 =   CGSizeMake(100, 10);</span><br><span class="line">     CGSize s4 =   CGSizeMake(100, 10);</span><br><span class="line">   </span><br><span class="line">     NSValue *v1 = [NSValue valueWithSize:s1];</span><br><span class="line">     NSValue *v2 = [NSValue valueWithSize:s2];</span><br><span class="line">     NSValue *v3 = [NSValue valueWithSize:s3];</span><br><span class="line">     NSValue *v4 = [NSValue valueWithSize:s4];</span><br><span class="line"></span><br><span class="line">    NSArray *arr = @[v1,v2,v3,v4];</span><br><span class="line">    for(NSValue *v in arr)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromSize(v.sizeValue));</span><br><span class="line">    &#125;</span><br><span class="line">//    CGPoint p1 =  CGPointMake(10, 20);</span><br><span class="line">//    CGPoint p2 =  CGPointMake(110, 120);</span><br><span class="line">//    CGPoint p3 =  CGPointMake(110, 320);</span><br><span class="line">//    CGPoint p4 =  CGPointMake(110, 240);</span><br><span class="line">//    NSValue *v1 = [NSValue valueWithPoint:p1];</span><br><span class="line">//    NSValue *v2 = [NSValue valueWithPoint:p2];</span><br><span class="line">//    NSValue *v3 = [NSValue valueWithPoint:p3];</span><br><span class="line">//    NSValue *v4 = [NSValue valueWithPoint:p4]; </span><br><span class="line">//    NSArray *arr = @[v1,v2,v3,v4];  </span><br><span class="line">//    for(NSValue *v in arr)</span><br><span class="line">//    &#123;</span><br><span class="line">//        NSLog(@&quot;%@&quot;,NSStringFromPoint(v.pointValue));</span><br><span class="line">//    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h3><ol>
<li><p>NSDate 时间处理.</p>
<pre><code>   1). 可以得到当前时间. 创建1个NSDate对象就可以了,将这个对象输出,就是当前时间
</code></pre>
</li>
</ol>
<p>​                    得到的是当前系统的格林威治时间. 0时区的时间. 东8区</p>
<p>​                    NSDate *date = [NSDate date];</p>
<p>​                    NSLog(@”%@”,date);</p>
<pre><code>      2). 格式化输出日期. 指定日期输出的格式
</code></pre>
<p>​                    默认的格式 年-月-日 时:分:秒 +时区.</p>
<p>​                     NSDate *date = [NSDate date];</p>
<p>​                     NSLog(@”%@”,date);</p>
<p>​             //1.先要创建1个NSDateFormatter对象,这个对象作用:将1个日期转换成1个指定的格式.</p>
<p>​                     NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</p>
<p>​             //2.告诉这个日期格式化器对象 要把日期转换个什么样子的.</p>
<p>​                     yyyy: 年份</p>
<p>​                     MM: 月份.</p>
<p>​                     mm: 分钟.</p>
<p>​                     dd: 天.</p>
<p>​                     hh: 12小时.</p>
<p>​                     HH: 24小时</p>
<p>​                     ss: 秒</p>
<p>​             <strong>formatter.dateFormat = @”yyyy年MM月dd日 HH点mm分ss秒”</strong></p>
<p>​             //3.使用日期格式化器 将指定的日期转换指定格式的字符串.</p>
<p>​                     *<em>NSString <em>str =[formatter stringFromDate:date];</em></em></p>
<p>​                     <strong>NSLog(@”str = %@”,str);</strong></p>
<pre><code>             **\- (NSString *)stringFromDate:(NSDate *)date; //将日期类型换换为字符串**
 
             **\- (NSDate *)dateFromString:(NSString *)string;//将字符串转换为日期对象.**
 
      注意: NSDate取到的时间是格林威治的时间.
</code></pre>
<p>​          NSDateFormatter转换成字符串以后 会转换为当前系统的时区的时间.</p>
<ol start="2">
<li><p>计算时间.</p>
<pre><code>   1). 想得到明天此时此刻的时间.
</code></pre>
</li>
</ol>
<p>​                当前时间的基础之上 + 1天的时间.</p>
<p>​                在当前时间的基础之上,新增指定的时间.得到的1个新的时间.</p>
<p>​                        + (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;</p>
<p>​                在当前的时间的基础之上,新增指定的秒.后的时间</p>
<p>​                得到东八区的时间:</p>
<p>​                        NSDate <em>d1 =[NSDate dateWithTimeIntervalSinceNow:8</em>60*60];</p>
<p>​                传入1个负数 就是在当前时间的基础之上减指定的秒数.</p>
<pre><code>      2). 求两个时间之间的差.
</code></pre>
<p>​                可以实现的效果.就是可以计算出执行代码所花费的时间.</p>
<p>​                    - (NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate;</p>
<ol start="3">
<li><p>得到NSDate中的年月日时分秒.</p>
<pre><code>   1). 得到时间的各个部分。可以使用日期格式化器来得到.

   2). 比较复杂.

           NSDate *date = [NSDate date];

           //1.创建1个日历对象. 调用类方法currentCalendar得到1个日历对象.

               NSCalendar *calendar = [NSCalendar currentCalendar];

           //2.指定日历对象取到日期的对象的那些部分. 是要取那1个时间对象的部分.

           // 返回1个日期组件对象.这个对象中就有指定日期的指定部分.

               NSDateComponents *com =  [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:date];

               NSLog(@&quot;%ld-%ld-%ld&quot;,com.year,com.month,com.day);
</code></pre>
</li>
</ol>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><ol>
<li><p>无论在MRC还是ARC下,<strong>如果属性的类型是NSString类型的. @property参数使用copy.</strong></p>
<p>@property(nonatomic,copy) NSString* name;</p>
</li>
<li><p>copy 复制</p>
<pre><code>    1). copy是1个方法.定义在NSObject类之中. 作用:拷贝对象.
</code></pre>
</li>
</ol>
<p>​                     <strong>NSString —-&gt; copy —&gt; 不可变字符串  没有产生新对象,而是直接将对象本身的地址返回. 这种拷贝我们叫做浅拷贝</strong></p>
<p>​                     NSMutableString –&gt; copy –&gt; 是1个不可变的字符串对象 .  有产生1个新对象.这样的拷贝我们叫做深拷贝.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString* str1=@&quot;jack&quot;;</span><br><span class="line">NSString*str2=[str1 copy];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString* str1=[NSMutableString stringWithFormat:@&quot;jack&quot;];</span><br><span class="line">NSString* str2=[str1 copy];</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/zengxiang21/img/main/img/202204281733429.png" alt="image-20220428173316258" style="zoom:50%;" />

<p>​    2). mutableCopy.定义在NSObject类之中. 作用:拷贝对象.</p>
<p>​                     NSString  —&gt; mutableCopy –&gt; 可变字符串对象. 深拷贝.</p>
<p>​                     NSMutableString –&gt; mutableCopy –&gt; 可变字符串对象 深拷贝</p>
<pre><code>                这是字符串的对象拷贝特点
</code></pre>
<ol start="3">
<li><p>字符串对象拷贝的引用计数器的问题.</p>
<pre><code>    1). 若字符串对象存储在常量区中. **存储在常量区的数据是不允许被回收的.**
</code></pre>
</li>
</ol>
<p>​             <strong>所以存储在常量区的字符串对象的引用计数器是1个超大的数.并且retain和release无效.</strong></p>
<pre><code>       2). 若字符串存储在堆区. 这个字符串对象和普通的对象一样的.引用计数器默认是1.
   
       3). 字符串对象如果是浅拷贝. 会将对象的引用计数器+1
</code></pre>
<p>​             字符串对象如果是深拷贝. 原来的对象的引用计数器不变.新拷贝出来的对象的引用计数器为1.</p>
<h3 id="自定义类拷贝"><a href="#自定义类拷贝" class="headerlink" title="自定义类拷贝"></a>自定义类拷贝</h3><ol>
<li><p>copy方法的确是定义在NSObject类中的1个方法.</p>
<pre><code>    copy方法的内部调用了另外1个方法. copyWithZone:

    这个方法是定义在NSCoping协议之中的.

   因为我们的类没有遵守NSCoping协议,那么我们的类中就没有 copyWithZone:这个方法.  

   所以,当我们自定义的类调用copy方法的时候就会出错/
</code></pre>
</li>
<li><p><strong>如果我们想要让我们自己的类具备对象拷贝的能力.那么就让我们的类遵守NSCoping协议</strong></p>
<pre><code>   **并实现copyWithZone:这个方法.** 

   **如果想要实现深拷贝:那么就重新创建1个对象.并将对象的属性的值复制.返回.**

   **如果想要实现浅拷贝:那么就直接返回self**
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Person : NSObject &lt;NSCopying&gt;</span><br><span class="line">@property(nonatomic,copy)NSString *name;</span><br><span class="line">@property(nonatomic,assign)int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    //1.如果要做深拷贝.你就重新创建1个对象.</span><br><span class="line">    //  把对象的属性的值 复制 到新对象中 将新对象返回.  </span><br><span class="line">//    Person *p1 = [Person new];</span><br><span class="line">//    p1.name = _name;</span><br><span class="line">//    p1.age = _age;</span><br><span class="line">//    return p1;  </span><br><span class="line">    return self;   </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//main.m</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Person *p1 = [Person new];</span><br><span class="line">    p1.name = @&quot;jack&quot;;</span><br><span class="line">    p1.age = 18;</span><br><span class="line">    Person *p2 =  [p1 copy];</span><br><span class="line">    NSLog(@&quot;p1 = %p&quot;,p1);</span><br><span class="line">    NSLog(@&quot;p2 = %p&quot;,p2);   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol>
<li><p>单例模式:</p>
<pre><code>    1个类的对象,无论在何时创建也无论在什么地方创建 也无论创建多少次.创建出来的都是同1个对象。
</code></pre>
</li>
<li><p>无论如何创建对象,最终都会调用alloc方法来创建对象.</p>
<pre><code>    1). **alloc方法的内部. 其实什么都没有做,只是调用了allocWithZone:方法**.
 
    2). **实际上真正申请空间 创建对象的事情是allocWithZone:方法在做.**
</code></pre>
</li>
<li><p>要实现单例模式.</p>
<pre><code>    重写+ allocWithZone:
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">  static id instance = nil;</span><br><span class="line">  if(instance == nil)</span><br><span class="line">  &#123;</span><br><span class="line">   instance = [super allocWithZone:zone];</span><br><span class="line">  &#125;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>单例模式的规范:</p>
<pre><code>    **如果类是1个单例模式.要求为类提供1个类方法.来返回这个单例对象.**
 
    **类方法的名称必须以 shared类名; default类名;**
</code></pre>
</li>
<li><p>什么时候要把类搞成单例.</p>
<pre><code>    1). 单例的特点
</code></pre>
</li>
</ol>
<p>​                 无论何时、何地、创建对象,也不管创建多少次对象,得到都是同1个对象.</p>
<p>​                 单例对象可以被共享. 存储在单例对象中的数据可以被共享.</p>
<p>​                 也就是无论在什么地方创建单例对象 访问的都是同1个对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    static id instance = nil;</span><br><span class="line">    if(instance == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)sharedPerson</span><br><span class="line">&#123;</span><br><span class="line">    return [self new];</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)defaultPerson</span><br><span class="line">&#123;</span><br><span class="line">    return [self new];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zengxiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zengxiang21.github.io/2022/03/24/objective-c/">https://zengxiang21.github.io/2022/03/24/objective-c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zengxiang21.github.io" target="_blank">zx的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/id/701/1858/1393" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/01/12/vue/"><img class="next-cover" src="https://picsum.photos/id/306/1024/768" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zengxiang</div><div class="author-info__description">zx的博客,欢迎访问</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zengxiang21" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#objective-C%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">objective-C概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5"><span class="toc-number">1.3.</span> <span class="toc-text">未来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.4.</span> <span class="toc-text">学习路线</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">第一个程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oc%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">oc基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">3.0.1.</span> <span class="toc-text">#import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">3.0.2.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSlog"><span class="toc-number">3.0.3.</span> <span class="toc-text">NSlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSString"><span class="toc-number">3.0.4.</span> <span class="toc-text">NSString</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%92%8C%E5%85%B6%E4%BB%96%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">c语言中字符指针和其他指针的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NS%E5%89%8D%E7%BC%80"><span class="toc-number">3.0.5.</span> <span class="toc-text">NS前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-number">3.0.6.</span> <span class="toc-text">@符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.7.</span> <span class="toc-text">类的定义实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.8.1.</span> <span class="toc-text">对象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.8.2.</span> <span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.8.3.</span> <span class="toc-text">对象方法声明和实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">3.0.8.4.</span> <span class="toc-text">对象属性默认值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.0.9.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.0.9.1.</span> <span class="toc-text">打印指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.10.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">3.0.11.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%9C%B0%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.11.1.</span> <span class="toc-text">查看类在代码段地址方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.0.12.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSObject%E7%B1%BB"><span class="toc-number">3.0.12.1.</span> <span class="toc-text">NSObject类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.0.12.2.</span> <span class="toc-text">super关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.0.13.</span> <span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">3.0.13.1.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D"><span class="toc-number">3.0.13.2.</span> <span class="toc-text">“%@”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%AD%98%E5%82%A8%E7%B1%BB%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.0.13.3.</span> <span class="toc-text">代码段存储类的步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEL"><span class="toc-number">3.0.14.</span> <span class="toc-text">SEL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.14.1.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.14.2.</span> <span class="toc-text">使用.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setter%E5%92%8Cgetter"><span class="toc-number">3.0.14.3.</span> <span class="toc-text">setter和getter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.0.15.</span> <span class="toc-text">.语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property"><span class="toc-number">3.0.16.</span> <span class="toc-text">@property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synthesize"><span class="toc-number">3.0.17.</span> <span class="toc-text">@synthesize</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%90%8E%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-property%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%85"><span class="toc-number">3.0.17.1.</span> <span class="toc-text">以后只需要写@property，编译器会自动补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.18.</span> <span class="toc-text">静态类型和动态类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSObject"><span class="toc-number">3.0.19.</span> <span class="toc-text">NSObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id%E6%8C%87%E9%92%88"><span class="toc-number">3.0.20.</span> <span class="toc-text">id指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#id%E6%8C%87%E9%92%88%E5%92%8CNSObject%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.20.1.</span> <span class="toc-text">id指针和NSObject区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA1%E4%B8%AA%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E"><span class="toc-number">3.0.20.2.</span> <span class="toc-text">父类中的类方法创建1个父类对象返回.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFinstancetype"><span class="toc-number">3.0.20.3.</span> <span class="toc-text">一、什么是instancetype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81id%E5%92%8Cinstancetype%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.20.4.</span> <span class="toc-text">二、id和instancetype的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%80"><span class="toc-number">3.0.20.4.1.</span> <span class="toc-text">区别一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BA%8C"><span class="toc-number">3.0.20.4.2.</span> <span class="toc-text">区别二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%89"><span class="toc-number">3.0.20.4.3.</span> <span class="toc-text">区别三</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A3%80%E6%B5%8B"><span class="toc-number">3.0.21.</span> <span class="toc-text">动态检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.22.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAMRC%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.0.23.</span> <span class="toc-text">第一个MRC程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.24.</span> <span class="toc-text">野指针和僵尸对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.0.25.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property%E5%8F%82%E6%95%B0"><span class="toc-number">3.0.26.</span> <span class="toc-text">property参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class"><span class="toc-number">3.0.27.</span> <span class="toc-text">@class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.0.28.</span> <span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0-MRC%E5%B8%B8%E7%94%A8"><span class="toc-number">3.0.29.</span> <span class="toc-text">自动释放池(MRC常用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC"><span class="toc-number">3.0.30.</span> <span class="toc-text">ARC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC%E4%B8%8B%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.31.</span> <span class="toc-text">ARC下单个对象内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC%E4%B8%8B%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.32.</span> <span class="toc-text">ARC下多个对象内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC%E4%B8%8B%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.0.33.</span> <span class="toc-text">ARC下的循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">3.0.34.</span> <span class="toc-text">@property参数总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MRC-ARC%E8%BD%AC%E5%8C%96"><span class="toc-number">3.0.35.</span> <span class="toc-text">MRC ARC转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">3.0.36.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%AD%A3%E5%BC%8F%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.0.37.</span> <span class="toc-text">非正式协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.0.38.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E5%B1%95"><span class="toc-number">3.0.39.</span> <span class="toc-text">延展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-number">3.0.40.</span> <span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.41.</span> <span class="toc-text">block的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.0.42.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6"><span class="toc-number">3.0.43.</span> <span class="toc-text">协议类型限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.44.</span> <span class="toc-text">代理设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foundation%E6%A1%86%E6%9E%B6"><span class="toc-number">3.0.45.</span> <span class="toc-text">Foundation框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSString%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98"><span class="toc-number">3.0.46.</span> <span class="toc-text">NSString常用成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSString%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.47.</span> <span class="toc-text">NSString常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98"><span class="toc-number">3.0.48.</span> <span class="toc-text">字符串常用成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSMutableString"><span class="toc-number">3.0.49.</span> <span class="toc-text">NSMutableString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSArray"><span class="toc-number">3.0.50.</span> <span class="toc-text">NSArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSMutableArray"><span class="toc-number">3.0.51.</span> <span class="toc-text">NSMutableArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSNumber"><span class="toc-number">3.0.52.</span> <span class="toc-text">NSNumber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSDictionary"><span class="toc-number">3.0.53.</span> <span class="toc-text">NSDictionary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSMutableDictionary"><span class="toc-number">3.0.54.</span> <span class="toc-text">NSMutableDictionary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.55.</span> <span class="toc-text">集合的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSFileManager"><span class="toc-number">3.0.56.</span> <span class="toc-text">NSFileManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foundation%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.0.57.</span> <span class="toc-text">Foundation框架中常用的结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSValue"><span class="toc-number">3.0.58.</span> <span class="toc-text">NSValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSDate"><span class="toc-number">3.0.59.</span> <span class="toc-text">NSDate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy"><span class="toc-number">3.0.60.</span> <span class="toc-text">copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.0.61.</span> <span class="toc-text">自定义类拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.62.</span> <span class="toc-text">单例模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/24/objective-c/" title="Objective-C"><img src="https://picsum.photos/id/701/1858/1393" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Objective-C"/></a><div class="content"><a class="title" href="/2022/03/24/objective-c/" title="Objective-C">Objective-C</a><time datetime="2022-03-24T08:11:43.297Z" title="发表于 2022-03-24 16:11:43">2022-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/vue/" title="Vue"><img src="https://picsum.photos/id/306/1024/768" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/2022/01/12/vue/" title="Vue">Vue</a><time datetime="2022-01-12T11:55:24.457Z" title="发表于 2022-01-12 19:55:24">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/node/" title="Nodejs"><img src="https://picsum.photos/id/369/4692/3128" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nodejs"/></a><div class="content"><a class="title" href="/2022/01/11/node/" title="Nodejs">Nodejs</a><time datetime="2022-01-11T12:42:19.228Z" title="发表于 2022-01-11 20:42:19">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/12/Ajax/" title="Ajax"><img src="https://picsum.photos/id/144/4912/2760" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ajax"/></a><div class="content"><a class="title" href="/2021/12/12/Ajax/" title="Ajax">Ajax</a><time datetime="2021-12-12T02:18:29.742Z" title="发表于 2021-12-12 10:18:29">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/jQuery/" title="jQuery"><img src="https://picsum.photos/id/908/1920/1280" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery"/></a><div class="content"><a class="title" href="/2021/12/03/jQuery/" title="jQuery">jQuery</a><time datetime="2021-12-03T02:28:02.101Z" title="发表于 2021-12-03 10:28:02">2021-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zengxiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>